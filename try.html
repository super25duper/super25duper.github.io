<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Firebase Storage Upload (v12) - Full Deep Debug</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 980px; margin: 40px auto; padding: 0 16px; }
    button { padding: 10px 14px; cursor: pointer; margin-inline-end: 8px; margin-top: 8px; }
    button:disabled { opacity: .55; cursor: not-allowed; }
    progress { width: 100%; height: 18px; margin-top: 12px; display:none; }
    .log { font-family: monospace; background:#111; color:#0f0; padding:10px; border-radius:10px; height: 360px; overflow:auto; white-space: pre-wrap; }
    img { max-width: 100%; border-radius: 12px; margin-top: 12px; display:none; }
    a { word-break: break-all; }
    .muted { opacity:.8; font-size: 12px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    label { user-select:none; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#eee; margin-inline-start:6px; font-size:12px; }
  </style>
</head>
<body>

<h2>Firebase Storage (v12) — Full Deep Debug</h2>

<div class="muted">
  <div><b>URL:</b> <span id="url"></span></div>
  <div><b>Origin:</b> <span id="origin"></span></div>
  <div><b>protocol:</b> <span id="protocol"></span></div>
  <div><b>online:</b> <span id="online"></span></div>
</div>

<div class="row" style="margin-top:12px;">
  <input id="fileInput" type="file" accept="image/*" />
  <button id="uploadBtn" disabled>העלה</button>
  <button id="cancelBtn" disabled>בטל</button>
  <button id="checksBtn">בדיקת חיבור (READ)</button>
  <button id="writeProbeBtn">בדיקת כתיבה (WRITE)</button>
  <button id="clearBtn">נקה לוג</button>
</div>

<div class="row">
  <label><input type="checkbox" id="forceNonResumable"> לכפות העלאה לא-Resumable (uploadBytes)</label>
  <label><input type="checkbox" id="traceNet" checked> Network Trace (XHR)</label>
  <span class="pill" id="netTraceState">trace: on</span>
</div>

<progress id="progress" value="0" max="100"></progress>
<p id="status"></p>

<p id="linkWrap" style="display:none;">
  <b>קישור לתמונה:</b> <a id="fileUrl" href="#" target="_blank" rel="noopener">—</a>
</p>

<img id="preview" alt="preview" />

<h3>לוגים</h3>
<div class="log" id="log"></div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js";
  import {
    getStorage,
    ref,
    uploadBytesResumable,
    uploadBytes,
    getDownloadURL,
    listAll
  } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-storage.js";

  // ===== UI =====
  const urlEl = document.getElementById("url");
  const originEl = document.getElementById("origin");
  const protocolEl = document.getElementById("protocol");
  const onlineEl = document.getElementById("online");
  const logEl = document.getElementById("log");
  const statusEl = document.getElementById("status");
  const fileInput = document.getElementById("fileInput");
  const uploadBtn = document.getElementById("uploadBtn");
  const cancelBtn = document.getElementById("cancelBtn");
  const checksBtn = document.getElementById("checksBtn");
  const writeProbeBtn = document.getElementById("writeProbeBtn");
  const clearBtn = document.getElementById("clearBtn");
  const progressEl = document.getElementById("progress");
  const linkWrap = document.getElementById("linkWrap");
  const fileUrlEl = document.getElementById("fileUrl");
  const previewEl = document.getElementById("preview");
  const forceNonResumableEl = document.getElementById("forceNonResumable");
  const traceNetEl = document.getElementById("traceNet");
  const netTraceStateEl = document.getElementById("netTraceState");

  urlEl.textContent = location.href;
  originEl.textContent = location.origin;
  protocolEl.textContent = location.protocol;

  function setOnlineText() { onlineEl.textContent = navigator.onLine ? "true" : "false"; }
  setOnlineText();
  addEventListener("online",  () => { setOnlineText(); log("EVENT: online=true"); });
  addEventListener("offline", () => { setOnlineText(); log("EVENT: online=false"); });

  function log(...args) {
    const line = args.map(a => typeof a === "object" ? JSON.stringify(a, null, 2) : String(a)).join(" ");
    console.log(...args);
    logEl.textContent += line + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function logError(label, e) {
    log(label, {
      name: e?.name,
      code: e?.code,
      message: e?.message,
      customData: e?.customData || null,
      stack: e?.stack ? String(e.stack).slice(0, 700) : null
    });
  }

  // ===== XHR Trace (catch status=0 / blocked) =====
  let xhrTraced = false;
  function enableXHRTraceOnce() {
    if (xhrTraced) return;
    xhrTraced = true;

    const OrigXHR = window.XMLHttpRequest;
    window.XMLHttpRequest = function() {
      const xhr = new OrigXHR();

      let _method = "";
      let _url = "";
      let _start = 0;

      const origOpen = xhr.open;
      xhr.open = function(method, url, ...rest) {
        _method = method;
        _url = String(url);
        _start = Date.now();

        if (traceNetEl.checked && (_url.includes("firebasestorage") || _url.includes("googleapis.com"))) {
          log(`[NET] open ${method} ${_url}`);
        }
        return origOpen.call(this, method, url, ...rest);
      };

      const origSend = xhr.send;
      xhr.send = function(body) {
        // Force a timeout so we actually get an event instead of infinite pending
        try { xhr.timeout = 45000; } catch {}

        if (traceNetEl.checked && (_url.includes("firebasestorage") || _url.includes("googleapis.com"))) {
          const bodySize = (body && (body.size || body.byteLength)) ? (body.size || body.byteLength) : null;
          log(`[NET] send ${_method} ${_url}` + (bodySize ? ` (bodySize=${bodySize})` : ""));
        }

        const dumpResponseBits = (tag) => {
          if (!traceNetEl.checked) return;
          if (!(_url.includes("firebasestorage") || _url.includes("googleapis.com"))) return;
          try {
            const rt = xhr.responseText;
            if (rt) log(`[NET] ${tag} responseText:`, rt.slice(0, 500));
            else log(`[NET] ${tag} responseText: (empty)`);
          } catch (e) {
            log(`[NET] ${tag} responseText: (unavailable)`);
          }
          try {
            const h = xhr.getAllResponseHeaders();
            if (h) log(`[NET] ${tag} headers:`, h);
            else log(`[NET] ${tag} headers: (none)`);
          } catch (e) {
            log(`[NET] ${tag} headers: (unavailable)`);
          }
        };

        xhr.addEventListener("load", () => {
          if (!traceNetEl.checked) return;
          if (!(_url.includes("firebasestorage") || _url.includes("googleapis.com"))) return;
          const ms = Date.now() - _start;
          log(`[NET] load status=${xhr.status} (${ms}ms) url=${_url}`);
          dumpResponseBits("load");
        });

        xhr.addEventListener("error", () => {
          if (!traceNetEl.checked) return;
          if (!(_url.includes("firebasestorage") || _url.includes("googleapis.com"))) return;
          const ms = Date.now() - _start;
          log(`[NET] error status=${xhr.status} (${ms}ms) url=${_url}`);
          log(`[NET] hint: status=0 => הדפדפן לא קיבל תשובת HTTP (חסימת תוסף/Proxy/VPN/AV או CORS/Blocked).`);
          dumpResponseBits("error");
        });

        xhr.addEventListener("timeout", () => {
          if (!traceNetEl.checked) return;
          if (!(_url.includes("firebasestorage") || _url.includes("googleapis.com"))) return;
          const ms = Date.now() - _start;
          log(`[NET] timeout (${ms}ms) url=${_url}`);
          dumpResponseBits("timeout");
        });

        xhr.addEventListener("abort", () => {
          if (!traceNetEl.checked) return;
          if (!(_url.includes("firebasestorage") || _url.includes("googleapis.com"))) return;
          const ms = Date.now() - _start;
          log(`[NET] abort (${ms}ms) url=${_url}`);
          dumpResponseBits("abort");
        });

        return origSend.call(this, body);
      };

      return xhr;
    };
  }

  traceNetEl.addEventListener("change", () => {
    netTraceStateEl.textContent = "trace: " + (traceNetEl.checked ? "on" : "off");
    log("TRACE TOGGLED:", traceNetEl.checked);
  });

  // ===== Firebase config =====
  const firebaseConfig = {
    apiKey: "AIzaSyBf-12UCoHpIMg81MWaer7DmtfVla95X9M",
    authDomain: "try-a-69b75.firebaseapp.com",
    projectId: "try-a-69b75",
    storageBucket: "try-a-69b75.firebasestorage.app",
    messagingSenderId: "136796358688",
    appId: "1:136796358688:web:f6d41df5505e26ec0b5445",
    measurementId: "G-ST0TTENTGF"
  };

  // ===== Init =====
  log("START");
  log("protocol:", location.protocol);
  if (location.protocol === "file:") {
    log("WARNING: file:// + type=module עלול להיכשל. מומלץ https/http.");
  }

  enableXHRTraceOnce();

  const app = initializeApp(firebaseConfig);
  log("initializeApp OK");

  try { getAnalytics(app); log("getAnalytics OK (optional)"); }
  catch (e) { log("getAnalytics FAILED (not critical)"); logError("analytics error:", e); }

  const storage = getStorage(app);
  log("getStorage OK, bucket:", storage?.app?.options?.storageBucket);
  log("READY");

  // ===== State =====
  let file = null;
  let activeTask = null;

  // Stall monitor (for "0% forever")
  let stallTimer = null;
  let lastProgressTs = Date.now();

  function stopStallMonitor() {
    if (stallTimer) clearInterval(stallTimer);
    stallTimer = null;
  }

  function startStallMonitor(onStall) {
    stopStallMonitor();
    lastProgressTs = Date.now();
    stallTimer = setInterval(() => {
      const diff = Date.now() - lastProgressTs;
      if (diff > 20000) {
        stopStallMonitor();
        onStall?.(diff);
      }
    }, 1000);
  }

  function resetUI() {
    linkWrap.style.display = "none";
    previewEl.style.display = "none";
    progressEl.style.display = "none";
    progressEl.value = 0;
    statusEl.textContent = "";
  }

  function setBusy(isBusy) {
    uploadBtn.disabled = isBusy || !file;
    cancelBtn.disabled = !isBusy;
    fileInput.disabled = isBusy;
    checksBtn.disabled = isBusy;
    writeProbeBtn.disabled = isBusy;
  }

  // ===== READ checks =====
  async function runConnectivityChecks() {
    log("=== CONNECTIVITY CHECKS START ===");

    try {
      const probePath = `__probe__/nope_${Date.now()}.txt`;
      log("CHECK A: getDownloadURL probe path:", probePath);
      await getDownloadURL(ref(storage, probePath));
      log("CHECK A: getDownloadURL OK (unexpected but confirms connectivity)");
    } catch (e) {
      log("CHECK A: getDownloadURL failed (often expected).");
      logError("CHECK A error:", e);
      if (e?.code === "storage/object-not-found") log("CHECK A RESULT: CONNECTED (server answered: object-not-found)");
    }

    try {
      const folder = "__probe__";
      log("CHECK B: listAll folder:", folder);
      const res = await listAll(ref(storage, folder));
      log("CHECK B: listAll OK (server responded)");
      log("CHECK B items:", res.items.map(i => i.fullPath));
      log("CHECK B prefixes:", res.prefixes.map(p => p.fullPath));
    } catch (e) {
      log("CHECK B: listAll failed.");
      logError("CHECK B error:", e);
    }

    log("=== CONNECTIVITY CHECKS END ===");
  }

  // ===== WRITE probe (non-resumable) =====
  async function runWriteProbe() {
    log("=== WRITE PROBE START ===");
    setBusy(true);
    resetUI();

    progressEl.style.display = "block";
    statusEl.textContent = "בודק כתיבה...";

    const blob = new Blob([`write_probe_${Date.now()}`], { type: "text/plain" });
    const path = `__probe__/write_${Date.now()}.txt`;

    try {
      await uploadBytes(ref(storage, path), blob, { contentType: "text/plain" });
      log("WRITE PROBE RESULT: SUCCESS");
      statusEl.textContent = "בדיקת כתיבה הצליחה";
    } catch (e) {
      log("WRITE PROBE RESULT: FAILED");
      logError("WRITE PROBE error:", e);
      statusEl.textContent = "בדיקת כתיבה נכשלה: " + (e?.message || e);
    } finally {
      setBusy(false);
      progressEl.style.display = "none";
      log("=== WRITE PROBE END ===");
    }
  }

  // ===== Upload strategies =====
  function uploadNonResumable(realFile, path) {
    return new Promise(async (resolve, reject) => {
      try {
        log("Non-resumable uploadBytes() to:", path);
        statusEl.textContent = "מעלה (לא-Resumable)...";
        progressEl.style.display = "block";
        progressEl.value = 0;

        const res = await uploadBytes(ref(storage, path), realFile, {
          contentType: realFile.type || "application/octet-stream"
        });

        const url = await getDownloadURL(res.ref);
        resolve(url);
      } catch (e) {
        reject(e);
      }
    });
  }

  function uploadResumableWithStall(realFile, path) {
    return new Promise((resolve, reject) => {
      log("Resumable uploadBytesResumable() to:", path);
      const storageRef = ref(storage, path);

      activeTask = uploadBytesResumable(storageRef, realFile, {
        contentType: realFile.type || "application/octet-stream"
      });

      progressEl.style.display = "block";
      progressEl.value = 0;
      statusEl.textContent = "מעלה (Resumable)...";

      startStallMonitor((diff) => {
        log(`STALL: ${Math.round(diff/1000)}s without progress. Canceling task...`);
        try { activeTask?.cancel(); } catch {}
        reject({ code: "stall-timeout", message: "Upload stalled (no progress)" });
      });

      activeTask.on("state_changed",
        (snap) => {
          lastProgressTs = Date.now();
          const p = snap.totalBytes ? (snap.bytesTransferred / snap.totalBytes) * 100 : 0;
          progressEl.value = p;
          statusEl.textContent = `מעלה... ${p.toFixed(0)}%`;
          log("progress:", p.toFixed(1) + "%", "state:", snap.state);
        },
        (e) => {
          stopStallMonitor();
          reject(e);
        },
        async () => {
          stopStallMonitor();
          try {
            const url = await getDownloadURL(activeTask.snapshot.ref);
            resolve(url);
          } catch (e) {
            reject(e);
          }
        }
      );
    });
  }

  async function uploadWithFallback(realFile) {
    setBusy(true);
    resetUI();

    const safeName = realFile.name.replace(/[^\w.\-]+/g, "_");
    const path = `uploads/${Date.now()}_${safeName}`;

    try {
      let url;

      if (forceNonResumableEl.checked) {
        url = await uploadNonResumable(realFile, path);
      } else {
        try {
          url = await uploadResumableWithStall(realFile, path);
        } catch (e) {
          logError("Resumable failed:", e);
          log("FALLBACK: trying uploadBytes() (non-resumable)...");
          url = await uploadNonResumable(realFile, path);
        }
      }

      log("SUCCESS Download URL:", url);
      fileUrlEl.href = url;
      fileUrlEl.textContent = url;
      linkWrap.style.display = "block";
      previewEl.src = url;
      previewEl.style.display = "block";
      statusEl.textContent = "העלאה הושלמה";
    } catch (e) {
      logError("UPLOAD FINAL FAILED:", e);
      statusEl.textContent = "שגיאה: " + (e?.message || e?.code || "unknown");
    } finally {
      stopStallMonitor();
      activeTask = null;
      setBusy(false);
    }
  }

  // ===== Events =====
  checksBtn.addEventListener("click", runConnectivityChecks);
  writeProbeBtn.addEventListener("click", runWriteProbe);

  clearBtn.addEventListener("click", () => {
    logEl.textContent = "";
    log("LOG CLEARED");
  });

  fileInput.addEventListener("change", () => {
    file = fileInput.files?.[0] || null;
    resetUI();
    uploadBtn.disabled = !file;
    if (file) log("Selected file:", { name: file.name, size: file.size, type: file.type });
    else log("No file selected");
  });

  cancelBtn.addEventListener("click", () => {
    if (!activeTask) return;
    log("Cancel requested");
    try { activeTask.cancel(); } catch {}
    stopStallMonitor();
    activeTask = null;
    setBusy(false);
    statusEl.textContent = "בוטל";
  });

  uploadBtn.addEventListener("click", async () => {
    if (!file) return;
    await uploadWithFallback(file);
  });
</script>

</body>
</html>