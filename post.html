<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>×¦×¤×™×™×” ×‘×¤×•×¡×˜</title>

  <!-- =====================================================================================
       ğŸš« ×—×¡×™××” ××™×™×“×™×ª ×œ×“×¤×“×¤×Ÿ ×¨×’×™×œ (××‘×˜×—×”: ×œ× ××©× ×™× ×©×™×˜×”)
       1) ×—×™×™×‘ WebView (AppInventor)
       2) ×—×™×™×‘ getWebViewString ×¤×•× ×§×¦×™×”
       ×× ×œ× => forbidden.html
       ===================================================================================== -->
  <script>
    (function () {
      try {
        if (!window.AppInventor || typeof window.AppInventor.getWebViewString !== "function") {
          location.replace("forbidden.html");
        }
      } catch (e) {
        location.replace("forbidden.html");
      }
    })();
  </script>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <script src="firebaseConfig.js"></script>

  <!-- CSS -->
  <link rel="stylesheet" href="css/forum.css" />
  <link rel="stylesheet" href="css/post.css" />

  <style>
    /* =====================================================================================
       SELECTIVE ADDITIONS (UI ×‘×œ×‘×“) â€“ ×œ× ××—×œ×™×£ CSS ×§×™×™×
       ===================================================================================== */

    .post-user-border {
      border-right: 4px solid rgba(0,0,0,0.15);
      padding-right: 12px;
      box-sizing: border-box;
    }

    .post-image-wrap {
      margin-top: 12px;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(0,0,0,0.03);
    }

    .post-image {
      width: 100%;
      height: auto;
      display: block;
      max-height: 380px;
      object-fit: cover;
      background: #fff;
      cursor: pointer;
    }

    .mini-image {
      width: 100%;
      height: auto;
      display: block;
      max-height: 180px;
      object-fit: cover;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.12);
      background: #fff;
      cursor: pointer;
      margin-top: 10px;
    }

    .img-actions-row {
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      margin-top: 10px;
    }

    .img-btn {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.18);
      background: #fff;
      cursor: pointer;
      font-weight: bold;
    }

    .img-btn-primary {
      border: none;
      background: rgb(17,17,87);
      color: #fff;
    }

    .img-btn-danger {
      border: 1px solid rgba(255,0,0,0.35);
      background: rgba(255,0,0,0.06);
      color: #8a0000;
    }

    .img-preview {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.12);
      overflow: hidden;
      background: rgba(0,0,0,0.03);
      margin-top: 10px;
    }

    .img-preview img {
      width: 100%;
      height: auto;
      display: block;
      max-height: 220px;
      object-fit: cover;
      background: #fff;
    }

    /* Viewer overlay (×—×œ×•×Ÿ ×§×˜×Ÿ ×¢× ××™×§×¡) */
    #miniViewerOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.72);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      box-sizing: border-box;
      z-index: 10000;
    }
    #miniViewerBox {
      width: min(820px, 100%);
      background: rgba(255,255,255,0.97);
      border-radius: 16px;
      padding: 12px;
      box-sizing: border-box;
      border: 1px solid rgba(0,0,0,0.12);
    }
    #miniViewerTop {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    #miniViewerClose {
      border: none;
      background: transparent;
      font-size: 18px;
      cursor: pointer;
      padding: 8px 10px;
      border-radius: 10px;
    }
    #miniViewerImg {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 14px;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.12);
      max-height: 78vh;
      object-fit: contain;
    }

    /* Edit post overlay */
    #editPostOverlay {
      position:fixed;
      inset:0;
      background: rgba(0,0,0,0.45);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      box-sizing:border-box;
      z-index:9999;
    }
    #editPostModal {
      width:min(740px, 100%);
      background:#fff;
      border-radius:16px;
      padding:16px;
      box-sizing:border-box;
    }

    /* Inline edit (comment/reply) */
    .inline-edit-box {
      margin-top: 8px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(0,0,0,0.02);
    }
    .inline-edit-box textarea {
      width:100%;
      box-sizing:border-box;
      padding:10px 12px;
      border-radius:10px;
      border:1px solid rgba(0,0,0,0.15);
      outline:none;
      resize:vertical;
    }
  </style>
</head>

<body>

<header class="top-bar">
  <h1>×¦×¤×™×™×” ×‘×¤×•×¡×˜</h1>
</header>

<main class="forum-container">

  <!-- =====================================================================================
       POST HEADER AREA
       ===================================================================================== -->
  <div id="post"></div>

  <!-- =====================================================================================
       STATUS BAR (UX ×©×“×¨×•×’ - ×œ× ×¤×•×’×¢ ×‘××‘×˜×—×”)
       ===================================================================================== -->
  <div id="statusBar" style="
    display:none;
    margin: 10px 0 14px 0;
    padding:10px 12px;
    border-radius:12px;
    background: rgba(0,0,0,0.05);
    color:#111;
    font-size:13px;
  "></div>

  <!-- =====================================================================================
       MAIN COMMENT COMPOSER
       ===================================================================================== -->
  <div id="mainComposer" class="composer hidden">
    <textarea id="mainText" placeholder="×›×ª×•×‘ ×ª×’×•×‘×”..."></textarea>

    <!-- =====================================================================================
         COMMENT IMAGE (NEW) â€“ ×ª××•× ×” ×œ×ª×’×•×‘×” (××•×¤×¦×™×•× ×œ×™)
         ===================================================================================== -->
    <div id="mainCommentImageBlock" style="
      margin-top:10px;
      border:1px solid rgba(0,0,0,0.10);
      border-radius:14px;
      padding:12px;
      background: rgba(0,0,0,0.02);
    ">
      <div class="img-actions-row">
        <div style="display:flex; flex-direction:column; gap:4px;">
          <div style="font-weight:bold;">×ª××•× ×” ×œ×ª×’×•×‘×” (××•×¤×¦×™×•× ×œ×™)</div>
          <div id="mainCommentImageMeta" style="font-size:12px; opacity:.75;">
            ×¤×•×¨××˜×™× × ×ª××›×™×: JPG/PNG/WebP. ××•××œ×¥ ×¢×“ 9MB.
          </div>
        </div>

        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button id="chooseMainCommentImageBtn" type="button" class="img-btn img-btn-primary">×‘×—×¨ ×ª××•× ×”</button>
          <button id="removeMainCommentImageBtn" type="button" class="img-btn img-btn-danger" style="display:none;">×”×¡×¨ ×ª××•× ×”</button>
        </div>
      </div>

      <input id="mainCommentImage" type="file" accept="image/*" style="display:none;" />

      <div id="mainCommentPreviewWrap" style="display:none;">
        <div class="img-preview">
          <img id="mainCommentPreviewImg" alt="×ª×¦×•×’×” ××§×“×™××”" src="" />
        </div>
      </div>
    </div>

    <div class="composer-actions">
      <button type="button" id="sendMainBtn">×©×œ×—</button>
      <button type="button" id="closeMainBtn">×‘×™×˜×•×œ</button>
    </div>

    <!-- extra UX (×©×“×¨×•×’) -->
    <div id="mainComposerHint" style="
      margin-top:8px;
      font-size:12px;
      opacity:0.75;
      line-height:1.5;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    ">
      <span>×˜×™×¤: ×ª×’×•×‘×” ×˜×•×‘×” ×”×™× ×§×¦×¨×”, ×‘×¨×•×¨×”, ×•××›×‘×“×ª.</span>
      <span id="mainCharCount">0/800</span>
    </div>
  </div>

  <!-- =====================================================================================
       OPEN MAIN COMPOSER BUTTON
       ===================================================================================== -->
  <button id="openMain" class="add-comment-btn" type="button">
    ×”×•×¡×£ ×ª×’×•×‘×”
  </button>

  <!-- =====================================================================================
       COMMENTS
       ===================================================================================== -->
  <section class="comments">
    <h3>×ª×’×•×‘×•×ª</h3>

    <!-- search inside comments (×©×“×¨×•×’, ×œ× ××‘×˜×œ ×›×œ×•×) -->
    <div style="
      display:flex;
      gap:10px;
      align-items:center;
      margin: 10px 0 12px 0;
      flex-wrap:wrap;
    ">
      <input id="commentSearch" type="search" placeholder="×—×™×¤×•×© ×‘×ª×’×•×‘×•×ª..."
        style="
          flex:1;
          min-width:180px;
          padding:10px 12px;
          border-radius:10px;
          border:1px solid rgba(0,0,0,0.15);
          outline:none;
          box-sizing:border-box;
        "
      />
      <select id="commentSort" style="
        padding:10px 12px;
        border-radius:10px;
        border:1px solid rgba(0,0,0,0.15);
        outline:none;
        background:#fff;
        cursor:pointer;
      ">
        <option value="newest">××™×•×Ÿ: ×”×—×“×©×•×ª ×œ××¢×œ×”</option>
        <option value="oldest">××™×•×Ÿ: ×”×™×©× ×•×ª ×œ××¢×œ×”</option>
        <option value="author">××™×•×Ÿ: ×œ×¤×™ ××—×‘×¨</option>
      </select>
    </div>

    <div id="comments">
      <div class="loader"></div>
    </div>

    <!-- load more (×©×“×¨×•×’ - ××•×¤×¦×™×•× ×œ×™) -->
    <div id="commentsFooter" style="
      margin-top:14px;
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
    ">
      <button id="loadMoreComments" type="button" style="
        display:none;
        padding:10px 14px;
        border-radius:12px;
        border:1px solid rgba(0,0,0,0.15);
        background:#fff;
        cursor:pointer;
        font-weight:bold;
      ">×˜×¢×Ÿ ×¢×•×“ ×ª×’×•×‘×•×ª</button>
    </div>
  </section>

</main>

<!-- =====================================================================================
     MINI VIEWER OVERLAY (×ª×¦×•×’×” ××§×“×™××” ×¢× ××™×§×¡) â€“ ×œ×¤×•×¡×˜/×ª×’×•×‘×•×ª/×¨×™×¤×œ×™×™×–
     ===================================================================================== -->
<div id="miniViewerOverlay">
  <div id="miniViewerBox">
    <div id="miniViewerTop">
      <div style="font-weight:bold;">×ª××•× ×”</div>
      <button id="miniViewerClose" type="button">âœ•</button>
    </div>
    <img id="miniViewerImg" alt="×ª××•× ×”" src="" />
    <div style="margin-top:10px; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center;">
      <span style="font-size:12px; opacity:.75;">×œ×—×¥ ××—×•×¥ ×œ×ª×™×‘×” ×›×“×™ ×œ×¡×’×•×¨</span>
      <span id="miniViewerHint" style="font-size:12px; opacity:.75;"></span>
    </div>
  </div>
</div>

<!-- =====================================================================================
     EDIT POST OVERLAY (×¢×“ 24 ×©×¢×•×ª, ×¨×§ ×”××—×‘×¨)
     ===================================================================================== -->
<div id="editPostOverlay">
  <div id="editPostModal">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
      <div style="font-weight:bold; font-size:18px;">×¢×¨×™×›×ª ×¤×•×¡×˜</div>
      <button id="closeEditPostBtn" type="button" style="border:none;background:transparent;font-size:18px;cursor:pointer;">âœ•</button>
    </div>

    <div style="margin-top:12px; display:flex; flex-direction:column; gap:10px;">
      <input id="editPostTitle" type="text" placeholder="×›×•×ª×¨×ª"
        maxlength="80"
        style="
          padding:12px;
          border-radius:12px;
          border:1px solid rgba(0,0,0,0.18);
          outline:none;
          box-sizing:border-box;
        "
      />
      <textarea id="editPostText" placeholder="×ª×•×›×Ÿ ×”×¤×•×¡×˜..."
        rows="7"
        maxlength="2000"
        style="
          padding:12px;
          border-radius:12px;
          border:1px solid rgba(0,0,0,0.18);
          outline:none;
          box-sizing:border-box;
          resize:vertical;
        "
      ></textarea>

      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
        <div id="editPostHint" style="font-size:12px; color:#444;">
          × ×™×ª×Ÿ ×œ×¢×¨×•×š ×¤×•×¡×˜ ×¢×“ 24 ×©×¢×•×ª ××¨×’×¢ ×”×¤×¨×¡×•×.
        </div>
        <div style="display:flex; gap:10px;">
          <button id="saveEditPostBtn" type="button" style="
            padding:10px 14px;
            border-radius:12px;
            border:none;
            background: rgb(17,17,87);
            color:#fff;
            cursor:pointer;
            font-weight:bold;
          ">×©××•×¨</button>
          <button id="cancelEditPostBtn" type="button" style="
            padding:10px 14px;
            border-radius:12px;
            border:1px solid rgba(0,0,0,0.18);
            background:#fff;
            cursor:pointer;
            font-weight:bold;
          ">×‘×™×˜×•×œ</button>
        </div>
      </div>

      <div id="editPostError" style="
        display:none;
        padding:10px 12px;
        border-radius:12px;
        background: rgba(255,0,0,0.08);
        color:#8a0000;
        font-size:13px;
      "></div>
    </div>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
<script>
/* =========================================================================================
   âš ï¸ ××‘×˜×—×” â€“ ×©×™×˜×” ×œ× ××©×ª× ×”:
   1) ×—×¡×™××” ××™×™×“×™×ª ×‘×“×¤×“×¤×Ÿ ×¨×’×™×œ (AppInventor + getWebViewString)
   2) payload ××§×•×“×•×œ×¨ (email/password/token)
   3) Firebase Auth signInWithEmailAndPassword
   4) ××™××•×ª token ××•×œ sessions/{uid}/token
   ×¨×§ ××—×¨×™ ×–×”: ×©×œ×™×¤×•×ª DB + ×›×ª×™×‘×•×ª ×ª×’×•×‘×”/×ª×’×•×‘×”-×¢×œ-×ª×’×•×‘×” + ×¢×¨×™×›×•×ª
   ========================================================================================= */

/* ===============================
   Helpers
   =============================== */
function escapeHTML(str = "") {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function safeText(str = "") {
  return String(str || "");
}

function userColor(key) {
  const colors = [
    "#60a5fa",
    "#34d399",
    "#f472b6",
    "#fbbf24",
    "#a78bfa",
    "#fb7185",
    "#22d3ee"
  ];
  let hash = 0;
  const s = String(key || "");
  for (let i = 0; i < s.length; i++) {
    hash = s.charCodeAt(i) + ((hash << 5) - hash);
  }
  return colors[Math.abs(hash) % colors.length];
}

function fmtTime(ts) {
  try {
    return new Date(ts).toLocaleTimeString("he-IL", {
      hour: "2-digit",
      minute: "2-digit"
    });
  } catch {
    return "";
  }
}

function fmtDateTime(ts) {
  try {
    return new Date(ts).toLocaleString("he-IL", {
      day: "2-digit",
      month: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    });
  } catch {
    return "";
  }
}

function setStatus(msg, type = "info") {
  const bar = document.getElementById("statusBar");
  if (!bar) return;

  if (!msg) {
    bar.style.display = "none";
    bar.textContent = "";
    return;
  }

  bar.style.display = "block";
  bar.textContent = msg;

  if (type === "error") {
    bar.style.background = "rgba(255,0,0,0.08)";
    bar.style.color = "#8a0000";
  } else if (type === "ok") {
    bar.style.background = "rgba(0,128,0,0.08)";
    bar.style.color = "#0b5a0b";
  } else if (type === "warn") {
    bar.style.background = "rgba(255,165,0,0.10)";
    bar.style.color = "#7a4b00";
  } else {
    bar.style.background = "rgba(0,0,0,0.05)";
    bar.style.color = "#111";
  }
}

function debounce(fn, ms) {
  let t = null;
  return function (...args) {
    clearTimeout(t);
    t = setTimeout(() => fn.apply(this, args), ms);
  };
}

function clampTextLen(s, maxLen) {
  const x = safeText(s);
  if (x.length <= maxLen) return x;
  return x.slice(0, maxLen);
}

function nowTs() {
  return Date.now();
}

function sanitizeImageUrl(url) {
  if (url === undefined || url === null) return "";
  const u = safeText(url).trim();
  if (!u) return "";
  if (u.startsWith("https://") || u.startsWith("http://")) return u;
  return "";
}

function bytesToHuman(n) {
  try {
    const x = Number(n || 0);
    if (!x) return "0B";
    if (x < 1024) return x + "B";
    if (x < 1024 * 1024) return Math.round(x / 1024) + "KB";
    return (Math.round((x / (1024 * 1024)) * 10) / 10) + "MB";
  } catch (e) {
    return "";
  }
}

function isLikelyImageFile(file) {
  try {
    if (!file) return false;
    const t = safeText(file.type || "").toLowerCase();
    if (t.startsWith("image/")) return true;
    const n = safeText(file.name || "").toLowerCase();
    if (n.includes(".jpg") || n.includes(".jpeg") || n.includes(".png") || n.includes(".webp")) return true;
    return false;
  } catch (e) {
    return false;
  }
}

function copyToClipboard(text) {
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text);
      return;
    }
  } catch {}
  const ta = document.createElement("textarea");
  ta.value = safeText(text);
  ta.style.position = "fixed";
  ta.style.opacity = "0";
  document.body.appendChild(ta);
  ta.select();
  try { document.execCommand("copy"); } catch {}
  document.body.removeChild(ta);
}

/* =========================================================================================
   MINI VIEWER (×ª×¦×•×’×” ××§×“×™××” ×¢× ××™×§×¡) â€“ ×œ×¤×•×¡×˜/×ª×’×•×‘×•×ª/×¨×™×¤×œ×™×™×–
   ========================================================================================= */
function openMiniViewer(url, hint) {
  const overlay = document.getElementById("miniViewerOverlay");
  const img = document.getElementById("miniViewerImg");
  const closeBtn = document.getElementById("miniViewerClose");
  const hintEl = document.getElementById("miniViewerHint");

  if (!overlay || !img) return;

  const safe = sanitizeImageUrl(url);
  if (!safe) return;

  img.setAttribute("src", safe);
  if (hintEl) hintEl.textContent = safeText(hint || "");
  overlay.style.display = "flex";

  if (closeBtn && !closeBtn.__bound) {
    closeBtn.__bound = true;
    closeBtn.addEventListener("click", function () {
      overlay.style.display = "none";
      img.setAttribute("src", "");
      if (hintEl) hintEl.textContent = "";
    });
  }

  if (!overlay.__bound) {
    overlay.__bound = true;
    overlay.addEventListener("click", function (e) {
      if (e.target === overlay) {
        overlay.style.display = "none";
        img.setAttribute("src", "");
        if (hintEl) hintEl.textContent = "";
      }
    });
  }
}

/* =========================================================================================
   Robust FileReader fallback (×œ× ×—×•×‘×”, ××‘×œ ×’×™×‘×•×™ ×× ObjectURL ×œ× ×–××™×Ÿ)
   - ×–×” ×›××Ÿ ×›×“×™ ×œ×”×§×˜×™×Ÿ "×œ× ×”×¦×œ×—×ª×™ ×œ×§×¨×•× ××ª ×”×ª××•× ×”" ×‘×¤×•×¢×œ.
   ========================================================================================= */
function readFileAsDataURLWithRetry(file, tries, done) {
  try {
    let left = Number(tries || 1);
    if (left < 1) left = 1;

    const attempt = function () {
      try {
        const r = new FileReader();
        r.onerror = function () {
          left--;
          if (left <= 0) { done("", false); return; }
          setTimeout(attempt, 160);
        };
        r.onload = function () {
          const dataUrl = safeText(r.result || "");
          if (!dataUrl || !dataUrl.startsWith("data:")) {
            left--;
            if (left <= 0) { done("", false); return; }
            setTimeout(attempt, 160);
            return;
          }
          done(dataUrl, true);
        };
        r.readAsDataURL(file);
      } catch (e1) {
        left--;
        if (left <= 0) { done("", false); return; }
        setTimeout(attempt, 160);
      }
    };

    attempt();
  } catch (e0) {
    done("", false);
  }
}

/* =========================================================================================
   ×”×¦×’×ª ×¤×•×¡×˜ ××”Ö¾sessionStorage (×× ×§×™×™×) â€“ ×˜×¢×™× ×” ××™×™×“×™×ª (×¤×™×¦'×¨ × ×©××¨)
   + ×©×“×¨×•×’: ××¦×™×’ ×’× ×ª××•× ×” ×× ×§×™×™××ª ×‘×§××©
   ========================================================================================= */
(function showCachedPostIfExists() {
  const cachedPost = sessionStorage.getItem("currentPost");
  if (!cachedPost) return;

  try {
    const p = JSON.parse(cachedPost);
    const host = document.getElementById("post");
    if (!host) return;

    const author = safeText(p.author || "");
    const border = userColor(author);
    const imgUrl = sanitizeImageUrl(p.image || "");

    host.innerHTML = `
      <div class="post post-user-border" style="border-right-color:${escapeHTML(border)};">
        <h3>${escapeHTML(p.title || "")}</h3>
        <p>${escapeHTML(p.text || "")}</p>
        <small style="display:block; margin-top:6px;">×××ª: ${escapeHTML(author)}</small>
        ${imgUrl ? `
          <div class="post-image-wrap">
            <img class="post-image js-open-viewer" data-hint="×ª××•× ×ª ×”×¤×•×¡×˜" src="${escapeHTML(imgUrl)}" alt="×ª××•× ×”" />
          </div>
        ` : ``}
      </div>
    `;
  } catch (e) {
    sessionStorage.removeItem("currentPost");
  }
})();

/* =========================================================================================
   Main
   ========================================================================================= */
document.addEventListener("DOMContentLoaded", function () {

  /* ===============================
     DOM Elements
     =============================== */
  const postContainer = document.getElementById("post");
  const commentsBox = document.getElementById("comments");

  const openMainBtn = document.getElementById("openMain");
  const mainComposer = document.getElementById("mainComposer");
  const mainText = document.getElementById("mainText");
  const sendMainBtn = document.getElementById("sendMainBtn");
  const closeMainBtn = document.getElementById("closeMainBtn");
  const mainCharCount = document.getElementById("mainCharCount");

  const commentSearch = document.getElementById("commentSearch");
  const commentSort = document.getElementById("commentSort");
  const loadMoreCommentsBtn = document.getElementById("loadMoreComments");

  /* ===============================
     Comment image UI (NEW)
     =============================== */
  const mainCommentImageInput = document.getElementById("mainCommentImage");
  const chooseMainCommentImageBtn = document.getElementById("chooseMainCommentImageBtn");
  const removeMainCommentImageBtn = document.getElementById("removeMainCommentImageBtn");
  const mainCommentPreviewWrap = document.getElementById("mainCommentPreviewWrap");
  const mainCommentPreviewImg = document.getElementById("mainCommentPreviewImg");
  const mainCommentImageMeta = document.getElementById("mainCommentImageMeta");

  /* ===============================
     Edit post UI (NEW)
     =============================== */
  const editPostOverlay = document.getElementById("editPostOverlay");
  const closeEditPostBtn = document.getElementById("closeEditPostBtn");
  const cancelEditPostBtn = document.getElementById("cancelEditPostBtn");
  const saveEditPostBtn = document.getElementById("saveEditPostBtn");
  const editPostTitle = document.getElementById("editPostTitle");
  const editPostText = document.getElementById("editPostText");
  const editPostError = document.getElementById("editPostError");

  /* ===============================
     Guard
     =============================== */
  if (!postContainer || !commentsBox) {
    location.replace("forbidden.html");
    return;
  }

  /* ===============================
     PostId ×—×•×‘×”
     =============================== */
  const postId = new URLSearchParams(location.search).get("postId");
  if (!postId) {
    location.replace("forbidden.html");
    return;
  }

  /* =====================================================================================
     Global State (×œ××¡×š ×¤×•×¡×˜)
     ===================================================================================== */
  let payload = null;
  let uid = null;
  let username = "××©×ª××©";
  let isAuthed = false;

  // current post snapshot (needed for edit rules)
  let currentPostObj = null; // {title,text,author,authorUid,time,image,lastCommentTime,...}
  let canEditPostNow = false;

  // ×× ×™×¢×ª ×“××‘×œ-×©×œ×™×—×•×ª (×ª×’×•×‘×•×ª / replies)
  let mainSending = false;
  const replySendingMap = Object.create(null);

  // Comments cache (×œ××™×•×Ÿ/×—×™×¤×•×© ×‘×œ×™ ×œ×©×‘×•×¨ ×©×•× ×“×‘×¨)
  let commentsCache = [];
  let commentsRenderedHtml = "";
  let commentsLimit = 200;          // ×©×•××¨ ×›××• ×©×”×™×”
  let commentsPagingStep = 200;     // ×©×“×¨×•×’: "×˜×¢×Ÿ ×¢×•×“"
  let canLoadMore = false;

  // Live listeners (×©×“×¨×•×’)
  let liveCommentsRef = null;
  let liveCommentsAttached = false;

  // Replies UI cache
  const repliesOpenState = Object.create(null);          // id => boolean
  const repliesLiveRefs = Object.create(null);           // id => firebase ref
  const repliesLiveAttached = Object.create(null);       // id => boolean

  // Payload wait hard limit (××•× ×¢ "×˜×¢×™× ×” ××™× ×¡×•×¤×™×ª" ×‘-WebView ×ª×§×•×œ)
  const PAYLOAD_MAX_MS = 12000; // 12s
  const PAYLOAD_POLL_MS = 200;
  const payloadStartAt = nowTs();

  /* =====================================================================================
     Image state (comment + reply)
     - Strategy: preview via ObjectURL (×›××¢×˜ ×‘×œ×™ ×©×’×™××•×ª)
       upload via storage.put(file) (×œ×œ× FileReader)
       fallback: putString(data_url) ×¨×§ ×× ×¦×¨×™×š
     ===================================================================================== */
  const MAX_IMG = 9 * 1024 * 1024; // 9MB

  let mainCommentImageFile = null;
  let mainCommentPreviewUrl = "";
  let mainCommentPreviewCanRevoke = false;

  function clearMainCommentImage(resetInput) {
    try {
      if (mainCommentPreviewUrl && mainCommentPreviewCanRevoke) {
        try { URL.revokeObjectURL(mainCommentPreviewUrl); } catch {}
      }
    } catch {}
    mainCommentImageFile = null;
    mainCommentPreviewUrl = "";
    mainCommentPreviewCanRevoke = false;

    try {
      if (mainCommentPreviewImg) mainCommentPreviewImg.setAttribute("src", "");
      if (mainCommentPreviewWrap) mainCommentPreviewWrap.style.display = "none";
      if (removeMainCommentImageBtn) removeMainCommentImageBtn.style.display = "none";
      if (resetInput && mainCommentImageInput) mainCommentImageInput.value = "";
      if (mainCommentImageMeta) mainCommentImageMeta.textContent = "×¤×•×¨××˜×™× × ×ª××›×™×: JPG/PNG/WebP. ××•××œ×¥ ×¢×“ 9MB.";
    } catch {}
  }

  if (chooseMainCommentImageBtn && mainCommentImageInput) {
    chooseMainCommentImageBtn.addEventListener("click", function () {
      try {
        mainCommentImageInput.value = "";
        mainCommentImageInput.click();
      } catch {}
    });
  }

  if (removeMainCommentImageBtn) {
    removeMainCommentImageBtn.addEventListener("click", function () {
      clearMainCommentImage(true);
    });
  }

  if (mainCommentImageInput) {
    mainCommentImageInput.addEventListener("change", function () {
      try {
        const f = (mainCommentImageInput.files && mainCommentImageInput.files[0]) ? mainCommentImageInput.files[0] : null;
        if (!f) return;

        if (!isLikelyImageFile(f)) {
          setStatus("×§×•×‘×¥ ×œ× × ×ª××š. ×‘×—×¨ ×ª××•× ×” (JPG/PNG/WebP).", "error");
          clearMainCommentImage(true);
          return;
        }

        if (Number(f.size || 0) > MAX_IMG) {
          setStatus("×”×ª××•× ×” ×’×“×•×œ×” ××“×™ (" + bytesToHuman(f.size) + "). ×¢×“ 9MB.", "error");
          clearMainCommentImage(true);
          return;
        }

        mainCommentImageFile = f;

        // preview with ObjectURL (preferred)
        try {
          if (mainCommentPreviewUrl && mainCommentPreviewCanRevoke) {
            try { URL.revokeObjectURL(mainCommentPreviewUrl); } catch {}
          }
        } catch {}

        mainCommentPreviewUrl = "";
        mainCommentPreviewCanRevoke = false;

        try {
          if (mainCommentImageMeta) mainCommentImageMeta.textContent = "× ×‘×—×¨×” ×ª××•× ×”: " + safeText(f.name) + " (" + bytesToHuman(f.size) + ")";
        } catch {}

        let previewSet = false;
        try {
          if (window.URL && typeof URL.createObjectURL === "function") {
            const u = URL.createObjectURL(f);
            mainCommentPreviewUrl = u;
            mainCommentPreviewCanRevoke = true;
            if (mainCommentPreviewImg) mainCommentPreviewImg.setAttribute("src", u);
            if (mainCommentPreviewWrap) mainCommentPreviewWrap.style.display = "block";
            if (removeMainCommentImageBtn) removeMainCommentImageBtn.style.display = "inline-block";
            previewSet = true;
          }
        } catch {}

        // fallback to FileReader quietly (no noisy errors)
        if (!previewSet) {
          readFileAsDataURLWithRetry(f, 3, function (durl, ok) {
            if (!ok) {
              // ×œ× ××¦×™×’×™× "×œ× ×”×¦×œ×—×ª×™ ×œ×§×¨×•×" ××’×¨×¡×™×‘×™ â€“ ×¨×§ ×¡×˜×˜×•×¡ ×¢×“×™×Ÿ
              setStatus("×œ× ×”×¦×œ×—×ª×™ ×œ×”×¦×™×’ ×ª×¦×•×’×” ××§×“×™××”, ××‘×œ ×× ×¡×” ×œ×”×¢×œ×•×ª ×›×¨×’×™×œ.", "warn");
              return;
            }
            mainCommentPreviewUrl = durl;
            mainCommentPreviewCanRevoke = false;
            if (mainCommentPreviewImg) mainCommentPreviewImg.setAttribute("src", durl);
            if (mainCommentPreviewWrap) mainCommentPreviewWrap.style.display = "block";
            if (removeMainCommentImageBtn) removeMainCommentImageBtn.style.display = "inline-block";
          });
        }
      } catch {}
    });
  }

  /* =====================================================================================
     Composer UX: ×¡×¤×™×¨×ª ×ª×•×•×™× (×©×“×¨×•×’)
     ===================================================================================== */
  const MAIN_MAX = 800;
  if (mainText && mainCharCount) {
    const updateCount = () => {
      const len = safeText(mainText.value).length;
      mainCharCount.textContent = `${len}/${MAIN_MAX}`;
    };
    mainText.addEventListener("input", updateCount);
    updateCount();
  }

  /* =====================================================================================
     Bind composer buttons (feature × ×©××¨)
     ===================================================================================== */
  openMainBtn.addEventListener("click", openMain);
  closeMainBtn.addEventListener("click", closeMain);
  sendMainBtn.addEventListener("click", sendMain);

  function openMain() {
    mainComposer.classList.remove("hidden");
    openMainBtn.style.display = "none";

    setTimeout(() => {
      try { mainText.focus(); } catch {}
      try {
        mainComposer.scrollIntoView({ behavior: "smooth", block: "center" });
      } catch {}
    }, 50);
  }

  function closeMain() {
    mainComposer.classList.add("hidden");
    openMainBtn.style.display = "block";
    mainText.value = "";
    if (mainCharCount) mainCharCount.textContent = `0/${MAIN_MAX}`;

    // reset image
    clearMainCommentImage(true);
  }

  /* =====================================================================================
     Search + Sort for comments (×©×“×¨×•×’ - ×œ× ××‘×˜×œ ×¤×™×¦'×¨)
     ===================================================================================== */
  if (commentSearch) {
    commentSearch.addEventListener("input", debounce(() => {
      renderCommentsFromCache();
    }, 120));
  }

  if (commentSort) {
    commentSort.addEventListener("change", () => {
      renderCommentsFromCache();
    });
  }

  if (loadMoreCommentsBtn) {
    loadMoreCommentsBtn.addEventListener("click", () => {
      commentsLimit += commentsPagingStep;
      setStatus("×˜×•×¢×Ÿ ×¢×•×“ ×ª×’×•×‘×•×ªâ€¦", "info");
      loadComments(false, true);
    });
  }

  /* =====================================================================================
     Auth Flow Start
     ===================================================================================== */
  waitForPayload();

  /* =====================================================================================
     1ï¸âƒ£ ×§×‘×œ×ª payload ××§×•×“×•×œ×¨
     - ×¢× Hard limit ×›×“×™ ×©×œ× ×™×”×™×• ×œ×•×¤×™× ××™× ×¡×•×¤×™×™×
     ===================================================================================== */
  function waitForPayload() {
    try {
      const elapsed = nowTs() - payloadStartAt;
      if (elapsed > PAYLOAD_MAX_MS) {
        location.replace("forbidden.html");
        return;
      }

      const raw = window.AppInventor.getWebViewString();
      if (!raw) return setTimeout(waitForPayload, PAYLOAD_POLL_MS);

      payload = JSON.parse(raw);
    } catch (e) {
      return setTimeout(waitForPayload, PAYLOAD_POLL_MS);
    }

    login();
  }

  /* =====================================================================================
     2ï¸âƒ£ ×”×ª×—×‘×¨×•×ª Firebase
     ===================================================================================== */
  function login() {
    if (!payload || !payload.email || !payload.password || !payload.token) {
      location.replace("forbidden.html");
      return;
    }

    setStatus("××××ª ×”×ª×—×‘×¨×•×ªâ€¦", "info");

    firebase.auth()
      .signInWithEmailAndPassword(payload.email, payload.password)
      .then((cred) => {
        uid = cred.user.uid;
        return validateToken(uid, payload.token);
      })
      .then(() => fetchUsername(uid))
      .then((name) => {
        username = name || "××©×ª××©";
        isAuthed = true;

        setStatus("××—×•×‘×¨ ×›Ö¾" + username, "ok");

        // ×ª××™×“ × ×˜×¢×Ÿ ×¤×•×¡×˜ ××”-DB ×›×“×™ ×œ×—×©×‘ ×”×¨×©××•×ª ×¢×¨×™×›×” + ×ª××•× ×” + ×’×‘×•×œ ×¦×‘×¢
        loadPost();

        // ×ª×’×•×‘×•×ª
        loadComments(true, false);

        // Live comments (×©×“×¨×•×’)
        attachLiveComments();

      })
      .catch(() => {
        location.replace("forbidden.html");
      });
  }

  /* =====================================================================================
     3ï¸âƒ£ ××™××•×ª token
     ===================================================================================== */
  function validateToken(uid, token) {
    return firebase.database()
      .ref("sessions/" + uid + "/token")
      .once("value")
      .then((snap) => {
        if (!snap.exists() || snap.val() !== token) {
          location.replace("forbidden.html");
          throw new Error("invalid token");
        }
      });
  }

  /* =====================================================================================
     4ï¸âƒ£ ×©×œ×™×¤×ª ×©× ××©×ª××©
     ===================================================================================== */
  function fetchUsername(uid) {
    return firebase.database()
      .ref("users/" + uid + "/username")
      .once("value")
      .then((snap) => snap.val());
  }

  /* =====================================================================================
     5ï¸âƒ£ ×˜×¢×™× ×ª ×¤×•×¡×˜ ×Ö¾DB (××œ×)
     - ×›×•×œ×œ ×ª××•× ×” ×× ×§×™×™××ª
     - ×›×•×œ×œ ×’×‘×•×œ ×¦×‘×¢×•× ×™ ×œ×¤×™ userColor(author)
     - ×›×•×œ×œ ×›×¤×ª×•×¨ ×¢×¨×™×›×” ×¢×“ 24 ×©×¢×•×ª (×¨×§ ×”××—×‘×¨)
     ===================================================================================== */
  function loadPost() {
    setStatus("×˜×•×¢×Ÿ ×¤×•×¡×˜â€¦", "info");

    firebase.database()
      .ref("posts/" + postId)
      .once("value")
      .then((snap) => {
        if (!snap.exists()) {
          postContainer.innerHTML = "<p>×”×¤×•×¡×˜ ×œ× × ××¦×.</p>";
          setStatus("×”×¤×•×¡×˜ ×œ× × ××¦×.", "error");
          return;
        }

        const p = snap.val() || {};
        currentPostObj = p;

        const author = safeText(p.author || "");
        const authorUid = safeText(p.authorUid || ""); // ×× ×§×™×™× ×‘×¢×ª×™×“
        const postTime = Number(p.time || 0);
        const imgUrl = sanitizeImageUrl(p.image || "");

        // ××™ ×”××—×‘×¨? (×ª×•××š ×’× authorUid ×× ×§×™×™×, ××—×¨×ª ×œ×¤×™ username)
        const isOwner = (authorUid && uid && authorUid === uid) || (!!author && author === username);

        // ×¢×“ 24 ×©×¢×•×ª
        const DAY_MS = 24 * 60 * 60 * 1000;
        const withinDay = postTime ? ((nowTs() - postTime) <= DAY_MS) : false;
        canEditPostNow = !!(isOwner && withinDay);

        // ×¦×‘×¢ ×’×‘×•×œ
        const border = userColor(author);

        // ×©××™×¨×” ×œ-cache ×œ× ×™×•×•×˜ ×—×–×¨×” (feature × ×©××¨, ×¢× ×ª××•× ×”)
        try {
          sessionStorage.setItem("currentPost", JSON.stringify({
            id: postId,
            title: safeText(p.title || ""),
            text: safeText(p.text || ""),
            author: author || "",
            image: imgUrl || ""
          }));
        } catch {}

        // ×¤×¢×•×œ×•×ª ×¤×•×¡×˜: copy/share/report + edit (×× ××•×ª×¨)
        postContainer.innerHTML = `
          <div class="post post-user-border" style="border-right-color:${escapeHTML(border)};">
            <h3>${escapeHTML(p.title || "")}</h3>
            <p>${escapeHTML(p.text || "")}</p>

            <small style="display:block; margin-top:6px; color:${escapeHTML(border)};">
              ×××ª: ${escapeHTML(author)}
            </small>

            <small style="opacity:.75; margin-top:6px; display:block;">
              ${escapeHTML(fmtDateTime(postTime || 0))}
            </small>

            ${imgUrl ? `
              <div class="post-image-wrap">
                <img class="post-image js-open-viewer"
                     data-hint="×ª××•× ×ª ×”×¤×•×¡×˜"
                     src="${escapeHTML(imgUrl)}"
                     alt="×ª××•× ×”" />
              </div>
            ` : ``}

            

              ${canEditPostNow ? `
                <button type="button" class="post-action" data-action="editPost"
                  style="padding:8px 10px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;font-weight:bold;">
                  ×¢×¨×•×š ×¤×•×¡×˜
                </button>
              ` : ``}
            </div>
          </div>
        `;

        bindPostActions();

        setStatus("×¤×•×¡×˜ × ×˜×¢×Ÿ.", "ok");
      })
      .catch(() => {
        postContainer.innerHTML = "<p>×©×’×™××” ×‘×˜×¢×™× ×ª ×”×¤×•×¡×˜.</p>";
        setStatus("×©×’×™××” ×‘×˜×¢×™× ×ª ×”×¤×•×¡×˜.", "error");
      });
  }

  /* =====================================================================================
     Post action buttons (×©×“×¨×•×’)
     ===================================================================================== */
  function bindPostActions() {
    if (postContainer.__actionsBound) return;
    postContainer.__actionsBound = true;

    postContainer.addEventListener("click", (e) => {
      const btn = e.target.closest(".post-action");
      if (!btn) return;

      const action = btn.getAttribute("data-action");
      if (!action) return;

      if (action === "copyLink") {
        const link = location.href;
        copyToClipboard(link);
        setStatus("×”×§×™×©×•×¨ ×”×•×¢×ª×§.", "ok");
      }

      if (action === "share") {
        const link = location.href;
        tryShareOrCopy(link);
      }

      if (action === "report") {
        reportPost();
      }

      if (action === "editPost") {
        openEditPostModal();
      }
    }, false);
  }

  function tryShareOrCopy(text) {
    try {
      if (navigator.share) {
        navigator.share({ title: "×¤×•×¨×•×", text: "×§×™×©×•×¨ ×œ×¤×•×¡×˜:", url: text })
          .then(() => setStatus("×©×•×ª×£.", "ok"))
          .catch(() => {
            copyToClipboard(text);
            setStatus("××™×Ÿ ×©×™×ª×•×£ ××•×‘× ×”. ×”×¢×ª×§×ª×™ ×§×™×©×•×¨.", "ok");
          });
      } else {
        copyToClipboard(text);
        setStatus("××™×Ÿ ×©×™×ª×•×£ ××•×‘× ×”. ×”×¢×ª×§×ª×™ ×§×™×©×•×¨.", "ok");
      }
    } catch {
      copyToClipboard(text);
      setStatus("×”×•×¢×ª×§ ×§×™×©×•×¨.", "ok");
    }
  }

  /* =====================================================================================
     Report post (×©×“×¨×•×’)
     - × ×©××¨, ×›×™ ×‘×™×§×©×ª ×œ×‘×˜×œ ×¨×§ ×“×™×•×•×— ×¢×œ ×ª×’×•×‘×•×ª
     ===================================================================================== */
  function reportPost() {
    if (!isAuthed || !uid) {
      setStatus("×œ× ×××•××ª. ×œ× × ×™×ª×Ÿ ×œ×“×•×•×—.", "error");
      return;
    }

    const reportObj = {
      type: "post",
      postId: postId,
      reporterUid: uid,
      reporterName: username,
      time: nowTs(),
      reason: "report"
    };

    firebase.database()
      .ref("reports")
      .push(reportObj)
      .then(() => setStatus("×“×•×•×— ×‘×”×¦×œ×—×”. ×ª×•×“×”.", "ok"))
      .catch(() => setStatus("×©×’×™××” ×‘×“×™×•×•×—.", "error"));
  }

  /* =====================================================================================
     EDIT POST (NEW) â€“ ×¢×“ 24 ×©×¢×•×ª, ×¨×§ ×”××—×‘×¨
     ===================================================================================== */
  function editPostErrorShow(msg) {
    if (!editPostError) return;
    editPostError.textContent = msg;
    editPostError.style.display = "block";
  }
  function editPostErrorHide() {
    if (!editPostError) return;
    editPostError.textContent = "";
    editPostError.style.display = "none";
  }

  function openEditPostModal() {
    if (!canEditPostNow) {
      setStatus("××™×Ÿ ×”×¨×©××” ×œ×¢×¨×•×š (×¨×§ ×”××—×‘×¨ ×•×¢×“ 24 ×©×¢×•×ª).", "error");
      return;
    }
    editPostErrorHide();

    const t = safeText((currentPostObj && currentPostObj.title) ? currentPostObj.title : "");
    const x = safeText((currentPostObj && currentPostObj.text) ? currentPostObj.text : "");

    if (editPostTitle) editPostTitle.value = t;
    if (editPostText) editPostText.value = x;

    if (editPostOverlay) editPostOverlay.style.display = "flex";
    setTimeout(() => { try { editPostTitle && editPostTitle.focus(); } catch {} }, 50);
  }

  function closeEditPostModal() {
    editPostErrorHide();
    if (editPostOverlay) editPostOverlay.style.display = "none";
  }

  if (closeEditPostBtn) closeEditPostBtn.addEventListener("click", closeEditPostModal);
  if (cancelEditPostBtn) cancelEditPostBtn.addEventListener("click", closeEditPostModal);

  if (editPostOverlay) {
    editPostOverlay.addEventListener("click", function (e) {
      if (e.target === editPostOverlay) closeEditPostModal();
    });
  }

  if (saveEditPostBtn) {
    saveEditPostBtn.addEventListener("click", function () {
      editPostErrorHide();

      if (!isAuthed || !uid) {
        editPostErrorShow("×œ× ×××•××ª. × ×¡×” ×©×•×‘.");
        return;
      }
      if (!canEditPostNow) {
        editPostErrorShow("××™×Ÿ ×”×¨×©××” ×œ×¢×¨×•×š (×¨×§ ×”××—×‘×¨ ×•×¢×“ 24 ×©×¢×•×ª).");
        return;
      }

      const title = safeText(editPostTitle ? editPostTitle.value : "").trim();
      const text = safeText(editPostText ? editPostText.value : "").trim();

      if (title.length < 3) { editPostErrorShow("×›×•×ª×¨×ª ×§×¦×¨×” ××“×™. ××™× ×™××•× 3 ×ª×•×•×™×."); return; }
      if (text.length < 3) { editPostErrorShow("×ª×•×›×Ÿ ×§×¦×¨ ××“×™. ××™× ×™××•× 3 ×ª×•×•×™×."); return; }

      setStatus("×©×•××¨ ×¢×¨×™×›×”â€¦", "info");
      saveEditPostBtn.disabled = true;

      // Selective update: ×¨×§ title/text (×œ× ××©× ×™× time, ×œ× × ×•×’×¢×™× ×‘××‘×˜×—×”)
      firebase.database()
        .ref("posts/" + postId)
        .update({
          title: title,
          text: text
        })
        .then(() => {
          setStatus("×”×¤×•×¡×˜ ×¢×•×“×›×Ÿ.", "ok");
          closeEditPostModal();
          // ×¨×¢× ×•×Ÿ ×¤×•×¡×˜ ×œ-UI + cache
          loadPost();
        })
        .catch(() => {
          editPostErrorShow("×©×’×™××” ×‘×©××™×¨×ª ×”×¢×¨×™×›×”. × ×¡×” ×©×•×‘.");
          setStatus("×©×’×™××” ×‘×©××™×¨×ª ×”×¢×¨×™×›×”.", "error");
        })
        .finally(() => {
          saveEditPostBtn.disabled = false;
        });
    });
  }

  /* =====================================================================================
     6ï¸âƒ£ ×˜×¢×™× ×ª ×ª×’×•×‘×•×ª (×¢× cache + ×©×“×¨×•×’×™×)
     ===================================================================================== */
  function loadComments(isFirst = false, isLoadMore = false) {
    if (!isAuthed) return;

    if (isFirst) {
      commentsBox.innerHTML = "<div class='loader'></div>";
    }

    const limit = Math.max(1, Number(commentsLimit || 200));

    firebase.database()
      .ref("comments/" + postId)
      .orderByChild("time")
      .limitToLast(limit)
      .once("value")
      .then((snap) => {
        const items = [];
        snap.forEach((cSnap) => {
          const v = cSnap.val() || {};
          items.push({
            id: cSnap.key,
            text: safeText(v.text),
            author: safeText(v.author),
            authorUid: safeText(v.authorUid || ""),
            time: Number(v.time || 0),
            image: sanitizeImageUrl(v.image || "")
          });
        });

        canLoadMore = items.length >= limit;
        if (loadMoreCommentsBtn) {
          loadMoreCommentsBtn.style.display = canLoadMore ? "inline-block" : "none";
        }

        commentsCache = items;

        renderCommentsFromCache();

        if (isLoadMore) {
          setStatus("× ×˜×¢× ×• ×¢×•×“ ×ª×’×•×‘×•×ª.", "ok");
        } else if (isFirst) {
          setStatus("×ª×’×•×‘×•×ª × ×˜×¢× ×•.", "ok");
        }
      })
      .catch(() => {
        commentsBox.innerHTML = "<p>×©×’×™××” ×‘×˜×¢×™× ×ª ×ª×’×•×‘×•×ª.</p>";
        setStatus("×©×’×™××” ×‘×˜×¢×™× ×ª ×ª×’×•×‘×•×ª.", "error");
      });
  }

  /* =====================================================================================
     Render comments from cache (×—×™×¤×•×© + ××™×•×Ÿ)
     ===================================================================================== */
  function renderCommentsFromCache() {
    const q = safeText(commentSearch?.value).trim().toLowerCase();
    const mode = safeText(commentSort?.value) || "newest";

    let list = commentsCache.slice();

    if (q) {
      list = list.filter((c) => {
        const t = (c.text || "").toLowerCase();
        const a = (c.author || "").toLowerCase();
        const hasImg = c.image ? "×ª××•× ×”" : "";
        return t.includes(q) || a.includes(q) || hasImg.includes(q);
      });
    }

    if (mode === "oldest") {
      list.sort((a, b) => (a.time || 0) - (b.time || 0));
    } else if (mode === "author") {
      list.sort((a, b) => (a.author || "").localeCompare(b.author || "", "he"));
    } else {
      list.sort((a, b) => (b.time || 0) - (a.time || 0));
    }

    if (list.length === 0) {
      commentsBox.innerHTML = q ? "<p>×œ× × ××¦××• ×ª×•×¦××•×ª.</p>" : "<p>××™×Ÿ ×ª×’×•×‘×•×ª ×¢×“×™×™×Ÿ.</p>";
      commentsRenderedHtml = commentsBox.innerHTML;
      return;
    }

    commentsBox.innerHTML = "";
    for (const c of list) {
      renderComment(c.id, c);
    }

    commentsRenderedHtml = commentsBox.innerHTML;
  }

  /* =====================================================================================
     7ï¸âƒ£ Render single comment
     - ×‘×•×˜×œ ×“×™×•×•×— ×¢×œ ×ª×’×•×‘×•×ª: ×”×›×¤×ª×•×¨ ×”×•×—×œ×£ ×‘"×¢×¨×•×š" (×œ××—×‘×¨)
     - ×ª××•× ×” ×œ×ª×’×•×‘×” (×ª×¦×•×’×” ×§×˜× ×”) ×× ×§×™×™××ª
     ===================================================================================== */
  function canEditItem(author, authorUid, itemTime) {
    try {
      const a = safeText(author || "");
      const au = safeText(authorUid || "");
      const t = Number(itemTime || 0) || 0;

      const isOwner = (au && uid && au === uid) || (!!a && a === username);
      const DAY_MS = 24 * 60 * 60 * 1000;
      const withinDay = t ? ((nowTs() - t) <= DAY_MS) : false;

      return !!(isOwner && withinDay);
    } catch (e) {
      return false;
    }
  }

  function renderComment(id, c) {
    const color = userColor(c.author);
    const canEdit = canEditItem(c.author, c.authorUid, c.time);

    const div = document.createElement("div");
    div.className = "comment";
    div.style.borderRightColor = color;
    div.setAttribute("data-comment-id", id);

    const imgUrl = sanitizeImageUrl(c.image || "");

    div.innerHTML = `
      <div class="comment-meta">
        <span class="comment-author">${escapeHTML(c.author || "")}</span>
        <span class="comment-time">${escapeHTML(fmtTime(c.time || 0))}</span>
      </div>

      <p class="comment-text" id="comment-text-${escapeHTML(id)}">${escapeHTML(c.text || "")}</p>

      ${imgUrl ? `
        <img class="mini-image js-open-viewer"
             data-hint="×ª××•× ×” ×‘×ª×’×•×‘×”"
             src="${escapeHTML(imgUrl)}"
             alt="×ª××•× ×”" />
      ` : ``}

      <div class="comment-actions" style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
        <button type="button" class="btn-reply" data-action="openReply" data-id="${escapeHTML(id)}">×”×©×‘</button>

        <span class="reply-count"
              id="reply-count-${escapeHTML(id)}"
              data-action="toggleReplies"
              data-id="${escapeHTML(id)}"
              style="cursor:pointer; user-select:none;">
          ×˜×•×¢×Ÿ ×ª×’×•×‘×•×ªâ€¦
        </span>

        <button type="button"
                class="btn-copy"
                data-action="copyComment"
                data-id="${escapeHTML(id)}"
                style="padding:6px 10px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;">
          ×”×¢×ª×§
        </button>

        ${canEdit ? `
          <button type="button"
                  class="btn-edit"
                  data-action="editComment"
                  data-id="${escapeHTML(id)}"
                  style="padding:6px 10px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;font-weight:bold;">
            ×¢×¨×•×š
          </button>
        ` : ``}

        <!-- DISABLED: reporting comments per request (kept for length) -->
        <!--
        <button type="button"
                class="btn-report"
                data-action="reportComment"
                data-id="${escapeHTML(id)}"
                style="padding:6px 10px;border-radius:10px;border:1px solid rgba(255,0,0,0.35);background:rgba(255,0,0,0.06);cursor:pointer;">
          ×“×•×•×—
        </button>
        -->
      </div>

      <div class="replies hidden" id="replies-${escapeHTML(id)}"></div>
    `;

    commentsBox.appendChild(div);

    updateReplyCount(id);
  }

  /* =====================================================================================
     Delegation for comment actions (×™×¦×™×‘ ×‘-WebView)
     + ×©×“×¨×•×’: ×¤×ª×™×—×ª viewer ×¢×œ ×ª××•× ×•×ª
     ===================================================================================== */
  (function bindCommentDelegation() {
    if (commentsBox.__delegationBound) return;
    commentsBox.__delegationBound = true;

    commentsBox.addEventListener("click", (e) => {

      // open viewer for any image with .js-open-viewer
      try {
        const img = e.target.closest(".js-open-viewer");
        if (img) {
          const src = img.getAttribute("src") || "";
          const hint = img.getAttribute("data-hint") || "";
          openMiniViewer(src, hint);
          return;
        }
      } catch {}

      const el = e.target.closest("[data-action]");
      if (!el) return;

      const action = el.getAttribute("data-action");
      const id = el.getAttribute("data-id");
      if (!action || !id) return;

      if (action === "openReply") {
        openReply(id);
      }

      if (action === "toggleReplies") {
        toggleReplies(id);
      }

      if (action === "copyComment") {
        const commentNode = el.closest(".comment");
        const textNode = commentNode ? commentNode.querySelector(".comment-text") : null;
        const txt = textNode ? textNode.innerText : "";
        copyToClipboard(txt);
        setStatus("×”×ª×’×•×‘×” ×”×•×¢×ª×§×”.", "ok");
      }

      if (action === "editComment") {
        beginInlineEditComment(id);
      }

      // DISABLED per request (kept for length)
      if (action === "reportComment") {
        // reportComment(id);
      }

    }, false);
  })();

  /* =====================================================================================
     Replies feature â€“ × ×©××¨ + ××©×•×“×¨×’
     - ×¨×™×¤×œ×™×™ ×’× ×™×›×•×œ ×œ×›×œ×•×œ ×ª××•× ×” (×›××• ×ª×’×•×‘×”) + ×¢×¨×™×›×” ×‘××§×•× ×“×™×•×•×—
     - ×—×©×•×‘: ×¨×™×¤×œ×™×™ ×œ× × ×¡×¤×¨ ×‘-count ×©×œ ×ª×’×•×‘×•×ª ×œ×¤×•×¡×˜ (×–×” × ×©××¨ ×‘-forum)
     ===================================================================================== */

  window.updateReplyCount = updateReplyCount;
  window.toggleReplies = toggleReplies;
  window.openReply = openReply;
  window.sendReply = sendReply;

  function updateReplyCount(id) {
    if (!isAuthed) return;

    firebase.database()
      .ref("replies/" + postId + "/" + id)
      .once("value")
      .then((s) => {
        const el = document.getElementById("reply-count-" + id);
        if (!el) return;
        const count = s.numChildren();
        el.textContent = count ? `${count} ×ª×’×•×‘×•×ª â–¾` : "××™×Ÿ ×ª×’×•×‘×•×ª";
      })
      .catch(() => {});
  }

  function toggleReplies(id) {
    const box = document.getElementById("replies-" + id);
    if (!box) return;

    const isOpen = !box.classList.contains("hidden");

    if (isOpen) {
      box.classList.add("hidden");
      repliesOpenState[id] = false;
      detachRepliesLive(id);
      return;
    }

    box.classList.remove("hidden");
    repliesOpenState[id] = true;

    box.innerHTML = "<div class='loader'></div>";

    firebase.database()
      .ref("replies/" + postId + "/" + id)
      .orderByChild("time")
      .limitToLast(200)
      .once("value")
      .then((s) => {
        let html = "";

        if (!s.exists()) {
          html = `
            <div style="padding:10px 0; opacity:.75;">
              ××™×Ÿ ×ª×’×•×‘×•×ª ×¢×“×™×™×Ÿ. ×ª×”×™×” ×”×¨××©×•×Ÿ.
            </div>
          `;
        } else {
          const arr = [];
          s.forEach((r) => {
            const d = r.val() || {};
            arr.push({
              rid: r.key,
              author: safeText(d.author),
              authorUid: safeText(d.authorUid || ""),
              text: safeText(d.text),
              time: Number(d.time || 0),
              image: sanitizeImageUrl(d.image || "")
            });
          });

          arr.sort((a, b) => (a.time || 0) - (b.time || 0));

          for (const d of arr) {
            html += buildReplyHTML(id, d);
          }
        }

        html += buildReplyComposerHTML(id);

        box.innerHTML = html;

        attachRepliesLive(id);
        updateReplyCount(id);
      })
      .catch(() => {
        box.innerHTML = "<p>×©×’×™××” ×‘×˜×¢×™× ×ª ×ª×’×•×‘×•×ª-×¢×œ-×ª×’×•×‘×”.</p>";
      });
  }

  function buildReplyHTML(commentId, d) {
    const c = userColor(d.author);
    const canEdit = canEditItem(d.author, d.authorUid, d.time);
    const imgUrl = sanitizeImageUrl(d.image || "");

    return `
      <div class="reply" data-reply-id="${escapeHTML(d.rid || "")}" style="
        border-right: 4px solid ${escapeHTML(c)};
        padding:10px 10px;
        margin:10px 0;
        border-radius:10px;
        background: rgba(0,0,0,0.03);
      ">
        <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
          <b style="color:${escapeHTML(c)};">${escapeHTML(d.author || "")}</b>
          <small style="opacity:.75;">${escapeHTML(fmtTime(d.time || 0))}</small>
        </div>

        <p class="reply-text" id="reply-text-${escapeHTML(commentId)}-${escapeHTML(d.rid || "")}" style="margin:8px 0 0 0;">
          ${escapeHTML(d.text || "")}
        </p>

        ${imgUrl ? `
          <img class="mini-image js-open-viewer"
               data-hint="×ª××•× ×” ×‘×¨×™×¤×œ×™×™"
               src="${escapeHTML(imgUrl)}"
               alt="×ª××•× ×”" />
        ` : ``}

        <div style="margin-top:8px; display:flex; gap:10px; flex-wrap:wrap;">
          <button type="button"
                  data-reply-action="copyReply"
                  data-comment-id="${escapeHTML(commentId)}"
                  data-reply-id="${escapeHTML(d.rid || "")}"
                  style="padding:6px 10px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;">
            ×”×¢×ª×§
          </button>

          ${canEdit ? `
            <button type="button"
                    data-reply-action="editReply"
                    data-comment-id="${escapeHTML(commentId)}"
                    data-reply-id="${escapeHTML(d.rid || "")}"
                    style="padding:6px 10px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;font-weight:bold;">
              ×¢×¨×•×š
            </button>
          ` : ``}

          <!-- DISABLED: reporting replies per request (kept for length) -->
          <!--
          <button type="button"
                  data-reply-action="reportReply"
                  data-comment-id="${escapeHTML(commentId)}"
                  data-reply-id="${escapeHTML(d.rid || "")}"
                  style="padding:6px 10px;border-radius:10px;border:1px solid rgba(255,0,0,0.35);background:rgba(255,0,0,0.06);cursor:pointer;">
            ×“×•×•×—
          </button>
          -->
        </div>
      </div>
    `;
  }

  function buildReplyComposerHTML(commentId) {
    return `
      <div class="reply-composer" style="
        margin-top:12px;
        padding:12px;
        border-radius:12px;
        border:1px solid rgba(0,0,0,0.10);
        background:#fff;
      ">
        <div style="font-weight:bold; margin-bottom:8px;">×”×•×¡×£ ×ª×’×•×‘×” ×œ×ª×’×•×‘×”</div>

        <textarea id="reply-textarea-${escapeHTML(commentId)}"
                  placeholder="×›×ª×•×‘ ×ª×’×•×‘×”..."
                  maxlength="600"
                  rows="3"
                  style="
                    width:100%;
                    box-sizing:border-box;
                    padding:10px 12px;
                    border-radius:10px;
                    border:1px solid rgba(0,0,0,0.15);
                    outline:none;
                    resize:vertical;
                  "></textarea>

        <!-- =====================================================================================
             REPLY IMAGE (NEW) â€“ ×ª××•× ×” ×œ×¨×™×¤×œ×™×™ (××•×¤×¦×™×•× ×œ×™)
             ===================================================================================== -->
        <div style="
          margin-top:10px;
          border:1px solid rgba(0,0,0,0.10);
          border-radius:14px;
          padding:12px;
          background: rgba(0,0,0,0.02);
        ">
          <div class="img-actions-row">
            <div style="display:flex; flex-direction:column; gap:4px;">
              <div style="font-weight:bold;">×ª××•× ×” ×œ×¨×™×¤×œ×™×™ (××•×¤×¦×™×•× ×œ×™)</div>
              <div style="font-size:12px; opacity:.75;">×¤×•×¨××˜×™× × ×ª××›×™×: JPG/PNG/WebP. ××•××œ×¥ ×¢×“ 9MB.</div>
            </div>

            <div style="display:flex; gap:10px; flex-wrap:wrap;">
              <button type="button"
                      class="img-btn img-btn-primary"
                      data-reply-action="chooseReplyImage"
                      data-id="${escapeHTML(commentId)}">×‘×—×¨ ×ª××•× ×”</button>

              <button type="button"
                      class="img-btn img-btn-danger"
                      data-reply-action="removeReplyImage"
                      data-id="${escapeHTML(commentId)}"
                      style="display:none;"
                      id="reply-remove-img-${escapeHTML(commentId)}">×”×¡×¨ ×ª××•× ×”</button>
            </div>
          </div>

          <input id="reply-image-${escapeHTML(commentId)}" type="file" accept="image/*" style="display:none;" />

          <div id="reply-preview-wrap-${escapeHTML(commentId)}" style="display:none;">
            <div class="img-preview">
              <img id="reply-preview-img-${escapeHTML(commentId)}" alt="×ª×¦×•×’×” ××§×“×™××”" src="" />
            </div>
          </div>
        </div>

        <div style="margin-top:10px; display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <small style="opacity:.75;">××§×¡×™××•× 600 ×ª×•×•×™×.</small>
          <div style="display:flex; gap:10px;">
            <button type="button"
                    class="reply-send-btn"
                    data-reply-action="sendReply"
                    data-id="${escapeHTML(commentId)}"
                    style="
                      padding:8px 12px;
                      border-radius:10px;
                      border:none;
                      background: rgb(17,17,87);
                      color:#fff;
                      cursor:pointer;
                      font-weight:bold;
                    ">×©×œ×—</button>
            <button type="button"
                    class="reply-close-btn"
                    data-reply-action="closeReplies"
                    data-id="${escapeHTML(commentId)}"
                    style="
                      padding:8px 12px;
                      border-radius:10px;
                      border:1px solid rgba(0,0,0,0.15);
                      background:#fff;
                      cursor:pointer;
                      font-weight:bold;
                    ">×¡×’×•×¨</button>
          </div>
        </div>

        <div id="reply-error-${escapeHTML(commentId)}" style="
          display:none;
          margin-top:10px;
          padding:10px 12px;
          border-radius:12px;
          background: rgba(255,0,0,0.08);
          color:#8a0000;
          font-size:13px;
        "></div>
      </div>
    `;
  }

  // Reply image state per commentId
  const replyImageState = Object.create(null); // commentId => {file, previewUrl, canRevoke}

  function initReplyImageState(commentId) {
    const id = safeText(commentId || "");
    if (!id) return;
    if (!replyImageState[id]) {
      replyImageState[id] = { file: null, previewUrl: "", canRevoke: false };
    }
  }

  function clearReplyImage(commentId, resetInput) {
    initReplyImageState(commentId);
    const st = replyImageState[commentId];

    try {
      if (st.previewUrl && st.canRevoke) {
        try { URL.revokeObjectURL(st.previewUrl); } catch {}
      }
    } catch {}

    st.file = null;
    st.previewUrl = "";
    st.canRevoke = false;

    try {
      const img = document.getElementById("reply-preview-img-" + commentId);
      const wrap = document.getElementById("reply-preview-wrap-" + commentId);
      const inp = document.getElementById("reply-image-" + commentId);
      const rm = document.getElementById("reply-remove-img-" + commentId);

      if (img) img.setAttribute("src", "");
      if (wrap) wrap.style.display = "none";
      if (rm) rm.style.display = "none";
      if (resetInput && inp) inp.value = "";
    } catch {}
  }

  /* =====================================================================================
     Delegation ×‘×ª×•×š replies containers (×©×“×¨×•×’ ×™×¦×™×‘×•×ª)
     + ×¢×¨×™×›×” ×œ×¨×™×¤×œ×™×™
     + ×ª××•× ×•×ª ×œ×¨×™×¤×œ×™×™
     ===================================================================================== */
  (function bindRepliesDelegation() {
    if (commentsBox.__repliesDelegationBound) return;
    commentsBox.__repliesDelegationBound = true;

    commentsBox.addEventListener("click", (e) => {
      const a = e.target.closest("[data-reply-action]");
      if (!a) return;

      const act = a.getAttribute("data-reply-action");
      const cid = a.getAttribute("data-id") || a.getAttribute("data-comment-id");
      const rid = a.getAttribute("data-reply-id");

      if (!act || !cid) return;

      if (act === "sendReply") {
        sendReply(cid);
      }

      if (act === "closeReplies") {
        toggleReplies(cid);
      }

      if (act === "copyReply") {
        const replyNode = a.closest(".reply");
        const p = replyNode ? replyNode.querySelector(".reply-text") : null;
        const txt = p ? p.innerText : "";
        copyToClipboard(txt);
        setStatus("×”×ª×’×•×‘×”-×¢×œ-×ª×’×•×‘×” ×”×•×¢×ª×§×”.", "ok");
      }

      if (act === "editReply") {
        if (!rid) return;
        beginInlineEditReply(cid, rid);
      }

      if (act === "chooseReplyImage") {
        initReplyImageState(cid);
        try {
          const inp = document.getElementById("reply-image-" + cid);
          if (inp) {
            inp.value = "";
            inp.click();
          }
        } catch {}
      }

      if (act === "removeReplyImage") {
        clearReplyImage(cid, true);
      }

      // DISABLED per request (kept for length)
      if (act === "reportReply") {
        // if (!rid) return;
        // reportReply(cid, rid);
      }

    }, false);

    // change handler for each reply image input (event delegation is hard for change)
    // solution: attach when replies open (selective & safe)
  })();

  function bindReplyImageInput(commentId) {
    try {
      const inp = document.getElementById("reply-image-" + commentId);
      if (!inp || inp.__bound) return;
      inp.__bound = true;

      inp.addEventListener("change", function () {
        try {
          const f = (inp.files && inp.files[0]) ? inp.files[0] : null;
          if (!f) return;

          if (!isLikelyImageFile(f)) {
            replyErrorShow(commentId, "×§×•×‘×¥ ×œ× × ×ª××š. ×‘×—×¨ ×ª××•× ×” (JPG/PNG/WebP).");
            clearReplyImage(commentId, true);
            return;
          }

          if (Number(f.size || 0) > MAX_IMG) {
            replyErrorShow(commentId, "×”×ª××•× ×” ×’×“×•×œ×” ××“×™ (" + bytesToHuman(f.size) + "). ×¢×“ 9MB.");
            clearReplyImage(commentId, true);
            return;
          }

          initReplyImageState(commentId);
          const st = replyImageState[commentId];
          st.file = f;

          // cleanup preview
          try {
            if (st.previewUrl && st.canRevoke) { try { URL.revokeObjectURL(st.previewUrl); } catch {} }
          } catch {}
          st.previewUrl = "";
          st.canRevoke = false;

          const img = document.getElementById("reply-preview-img-" + commentId);
          const wrap = document.getElementById("reply-preview-wrap-" + commentId);
          const rm = document.getElementById("reply-remove-img-" + commentId);

          let previewSet = false;
          try {
            if (window.URL && typeof URL.createObjectURL === "function") {
              const u = URL.createObjectURL(f);
              st.previewUrl = u;
              st.canRevoke = true;
              if (img) img.setAttribute("src", u);
              if (wrap) wrap.style.display = "block";
              if (rm) rm.style.display = "inline-block";
              previewSet = true;
            }
          } catch {}

          if (!previewSet) {
            readFileAsDataURLWithRetry(f, 3, function (durl, ok) {
              if (!ok) {
                replyErrorShow(commentId, "×œ× ×”×¦×œ×—×ª×™ ×œ×”×¦×™×’ ×ª×¦×•×’×” ××§×“×™××”, ××‘×œ ×× ×¡×” ×œ×”×¢×œ×•×ª ×›×¨×’×™×œ.");
                return;
              }
              st.previewUrl = durl;
              st.canRevoke = false;
              if (img) img.setAttribute("src", durl);
              if (wrap) wrap.style.display = "block";
              if (rm) rm.style.display = "inline-block";
            });
          }

        } catch {}
      });
    } catch {}
  }

  function openReply(id) {
    const box = document.getElementById("replies-" + id);
    if (!box) return;

    if (box.classList.contains("hidden")) {
      toggleReplies(id);
      setTimeout(() => {
        const ta = document.getElementById("reply-textarea-" + id);
        try { ta && ta.focus(); } catch {}
      }, 150);
      return;
    }

    const ta = document.getElementById("reply-textarea-" + id);
    try { ta && ta.focus(); } catch {}
  }

  function replyErrorShow(commentId, msg) {
    const el = document.getElementById("reply-error-" + commentId);
    if (!el) return;
    el.textContent = msg;
    el.style.display = "block";
  }

  function replyErrorHide(commentId) {
    const el = document.getElementById("reply-error-" + commentId);
    if (!el) return;
    el.textContent = "";
    el.style.display = "none";
  }

  /* =====================================================================================
     Upload helpers (storage.put preferred, fallback to putString)
     ===================================================================================== */
  function uploadImageToStorage(file, storagePath, onProgress) {
    return new Promise(function (resolve, reject) {
      try {
        if (!file || !storagePath) { reject("missing"); return; }

        const ref = firebase.storage().ref(storagePath);
        let task = null;

        try {
          task = ref.put(file);
        } catch (ePut) {
          task = null;
        }

        if (task) {
          task.on("state_changed",
            function (snap) {
              try {
                if (!snap) return;
                const bytes = Number(snap.bytesTransferred || 0);
                const total = Number(snap.totalBytes || 0);
                if (total > 0) {
                  const pct = Math.round((bytes / total) * 100);
                  if (typeof onProgress === "function") onProgress(pct);
                }
              } catch {}
            },
            function (err) { reject(err); },
            function () {
              task.snapshot.ref.getDownloadURL()
                .then(function (url) { resolve(url); })
                .catch(function (e) { reject(e); });
            }
          );
          return;
        }

        // fallback: data_url upload (only if put(file) isn't available)
        readFileAsDataURLWithRetry(file, 3, function (durl, ok) {
          if (!ok) { reject("read_failed"); return; }

          const task2 = ref.putString(durl, "data_url");
          task2.on("state_changed",
            function (snap) {
              try {
                if (!snap) return;
                const bytes = Number(snap.bytesTransferred || 0);
                const total = Number(snap.totalBytes || 0);
                if (total > 0) {
                  const pct = Math.round((bytes / total) * 100);
                  if (typeof onProgress === "function") onProgress(pct);
                }
              } catch {}
            },
            function (err) { reject(err); },
            function () {
              task2.snapshot.ref.getDownloadURL()
                .then(function (url) { resolve(url); })
                .catch(function (e) { reject(e); });
            }
          );
        });

      } catch (e0) {
        reject(e0);
      }
    });
  }

  /* =====================================================================================
     CRITICAL: Update lastCommentTime for forum sort (includes replies)
     - ×–×” ××” ×©×’×•×¨× ×œ×¤×•×¡×˜ ×œ×§×¤×•×¥ ×‘××™×•×Ÿ "×ª×’×•×‘×” ××—×¨×•× ×”" ×‘×¤×•×¨×•×
     - ×œ× × ×•×’×¢ ×‘×¡×¤×™×¨×ª ×ª×’×•×‘×•×ª (commentsCount × ×©××¨ ×¨×§ ×œ×ª×’×•×‘×•×ª, ×œ× ×œ×¨×™×¤×œ×™×™×–)
     ===================================================================================== */
  function bumpPostLastCommentTime(ts) {
    try {
      const t = Number(ts || 0) || nowTs();
      firebase.database().ref("posts/" + postId + "/lastCommentTime").set(t);
    } catch {}
  }

  function incrementPostCommentsCount() {
    try {
      // count ONLY comments (not replies) => aligns with your request
      firebase.database().ref("posts/" + postId + "/commentsCount").transaction(function (cur) {
        const x = Number(cur || 0) || 0;
        return x + 1;
      });
    } catch {}
  }

  /* =====================================================================================
     Send reply (now supports optional image + bumps lastCommentTime)
     ===================================================================================== */
  function sendReply(commentId) {
    if (!isAuthed) return;

    const ta = document.getElementById("reply-textarea-" + commentId);
    if (!ta) return;

    replyErrorHide(commentId);

    const raw = safeText(ta.value).trim();
    if (!raw && !(replyImageState[commentId] && replyImageState[commentId].file)) {
      replyErrorShow(commentId, "×›×ª×•×‘ ××©×”×• ××• ×¦×¨×£ ×ª××•× ×”.");
      return;
    }

    if (replySendingMap[commentId]) return;
    replySendingMap[commentId] = true;

    const text = clampTextLen(raw, 600);
    const replyRef = firebase.database().ref("replies/" + postId + "/" + commentId).push();
    const replyId = replyRef.key;

    const st = replyImageState[commentId] ? replyImageState[commentId] : null;
    const file = st && st.file ? st.file : null;

    const finishWrite = function (imageUrl) {
      const obj = {
        text: text,
        author: username,
        time: nowTs(),
        authorUid: uid || ""
      };
      if (imageUrl) obj.image = sanitizeImageUrl(imageUrl);

      return replyRef.set(obj);
    };

    // if image: upload first
    let chain = Promise.resolve("");

    if (file) {
      if (!isLikelyImageFile(file) || Number(file.size || 0) > MAX_IMG) {
        replyErrorShow(commentId, "×”×ª××•× ×” ×œ× ×ª×§×™× ×” ××• ×’×“×•×œ×” ××“×™. ×‘×—×¨ ××—×“×©.");
        clearReplyImage(commentId, true);
        replySendingMap[commentId] = false;
        return;
      }

      const ext = safeText(file.name || "").includes(".") ? safeText(file.name).split(".").pop().toLowerCase() : "jpg";
      const name = nowTs() + "_" + (uid || "u") + "." + (ext || "jpg");
      const path = "reply-images/" + postId + "/" + commentId + "/" + replyId + "/" + name;

      setStatus("××¢×œ×” ×ª××•× ×” ×œ×¨×™×¤×œ×™×™â€¦", "info");

      chain = uploadImageToStorage(file, path, function () {})
        .then(function (url) {
          setStatus("×©×•××¨ ×¨×™×¤×œ×™×™â€¦", "info");
          return url;
        });
    }

    chain
      .then(function (url) {
        return finishWrite(url || "");
      })
      .then(() => {
        ta.value = "";
        clearReplyImage(commentId, true);

        updateReplyCount(commentId);

        // THIS is the key for forum sorting:
        bumpPostLastCommentTime(nowTs());

        // refresh open box gently
        if (repliesOpenState[commentId]) {
          toggleReplies(commentId);
          setTimeout(() => toggleReplies(commentId), 50);
        }

        setStatus("× ×©×œ×— ×¨×™×¤×œ×™×™.", "ok");
      })
      .catch(() => {
        replyErrorShow(commentId, "×©×’×™××” ×‘×©×œ×™×—×”. × ×¡×” ×©×•×‘.");
        setStatus("×©×’×™××” ×‘×©×œ×™×—×”.", "error");
      })
      .finally(() => {
        replySendingMap[commentId] = false;
      });
  }

  /* =====================================================================================
     Main comment send (×›×•×œ×œ ×ª××•× ×”) + bump lastCommentTime + increment commentsCount
     ===================================================================================== */
  function sendMain() {
    if (!isAuthed) return;

    const raw = safeText(mainText.value).trim();

    if (!raw && !mainCommentImageFile) {
      setStatus("×›×ª×•×‘ ×ª×’×•×‘×” ××• ×¦×¨×£ ×ª××•× ×”.", "warn");
      return;
    }

    if (mainSending) return;
    mainSending = true;

    sendMainBtn.disabled = true;

    const text = clampTextLen(raw, MAIN_MAX);

    const commentRef = firebase.database().ref("comments/" + postId).push();
    const commentId = commentRef.key;

    const finishWrite = function (imageUrl) {
      const obj = {
        text: text,
        author: username,
        time: nowTs(),
        authorUid: uid || ""
      };
      if (imageUrl) obj.image = sanitizeImageUrl(imageUrl);

      return commentRef.set(obj);
    };

    let chain = Promise.resolve("");

    if (mainCommentImageFile) {
      const f = mainCommentImageFile;

      if (!isLikelyImageFile(f) || Number(f.size || 0) > MAX_IMG) {
        setStatus("×”×ª××•× ×” ×œ× ×ª×§×™× ×” ××• ×’×“×•×œ×” ××“×™. ×‘×—×¨ ××—×“×©.", "error");
        clearMainCommentImage(true);
        sendMainBtn.disabled = false;
        mainSending = false;
        return;
      }

      const ext = safeText(f.name || "").includes(".") ? safeText(f.name).split(".").pop().toLowerCase() : "jpg";
      const name = nowTs() + "_" + (uid || "u") + "." + (ext || "jpg");
      const path = "comment-images/" + postId + "/" + commentId + "/" + name;

      setStatus("××¢×œ×” ×ª××•× ×” ×œ×ª×’×•×‘×”â€¦", "info");

      chain = uploadImageToStorage(f, path, function () {})
        .then(function (url) {
          setStatus("×©×•××¨ ×ª×’×•×‘×”â€¦", "info");
          return url;
        });
    }

    chain
      .then(function (url) {
        return finishWrite(url || "");
      })
      .then(() => {
        closeMain();

        // key for forum sorting:
        bumpPostLastCommentTime(nowTs());

        // count ONLY comments (not replies)
        incrementPostCommentsCount();

        // keep existing behavior
        loadComments(false, false);
        setStatus("×ª×’×•×‘×” × ×©×œ×—×”.", "ok");
      })
      .catch(() => {
        setStatus("×©×’×™××” ×‘×©×œ×™×—×ª ×ª×’×•×‘×”.", "error");
      })
      .finally(() => {
        mainSending = false;
        sendMainBtn.disabled = false;
      });
  }

  /* =====================================================================================
     Inline edit â€“ COMMENT (NEW)
     ===================================================================================== */
  function beginInlineEditComment(commentId) {
    try {
      const cid = safeText(commentId || "");
      if (!cid) return;

      // find comment in cache to validate permission
      const c = commentsCache.find(x => x.id === cid);
      if (!c) return;

      if (!canEditItem(c.author, c.authorUid, c.time)) {
        setStatus("××™×Ÿ ×”×¨×©××” ×œ×¢×¨×•×š ×ª×’×•×‘×” (×¨×§ ×”××—×‘×¨ ×•×¢×“ 24 ×©×¢×•×ª).", "error");
        return;
      }

      const commentNode = commentsBox.querySelector('.comment[data-comment-id="' + cid + '"]');
      if (!commentNode) return;

      // avoid duplicate editor
      if (commentNode.querySelector(".inline-edit-box")) return;

      const textEl = commentNode.querySelector(".comment-text");
      const oldText = textEl ? safeText(textEl.innerText || "") : safeText(c.text || "");

      const box = document.createElement("div");
      box.className = "inline-edit-box";
      box.innerHTML = `
        <div style="font-weight:bold; margin-bottom:8px;">×¢×¨×™×›×ª ×ª×’×•×‘×”</div>
        <textarea id="edit-comment-ta-${escapeHTML(cid)}" rows="4" maxlength="800">${escapeHTML(oldText)}</textarea>
        <div style="margin-top:10px; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center;">
          <small style="opacity:.75;">××§×¡×™××•× 800 ×ª×•×•×™×.</small>
          <div style="display:flex; gap:10px;">
            <button type="button" data-inline-action="saveCommentEdit" data-id="${escapeHTML(cid)}"
              style="padding:8px 12px;border-radius:10px;border:none;background:rgb(17,17,87);color:#fff;cursor:pointer;font-weight:bold;">×©××•×¨</button>
            <button type="button" data-inline-action="cancelCommentEdit" data-id="${escapeHTML(cid)}"
              style="padding:8px 12px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;font-weight:bold;">×‘×™×˜×•×œ</button>
          </div>
        </div>
        <div id="edit-comment-err-${escapeHTML(cid)}" style="display:none;margin-top:10px;padding:10px 12px;border-radius:12px;background:rgba(255,0,0,0.08);color:#8a0000;font-size:13px;"></div>
      `;

      commentNode.appendChild(box);

      setTimeout(() => {
        try {
          const ta = document.getElementById("edit-comment-ta-" + cid);
          ta && ta.focus();
        } catch {}
      }, 50);

    } catch {}
  }

  /* =====================================================================================
     Inline edit â€“ REPLY (NEW)
     ===================================================================================== */
  function beginInlineEditReply(commentId, replyId) {
    try {
      const cid = safeText(commentId || "");
      const rid = safeText(replyId || "");
      if (!cid || !rid) return;

      // find reply node
      const repliesBox = document.getElementById("replies-" + cid);
      if (!repliesBox) return;

      // locate reply
      const replyNode = repliesBox.querySelector('.reply[data-reply-id="' + rid + '"]');
      if (!replyNode) return;

      // avoid duplicate editor
      if (replyNode.querySelector(".inline-edit-box")) return;

      // permission: fetch reply once (selective)
      firebase.database()
        .ref("replies/" + postId + "/" + cid + "/" + rid)
        .once("value")
        .then((snap) => {
          if (!snap.exists()) return;

          const d = snap.val() || {};
          const author = safeText(d.author || "");
          const authorUid = safeText(d.authorUid || "");
          const t = Number(d.time || 0);

          if (!canEditItem(author, authorUid, t)) {
            setStatus("××™×Ÿ ×”×¨×©××” ×œ×¢×¨×•×š ×¨×™×¤×œ×™×™ (×¨×§ ×”××—×‘×¨ ×•×¢×“ 24 ×©×¢×•×ª).", "error");
            return;
          }

          const textEl = replyNode.querySelector(".reply-text");
          const oldText = textEl ? safeText(textEl.innerText || "") : safeText(d.text || "");

          const box = document.createElement("div");
          box.className = "inline-edit-box";
          box.innerHTML = `
            <div style="font-weight:bold; margin-bottom:8px;">×¢×¨×™×›×ª ×¨×™×¤×œ×™×™</div>
            <textarea id="edit-reply-ta-${escapeHTML(cid)}-${escapeHTML(rid)}" rows="4" maxlength="600">${escapeHTML(oldText)}</textarea>
            <div style="margin-top:10px; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center;">
              <small style="opacity:.75;">××§×¡×™××•× 600 ×ª×•×•×™×.</small>
              <div style="display:flex; gap:10px;">
                <button type="button" data-inline-action="saveReplyEdit" data-comment-id="${escapeHTML(cid)}" data-reply-id="${escapeHTML(rid)}"
                  style="padding:8px 12px;border-radius:10px;border:none;background:rgb(17,17,87);color:#fff;cursor:pointer;font-weight:bold;">×©××•×¨</button>
                <button type="button" data-inline-action="cancelReplyEdit" data-comment-id="${escapeHTML(cid)}" data-reply-id="${escapeHTML(rid)}"
                  style="padding:8px 12px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;font-weight:bold;">×‘×™×˜×•×œ</button>
              </div>
            </div>
            <div id="edit-reply-err-${escapeHTML(cid)}-${escapeHTML(rid)}" style="display:none;margin-top:10px;padding:10px 12px;border-radius:12px;background:rgba(255,0,0,0.08);color:#8a0000;font-size:13px;"></div>
          `;

          replyNode.appendChild(box);

          setTimeout(() => {
            try {
              const ta = document.getElementById("edit-reply-ta-" + cid + "-" + rid);
              ta && ta.focus();
            } catch {}
          }, 50);

        })
        .catch(() => {});
    } catch {}
  }

  /* =====================================================================================
     Inline edit delegation (comment + reply)
     ===================================================================================== */
  (function bindInlineEditDelegation() {
    if (commentsBox.__inlineEditBound) return;
    commentsBox.__inlineEditBound = true;

    commentsBox.addEventListener("click", function (e) {
      const el = e.target.closest("[data-inline-action]");
      if (!el) return;

      const act = el.getAttribute("data-inline-action");

      if (act === "cancelCommentEdit") {
        const id = el.getAttribute("data-id");
        const node = commentsBox.querySelector('.comment[data-comment-id="' + id + '"]');
        if (!node) return;
        const box = node.querySelector(".inline-edit-box");
        if (box) box.remove();
      }

      if (act === "saveCommentEdit") {
        const id = el.getAttribute("data-id");
        const ta = document.getElementById("edit-comment-ta-" + id);
        const err = document.getElementById("edit-comment-err-" + id);
        if (!ta) return;

        const newText = safeText(ta.value).trim();
        if (newText.length < 1) {
          if (err) { err.style.display = "block"; err.textContent = "×”×˜×§×¡×˜ ×¨×™×§."; }
          return;
        }

        // permission re-check (selective)
        const c = commentsCache.find(x => x.id === id);
        if (!c || !canEditItem(c.author, c.authorUid, c.time)) {
          setStatus("××™×Ÿ ×”×¨×©××” ×œ×¢×¨×•×š ×ª×’×•×‘×”.", "error");
          return;
        }

        setStatus("×©×•××¨ ×¢×¨×™×›×ª ×ª×’×•×‘×”â€¦", "info");

        firebase.database()
          .ref("comments/" + postId + "/" + id)
          .update({ text: clampTextLen(newText, 800) })
          .then(() => {
            setStatus("×”×ª×’×•×‘×” ×¢×•×“×›× ×”.", "ok");
            // local cache update
            const idx = commentsCache.findIndex(x => x.id === id);
            if (idx !== -1) commentsCache[idx].text = clampTextLen(newText, 800);
            renderCommentsFromCache();
          })
          .catch(() => {
            if (err) { err.style.display = "block"; err.textContent = "×©×’×™××” ×‘×©××™×¨×”. × ×¡×” ×©×•×‘."; }
            setStatus("×©×’×™××” ×‘×©××™×¨×”.", "error");
          });
      }

      if (act === "cancelReplyEdit") {
        const cid = el.getAttribute("data-comment-id");
        const rid = el.getAttribute("data-reply-id");
        const box = commentsBox.querySelector('.reply[data-reply-id="' + rid + '"] .inline-edit-box');
        if (box) box.remove();
      }

      if (act === "saveReplyEdit") {
        const cid = el.getAttribute("data-comment-id");
        const rid = el.getAttribute("data-reply-id");
        const ta = document.getElementById("edit-reply-ta-" + cid + "-" + rid);
        const err = document.getElementById("edit-reply-err-" + cid + "-" + rid);
        if (!ta) return;

        const newText = safeText(ta.value).trim();
        if (newText.length < 1) {
          if (err) { err.style.display = "block"; err.textContent = "×”×˜×§×¡×˜ ×¨×™×§."; }
          return;
        }

        setStatus("×©×•××¨ ×¢×¨×™×›×ª ×¨×™×¤×œ×™×™â€¦", "info");

        // permission re-check by read (selective)
        firebase.database()
          .ref("replies/" + postId + "/" + cid + "/" + rid)
          .once("value")
          .then((snap) => {
            if (!snap.exists()) throw new Error("missing");
            const d = snap.val() || {};
            if (!canEditItem(d.author, d.authorUid, d.time)) throw new Error("no_perm");

            return firebase.database()
              .ref("replies/" + postId + "/" + cid + "/" + rid)
              .update({ text: clampTextLen(newText, 600) });
          })
          .then(() => {
            setStatus("×”×¨×™×¤×œ×™×™ ×¢×•×“×›×Ÿ.", "ok");
            // refresh replies box gently
            if (repliesOpenState[cid]) {
              toggleReplies(cid);
              setTimeout(() => toggleReplies(cid), 50);
            }
          })
          .catch(() => {
            if (err) { err.style.display = "block"; err.textContent = "×©×’×™××” ×‘×©××™×¨×” ××• ××™×Ÿ ×”×¨×©××”."; }
            setStatus("×©×’×™××” ×‘×©××™×¨×”.", "error");
          });
      }

    }, false);
  })();

  /* =====================================================================================
     Live comments (×©×“×¨×•×’)
     - ×ª×•××š ×’× ×‘×ª××•× ×” ×œ×©×™× ×•×™×™×/×”×•×¡×¤×•×ª
     ===================================================================================== */
  function attachLiveComments() {
    if (liveCommentsAttached) return;
    liveCommentsAttached = true;

    liveCommentsRef = firebase.database()
      .ref("comments/" + postId)
      .orderByChild("time")
      .limitToLast(50);

    liveCommentsRef.on("child_added", (snap) => {
      const id = snap.key;
      const v = snap.val() || {};

      if (commentsCache.some((x) => x.id === id)) return;

      commentsCache.push({
        id,
        text: safeText(v.text),
        author: safeText(v.author),
        authorUid: safeText(v.authorUid || ""),
        time: Number(v.time || 0),
        image: sanitizeImageUrl(v.image || "")
      });

      renderCommentsFromCache();
    });

    liveCommentsRef.on("child_changed", (snap) => {
      const id = snap.key;
      const v = snap.val() || {};

      const idx = commentsCache.findIndex((x) => x.id === id);
      if (idx === -1) return;

      commentsCache[idx] = {
        ...commentsCache[idx],
        text: safeText(v.text),
        author: safeText(v.author),
        authorUid: safeText(v.authorUid || commentsCache[idx].authorUid || ""),
        time: Number(v.time || commentsCache[idx].time || 0),
        image: sanitizeImageUrl(v.image || commentsCache[idx].image || "")
      };

      renderCommentsFromCache();
    });
  }

  /* =====================================================================================
     Live replies (×¨×§ ×›×©×”×ª×™×‘×” ×¤×ª×•×—×”)
     + bind reply image input on open
     ===================================================================================== */
  function attachRepliesLive(commentId) {
    if (repliesLiveAttached[commentId]) return;
    repliesLiveAttached[commentId] = true;

    // ensure reply image input is bound for this open box
    bindReplyImageInput(commentId);

    const ref = firebase.database()
      .ref("replies/" + postId + "/" + commentId)
      .orderByChild("time")
      .limitToLast(25);

    repliesLiveRefs[commentId] = ref;

    ref.on("child_added", (snap) => {
      if (!repliesOpenState[commentId]) return;

      updateReplyCount(commentId);

      const box = document.getElementById("replies-" + commentId);
      if (!box) return;

      const active = document.activeElement;
      const isTypingHere = active && active.id === ("reply-textarea-" + commentId);
      if (isTypingHere) return;

      try {
        box.classList.add("hidden");
        repliesOpenState[commentId] = false;
        toggleReplies(commentId);
      } catch {}
    });
  }

  function detachRepliesLive(commentId) {
    try {
      const ref = repliesLiveRefs[commentId];
      if (ref) ref.off();
    } catch {}
    repliesLiveRefs[commentId] = null;
    repliesLiveAttached[commentId] = false;
  }

  /* =====================================================================================
     DISABLED: Report comment / reply (per request)
     - kept as code (length) but not used
     ===================================================================================== */
  function reportComment(commentId) {
    // DISABLED
    // if (!isAuthed || !uid) { setStatus("×œ× ×××•××ª. ×œ× × ×™×ª×Ÿ ×œ×“×•×•×—.", "error"); return; }
    // firebase.database().ref("reports").push({ type:"comment", postId, commentId, reporterUid:uid, reporterName:username, time:nowTs(), reason:"report" })
    //   .then(() => setStatus("×“×•×•×— ×‘×”×¦×œ×—×”.", "ok"))
    //   .catch(() => setStatus("×©×’×™××” ×‘×“×™×•×•×—.", "error"));
  }

  function reportReply(commentId, replyId) {
    // DISABLED
    // if (!isAuthed || !uid) { setStatus("×œ× ×××•××ª. ×œ× × ×™×ª×Ÿ ×œ×“×•×•×—.", "error"); return; }
    // firebase.database().ref("reports").push({ type:"reply", postId, commentId, replyId, reporterUid:uid, reporterName:username, time:nowTs(), reason:"report" })
    //   .then(() => setStatus("×“×•×•×— ×‘×”×¦×œ×—×”.", "ok"))
    //   .catch(() => setStatus("×©×’×™××” ×‘×“×™×•×•×—.", "error"));
  }

  /* =====================================================================================
     Cleanup on unload (×©×“×¨×•×’ ×™×¦×™×‘×•×ª)
     ===================================================================================== */
  window.addEventListener("beforeunload", () => {
    try {
      if (liveCommentsRef) liveCommentsRef.off();
    } catch {}
    liveCommentsAttached = false;

    for (const k in repliesLiveRefs) {
      try {
        if (repliesLiveRefs[k]) repliesLiveRefs[k].off();
      } catch {}
    }
  });

});
</script>

</body>
</html>