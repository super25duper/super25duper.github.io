<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>×¦×¤×™×™×” ×‘×¤×•×¡×˜</title>

  <!-- =====================================================================================
       ğŸš« ×—×¡×™××” ××™×™×“×™×ª ×œ×“×¤×“×¤×Ÿ ×¨×’×™×œ (××‘×˜×—×”: ×œ× ××©× ×™× ×©×™×˜×”)
       1) ×—×™×™×‘ WebView (AppInventor)
       2) ×—×™×™×‘ getWebViewString ×¤×•× ×§×¦×™×”
       ×× ×œ× => forbidden.html
       ===================================================================================== -->
  <script>
    (function () {
      try {
        if (!window.AppInventor || typeof window.AppInventor.getWebViewString !== "function") {
          location.replace("forbidden.html");
        }
      } catch (e) {
        location.replace("forbidden.html");
      }
    })();
  </script>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <script src="firebaseConfig.js"></script>

  <!-- CSS -->
  <link rel="stylesheet" href="css/forum.css" />
  <link rel="stylesheet" href="css/post.css" />

  <style>
    /* =====================================================================================
       SELECTIVE ADDITIONS (UI ×‘×œ×‘×“) â€“ ×œ× ××—×œ×™×£ CSS ×§×™×™×
       ===================================================================================== */

    .post-user-border {
      border-right: 4px solid rgba(0,0,0,0.15);
      padding-right: 12px;
      box-sizing: border-box;
    }

    .post-image-wrap {
      margin-top: 12px;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(0,0,0,0.03);
    }

    .post-image {
      width: 100%;
      height: auto;
      display: block;
      max-height: 380px;
      object-fit: cover;
      background: #fff;
      cursor: pointer;
    }

    .mini-image {
      width: 100%;
      height: auto;
      display: block;
      max-height: 180px;
      object-fit: cover;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.12);
      background: #fff;
      cursor: pointer;
      margin-top: 10px;
    }

    .img-actions-row {
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      margin-top: 10px;
    }

    .img-btn {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.18);
      background: #fff;
      cursor: pointer;
      font-weight: bold;
    }

    .img-btn-primary {
      border: none;
      background: rgb(17,17,87);
      color: #fff;
    }

    .img-btn-danger {
      border: 1px solid rgba(255,0,0,0.35);
      background: rgba(255,0,0,0.06);
      color: #8a0000;
    }

    .img-preview {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.12);
      overflow: hidden;
      background: rgba(0,0,0,0.03);
      margin-top: 10px;
    }

    .img-preview img {
      width: 100%;
      height: auto;
      display: block;
      max-height: 220px;
      object-fit: cover;
      background: #fff;
    }

    /* Viewer overlay (×—×œ×•×Ÿ ×§×˜×Ÿ ×¢× ××™×§×¡) */
    #miniViewerOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.72);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      box-sizing: border-box;
      z-index: 10000;
    }
    #miniViewerBox {
      width: min(820px, 100%);
      background: rgba(255,255,255,0.97);
      border-radius: 16px;
      padding: 12px;
      box-sizing: border-box;
      border: 1px solid rgba(0,0,0,0.12);
    }
    #miniViewerTop {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    #miniViewerClose {
      border: none;
      background: transparent;
      font-size: 18px;
      cursor: pointer;
      padding: 8px 10px;
      border-radius: 10px;
    }
    #miniViewerImg {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 14px;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.12);
      max-height: 78vh;
      object-fit: contain;
    }

    /* Edit post overlay */
    #editPostOverlay {
      position:fixed;
      inset:0;
      background: rgba(0,0,0,0.45);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      box-sizing:border-box;
      z-index:9999;
    }
    #editPostModal {
      width:min(740px, 100%);
      background:#fff;
      border-radius:16px;
      padding:16px;
      box-sizing:border-box;
    }

    /* Inline edit (comment/reply) */
    .inline-edit-box {
      margin-top: 8px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(0,0,0,0.02);
    }
    .inline-edit-box textarea {
      width:100%;
      box-sizing:border-box;
      padding:10px 12px;
      border-radius:10px;
      border:1px solid rgba(0,0,0,0.15);
      outline:none;
      resize:vertical;
    }
  </style>
</head>

<body>

<header class="top-bar">
  <h1>×¦×¤×™×™×” ×‘×¤×•×¡×˜</h1>
</header>

<main class="forum-container">

  <!-- =====================================================================================
       POST HEADER AREA
       ===================================================================================== -->
  <div id="post"></div>

  <!-- =====================================================================================
       STATUS BAR (UX ×©×“×¨×•×’ - ×œ× ×¤×•×’×¢ ×‘××‘×˜×—×”)
       ===================================================================================== -->
  <div id="statusBar" style="
    display:none;
    margin: 10px 0 14px 0;
    padding:10px 12px;
    border-radius:12px;
    background: rgba(0,0,0,0.05);
    color:#111;
    font-size:13px;
  "></div>

  <!-- =====================================================================================
       MAIN COMMENT COMPOSER
       ===================================================================================== -->
  <div id="mainComposer" class="composer hidden">
    <textarea id="mainText" placeholder="×›×ª×•×‘ ×ª×’×•×‘×”..."></textarea>

    <!-- =====================================================================================
         COMMENT IMAGE (NEW) â€“ ×ª××•× ×” ×œ×ª×’×•×‘×” (××•×¤×¦×™×•× ×œ×™)
         ===================================================================================== -->
    <div id="mainCommentImageBlock" style="
      margin-top:10px;
      border:1px solid rgba(0,0,0,0.10);
      border-radius:14px;
      padding:12px;
      background: rgba(0,0,0,0.02);
    ">
      <div class="img-actions-row">
        <div style="display:flex; flex-direction:column; gap:4px;">
          <div style="font-weight:bold;">×ª××•× ×” ×œ×ª×’×•×‘×” (××•×¤×¦×™×•× ×œ×™)</div>
          <div id="mainCommentImageMeta" style="font-size:12px; opacity:.75;">
            ×¤×•×¨××˜×™× × ×ª××›×™×: JPG/PNG/WebP. ××•××œ×¥ ×¢×“ 9MB.
          </div>
        </div>

        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button id="chooseMainCommentImageBtn" type="button" class="img-btn img-btn-primary">×‘×—×¨ ×ª××•× ×”</button>
          <button id="removeMainCommentImageBtn" type="button" class="img-btn img-btn-danger" style="display:none;">×”×¡×¨ ×ª××•× ×”</button>
        </div>
      </div>

      <input id="mainCommentImage" type="file" accept="image/*" style="display:none;" />

      <div id="mainCommentPreviewWrap" style="display:none;">
        <div class="img-preview">
          <img id="mainCommentPreviewImg" alt="×ª×¦×•×’×” ××§×“×™××”" src="" />
        </div>
      </div>
    </div>

    <div class="composer-actions">
      <button type="button" id="sendMainBtn">×©×œ×—</button>
      <button type="button" id="closeMainBtn">×‘×™×˜×•×œ</button>
    </div>

    <!-- extra UX (×©×“×¨×•×’) -->
    <div id="mainComposerHint" style="
      margin-top:8px;
      font-size:12px;
      opacity:0.75;
      line-height:1.5;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    ">
      <span>×˜×™×¤: ×ª×’×•×‘×” ×˜×•×‘×” ×”×™× ×§×¦×¨×”, ×‘×¨×•×¨×”, ×•××›×‘×“×ª.</span>
      <span id="mainCharCount">0/800</span>
    </div>
  </div>

  <!-- =====================================================================================
       OPEN MAIN COMPOSER BUTTON
       ===================================================================================== -->
  <button id="openMain" class="add-comment-btn" type="button">
    ×”×•×¡×£ ×ª×’×•×‘×”
  </button>

  <!-- =====================================================================================
       COMMENTS
       ===================================================================================== -->
  <section class="comments">
    <h3>×ª×’×•×‘×•×ª</h3>

    <!-- search inside comments (×©×“×¨×•×’, ×œ× ××‘×˜×œ ×›×œ×•×) -->
    <div style="
      display:flex;
      gap:10px;
      align-items:center;
      margin: 10px 0 12px 0;
      flex-wrap:wrap;
    ">
      <input id="commentSearch" type="search" placeholder="×—×™×¤×•×© ×‘×ª×’×•×‘×•×ª..."
        style="
          flex:1;
          min-width:180px;
          padding:10px 12px;
          border-radius:10px;
          border:1px solid rgba(0,0,0,0.15);
          outline:none;
          box-sizing:border-box;
        "
      />
      <select id="commentSort" style="
        padding:10px 12px;
        border-radius:10px;
        border:1px solid rgba(0,0,0,0.15);
        outline:none;
        background:#fff;
        cursor:pointer;
      ">
        <option value="newest">××™×•×Ÿ: ×”×—×“×©×•×ª ×œ××¢×œ×”</option>
        <option value="oldest">××™×•×Ÿ: ×”×™×©× ×•×ª ×œ××¢×œ×”</option>
        <option value="author">××™×•×Ÿ: ×œ×¤×™ ××—×‘×¨</option>
      </select>
    </div>

    <div id="comments">
      <div class="loader"></div>
    </div>

    <!-- load more (×©×“×¨×•×’ - ××•×¤×¦×™×•× ×œ×™) -->
    <div id="commentsFooter" style="
      margin-top:14px;
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
    ">
      <button id="loadMoreComments" type="button" style="
        display:none;
        padding:10px 14px;
        border-radius:12px;
        border:1px solid rgba(0,0,0,0.15);
        background:#fff;
        cursor:pointer;
        font-weight:bold;
      ">×˜×¢×Ÿ ×¢×•×“ ×ª×’×•×‘×•×ª</button>
    </div>
  </section>

</main>

<!-- =====================================================================================
     MINI VIEWER OVERLAY (×ª×¦×•×’×” ××§×“×™××” ×¢× ××™×§×¡) â€“ ×œ×¤×•×¡×˜/×ª×’×•×‘×•×ª/×¨×™×¤×œ×™×™×–
     ===================================================================================== -->
<div id="miniViewerOverlay">
  <div id="miniViewerBox">
    <div id="miniViewerTop">
      <div style="font-weight:bold;">×ª××•× ×”</div>
      <button id="miniViewerClose" type="button">âœ•</button>
    </div>
    <img id="miniViewerImg" alt="×ª××•× ×”" src="" />
    <div style="margin-top:10px; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center;">
      <span style="font-size:12px; opacity:.75;">×œ×—×¥ ××—×•×¥ ×œ×ª×™×‘×” ×›×“×™ ×œ×¡×’×•×¨</span>
      <span id="miniViewerHint" style="font-size:12px; opacity:.75;"></span>
    </div>
  </div>
</div>

<!-- =====================================================================================
     EDIT POST OVERLAY (×¢×“ 24 ×©×¢×•×ª, ×¨×§ ×”××—×‘×¨)
     ===================================================================================== -->
<div id="editPostOverlay">
  <div id="editPostModal">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
      <div style="font-weight:bold; font-size:18px;">×¢×¨×™×›×ª ×¤×•×¡×˜</div>
      <button id="closeEditPostBtn" type="button" style="border:none;background:transparent;font-size:18px;cursor:pointer;">âœ•</button>
    </div>

    <div style="margin-top:12px; display:flex; flex-direction:column; gap:10px;">
      <input id="editPostTitle" type="text" placeholder="×›×•×ª×¨×ª"
        maxlength="80"
        style="
          padding:12px;
          border-radius:12px;
          border:1px solid rgba(0,0,0,0.18);
          outline:none;
          box-sizing:border-box;
        "
      />
      <textarea id="editPostText" placeholder="×ª×•×›×Ÿ ×”×¤×•×¡×˜..."
        rows="7"
        maxlength="2000"
        style="
          padding:12px;
          border-radius:12px;
          border:1px solid rgba(0,0,0,0.18);
          outline:none;
          box-sizing:border-box;
          resize:vertical;
        "
      ></textarea>

      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
        <div id="editPostHint" style="font-size:12px; color:#444;">
          × ×™×ª×Ÿ ×œ×¢×¨×•×š ×¤×•×¡×˜ ×¢×“ 24 ×©×¢×•×ª ××¨×’×¢ ×”×¤×¨×¡×•×.
        </div>
        <div style="display:flex; gap:10px;">
          <button id="saveEditPostBtn" type="button" style="
            padding:10px 14px;
            border-radius:12px;
            border:none;
            background: rgb(17,17,87);
            color:#fff;
            cursor:pointer;
            font-weight:bold;
          ">×©××•×¨</button>
          <button id="cancelEditPostBtn" type="button" style="
            padding:10px 14px;
            border-radius:12px;
            border:1px solid rgba(0,0,0,0.18);
            background:#fff;
            cursor:pointer;
            font-weight:bold;
          ">×‘×™×˜×•×œ</button>
        </div>
      </div>

      <div id="editPostError" style="
        display:none;
        padding:10px 12px;
        border-radius:12px;
        background: rgba(255,0,0,0.08);
        color:#8a0000;
        font-size:13px;
      "></div>
    </div>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
<script>
/* =========================================================================================
   âš ï¸ ××‘×˜×—×” â€“ ×©×™×˜×” ×œ× ××©×ª× ×”:
   1) ×—×¡×™××” ××™×™×“×™×ª ×‘×“×¤×“×¤×Ÿ ×¨×’×™×œ (AppInventor + getWebViewString)
   2) payload ××§×•×“×•×œ×¨ (email/password/token)
   3) Firebase Auth signInWithEmailAndPassword
   4) ××™××•×ª token ××•×œ sessions/{uid}/token
   ×¨×§ ××—×¨×™ ×–×”: ×©×œ×™×¤×•×ª DB + ×›×ª×™×‘×•×ª ×ª×’×•×‘×”/×ª×’×•×‘×”-×¢×œ-×ª×’×•×‘×” + ×¢×¨×™×›×•×ª
   ========================================================================================= */

/* ===============================
   Helpers
   =============================== */
function escapeHTML(str = "") {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function safeText(str = "") {
  return String(str || "");
}

function userColor(key) {
  const colors = [
    "#60a5fa",
    "#34d399",
    "#f472b6",
    "#fbbf24",
    "#a78bfa",
    "#fb7185",
    "#22d3ee"
  ];
  let hash = 0;
  const s = String(key || "");
  for (let i = 0; i < s.length; i++) {
    hash = s.charCodeAt(i) + ((hash << 5) - hash);
  }
  return colors[Math.abs(hash) % colors.length];
}

function fmtTime(ts) {
  try {
    return new Date(ts).toLocaleTimeString("he-IL", {
      hour: "2-digit",
      minute: "2-digit"
    });
  } catch {
    return "";
  }
}

function fmtDateTime(ts) {
  try {
    return new Date(ts).toLocaleString("he-IL", {
      day: "2-digit",
      month: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    });
  } catch {
    return "";
  }
}

function setStatus(msg, type = "info") {
  const bar = document.getElementById("statusBar");
  if (!bar) return;

  if (!msg) {
    bar.style.display = "none";
    bar.textContent = "";
    return;
  }

  bar.style.display = "block";
  bar.textContent = msg;

  if (type === "error") {
    bar.style.background = "rgba(255,0,0,0.08)";
    bar.style.color = "#8a0000";
  } else if (type === "ok") {
    bar.style.background = "rgba(0,128,0,0.08)";
    bar.style.color = "#0b5a0b";
  } else if (type === "warn") {
    bar.style.background = "rgba(255,165,0,0.10)";
    bar.style.color = "#7a4b00";
  } else {
    bar.style.background = "rgba(0,0,0,0.05)";
    bar.style.color = "#111";
  }
}

function debounce(fn, ms) {
  let t = null;
  return function (...args) {
    clearTimeout(t);
    t = setTimeout(() => fn.apply(this, args), ms);
  };
}

function clampTextLen(s, maxLen) {
  const x = safeText(s);
  if (x.length <= maxLen) return x;
  return x.slice(0, maxLen);
}

function nowTs() {
  return Date.now();
}

function sanitizeImageUrl(url) {
  if (url === undefined || url === null) return "";
  const u = safeText(url).trim();
  if (!u) return "";
  if (u.startsWith("https://") || u.startsWith("http://")) return u;
  return "";
}

function bytesToHuman(n) {
  try {
    const x = Number(n || 0);
    if (!x) return "0B";
    if (x < 1024) return x + "B";
    if (x < 1024 * 1024) return Math.round(x / 1024) + "KB";
    return (Math.round((x / (1024 * 1024)) * 10) / 10) + "MB";
  } catch (e) {
    return "";
  }
}
/* =========================================================================================
   SECURE IMAGES (SIGNED URL) â€” ×›××• ×‘×“×£ ×”×¤×•×¨×•×
   ========================================================================================= */

// ××•×ª×• endpoint ×‘×“×™×•×§ ×›××• ×‘×¤×•×¨×•× (×ª×©××™×¨ ××•×ª×• ×–×”×”!)
const GET_IMAGE_URL_ENDPOINT = "https://us-central1-bigone-86490.cloudfunctions.net/getImageUrl";


// Cache ×‘×–×™×›×¨×•×Ÿ ×›×“×™ ×œ× ×œ×§×¨×•× ×œ×¤×•× ×§×¦×™×” ×©×•×‘ ×•×©×•×‘
const signedUrlCache = Object.create(null); // path => { url, expTs }

/** ×× ×¡×” ×œ×—×œ×¥ URL ×•×ª×•×§×£ ××”×ª×’×•×‘×” */
function _extractSignedUrlFromPayload(data) {
  try {
    if (!data) return { url: "", expSeconds: 0 };

    if (typeof data === "string") {
      return { url: data, expSeconds: 60 };
    }

    const url = safeText(data.url || data.signedUrl || data.downloadUrl || "");
    const exp = Number(data.expiresIn || data.expires_in || data.exp || 0) || 0;

    return { url, expSeconds: exp };
  } catch {
    return { url: "", expSeconds: 0 };
  }
}

function getCachedSignedUrlForPath(path) {
  try {
    const p = safeText(path || "");
    if (!p) return "";
    const rec = signedUrlCache[p];
    if (!rec || !rec.url) return "";
    // ×× ×¤×’ ×ª×•×§×£ - ××•×—×§×™×
    if (rec.expTs && Date.now() > rec.expTs) {
      delete signedUrlCache[p];
      return "";
    }
    return rec.url;
  } catch {
    return "";
  }
}

function setCachedSignedUrlForPath(path, url, expSeconds) {
  try {
    const p = safeText(path || "");
    const u = safeText(url || "");
    if (!p || !u) return;
    const exp = Number(expSeconds || 0) || 0;
    // × ×©××•×¨ ××¢×˜ ×¤×—×•×ª ××”×ª×•×§×£ ×›×“×™ ×œ×”×™×× ×¢ ×"×¤×’ ×‘×“×™×•×§ ×‘×–××Ÿ"
    const expTs = exp ? (Date.now() + Math.max(10, exp - 20) * 1000) : (Date.now() + 40 * 1000);
    signedUrlCache[p] = { url: u, expTs };
  } catch {}
}

function fetchSignedUrlForPath(path) {
  const p = safeText(path || "").trim();
  if (!p) return Promise.resolve("");

  // cache
  const cached = getCachedSignedUrlForPath(p);
  if (cached) return Promise.resolve(cached);

  // ×—×™×™×‘ ×œ×”×™×•×ª ××—×•×‘×¨
  const user = firebase.auth().currentUser;
  if (!user) return Promise.resolve("");

return user.getIdToken(true)
  .then((token) => {
    const url = GET_IMAGE_URL_ENDPOINT + "?path=" + encodeURIComponent(p);
    return fetch(url, {
      method: "GET",
      headers: {
        "Authorization": "Bearer " + token
      }
    });
  })
  .then((res) => res.json())
  .then((data) => {
    const out = _extractSignedUrlFromPayload(data);
    const signed = sanitizeImageUrl(out.url || "");
    if (signed) setCachedSignedUrlForPath(p, signed, out.expSeconds || 0);
    return signed || "";
  })
  .catch(() => "");

}

/** ××¦××™×“ Signed URL ×œ×ª×’×™×ª IMG ×‘×¦×•×¨×” ×œ× ×—×•×¡××ª (×”×“×£ × ×˜×¢×Ÿ, ×”×ª××•× ×” ×ª×•×¤×™×¢ ×›×©××’×™×¢×”) */
function hydrateSignedImg(imgEl) {
  try {
    if (!imgEl) return;

    // ×× ×›×‘×¨ ×™×© src ×—×•×§×™ â€“ ×œ× × ×•×’×¢×™×
    const cur = safeText(imgEl.getAttribute("src") || "");
    if (cur && (cur.startsWith("http://") || cur.startsWith("https://"))) return;

    const path = safeText(imgEl.getAttribute("data-image-path") || "").trim();
    if (!path) return;

    // wrapper ×œ×”×¡×ª×™×¨ ×¢×“ ×©×™×© URL (×›×“×™ ×œ× ×œ×¨××•×ª "×ª××•× ×” ×©×‘×•×¨×”")
    const wrap = imgEl.closest("[data-img-wrap='1']");
    if (wrap) wrap.style.display = "none";

    fetchSignedUrlForPath(path).then((url) => {
      if (!url) return;
      imgEl.setAttribute("src", url);
      // ×”×¦×’ ××—×¨×™ ×©×”×ª×—×œ× ×• ×œ×˜×¢×•×Ÿ
      if (wrap) wrap.style.display = "block";
    });
  } catch {}
}

function hydrateSignedImages(root) {
  try {
    const base = root || document;
    const imgs = base.querySelectorAll("img[data-image-path]");
    for (const img of imgs) hydrateSignedImg(img);
  } catch {}
}

function isLikelyImageFile(file) {
  try {
    if (!file) return false;
    const t = safeText(file.type || "").toLowerCase();
    if (t.startsWith("image/")) return true;
    const n = safeText(file.name || "").toLowerCase();
    if (n.includes(".jpg") || n.includes(".jpeg") || n.includes(".png") || n.includes(".webp")) return true;
    return false;
  } catch (e) {
    return false;
  }
}

function copyToClipboard(text) {
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text);
      return;
    }
  } catch {}
  const ta = document.createElement("textarea");
  ta.value = safeText(text);
  ta.style.position = "fixed";
  ta.style.opacity = "0";
  document.body.appendChild(ta);
  ta.select();
  try { document.execCommand("copy"); } catch {}
  document.body.removeChild(ta);
}

/* =========================================================================================
   MINI VIEWER (×ª×¦×•×’×” ××§×“×™××” ×¢× ××™×§×¡) â€“ ×œ×¤×•×¡×˜/×ª×’×•×‘×•×ª/×¨×™×¤×œ×™×™×–
   ========================================================================================= */
function openMiniViewer(url, hint) {
  const overlay = document.getElementById("miniViewerOverlay");
  const img = document.getElementById("miniViewerImg");
  const closeBtn = document.getElementById("miniViewerClose");
  const hintEl = document.getElementById("miniViewerHint");

  if (!overlay || !img) return;

  const safe = sanitizeImageUrl(url);
  if (!safe) return;

  img.setAttribute("src", safe);
  if (hintEl) hintEl.textContent = safeText(hint || "");
  overlay.style.display = "flex";

  if (closeBtn && !closeBtn.__bound) {
    closeBtn.__bound = true;
    closeBtn.addEventListener("click", function () {
      overlay.style.display = "none";
      img.setAttribute("src", "");
      if (hintEl) hintEl.textContent = "";
    });
  }

  if (!overlay.__bound) {
    overlay.__bound = true;
    overlay.addEventListener("click", function (e) {
      if (e.target === overlay) {
        overlay.style.display = "none";
        img.setAttribute("src", "");
        if (hintEl) hintEl.textContent = "";
      }
    });
  }
}

/* =========================================================================================
   Robust FileReader fallback (×œ× ×—×•×‘×”, ××‘×œ ×’×™×‘×•×™ ×× ObjectURL ×œ× ×–××™×Ÿ)
   - ×–×” ×›××Ÿ ×›×“×™ ×œ×”×§×˜×™×Ÿ "×œ× ×”×¦×œ×—×ª×™ ×œ×§×¨×•× ××ª ×”×ª××•× ×”" ×‘×¤×•×¢×œ.
   ========================================================================================= */
function readFileAsDataURLWithRetry(file, tries, done) {
  try {
    let left = Number(tries || 1);
    if (left < 1) left = 1;

    const attempt = function () {
      try {
        const r = new FileReader();
        r.onerror = function () {
          left--;
          if (left <= 0) { done("", false); return; }
          setTimeout(attempt, 160);
        };
        r.onload = function () {
          const dataUrl = safeText(r.result || "");
          if (!dataUrl || !dataUrl.startsWith("data:")) {
            left--;
            if (left <= 0) { done("", false); return; }
            setTimeout(attempt, 160);
            return;
          }
          done(dataUrl, true);
        };
        r.readAsDataURL(file);
      } catch (e1) {
        left--;
        if (left <= 0) { done("", false); return; }
        setTimeout(attempt, 160);
      }
    };

    attempt();
  } catch (e0) {
    done("", false);
  }
}

(function showCachedPostIfExists() {
  const cachedPost = sessionStorage.getItem("currentPost");
  if (!cachedPost) return;

  try {
    const p = JSON.parse(cachedPost);
    const host = document.getElementById("post");
    if (!host) return;

    const author = safeText(p.author || "");
    const border = userColor(author);

    // ×‘×¤×•×¨×•× × ×©××¨×™× ×‘×“"×›: imagePath + imageUrl
    const imageUrl = sanitizeImageUrl(p.imageUrl || p.image || "");
    const imagePath = safeText(p.imagePath || "");

    host.innerHTML = `
      <div class="post post-user-border" style="border-right-color:${escapeHTML(border)};">
        <h3>${escapeHTML(p.title || "")}</h3>
        <p>${escapeHTML(p.text || "")}</p>
        <small style="display:block; margin-top:6px;">×××ª: ${escapeHTML(author)}</small>

        ${(imageUrl || imagePath) ? `
          <div class="post-image-wrap" data-img-wrap="1" style="display:${(imageUrl ? "block" : "none")};">
            <img class="post-image js-open-viewer"
                 data-hint="×ª××•× ×ª ×”×¤×•×¡×˜"
                 ${imagePath ? `data-image-path="${escapeHTML(imagePath)}"` : ``}
                 ${imageUrl ? `src="${escapeHTML(imageUrl)}"` : ``}
                 alt="×ª××•× ×”" />
          </div>
        ` : ``}
      </div>
    `;

    // ×œ× ×—×•×¡×: ×× ×™×© imagePath, ×™×‘×™× signed URL ×•×™×¦×™×’ ×›×©××•×›×Ÿ
    hydrateSignedImages(host);

  } catch (e) {
    sessionStorage.removeItem("currentPost");
  }
})();

/* =========================================================================================
   Main
   ========================================================================================= */
document.addEventListener("DOMContentLoaded", function () {

  /* ===============================
     DOM Elements
     =============================== */
  const postContainer = document.getElementById("post");
  const commentsBox = document.getElementById("comments");

  const openMainBtn = document.getElementById("openMain");
  const mainComposer = document.getElementById("mainComposer");
  const mainText = document.getElementById("mainText");
  const sendMainBtn = document.getElementById("sendMainBtn");
  const closeMainBtn = document.getElementById("closeMainBtn");
  const mainCharCount = document.getElementById("mainCharCount");

  const commentSearch = document.getElementById("commentSearch");
  const commentSort = document.getElementById("commentSort");
  const loadMoreCommentsBtn = document.getElementById("loadMoreComments");

  /* ===============================
     Comment image UI (NEW)
     =============================== */
  const mainCommentImageInput = document.getElementById("mainCommentImage");
  const chooseMainCommentImageBtn = document.getElementById("chooseMainCommentImageBtn");
  const removeMainCommentImageBtn = document.getElementById("removeMainCommentImageBtn");
  const mainCommentPreviewWrap = document.getElementById("mainCommentPreviewWrap");
  const mainCommentPreviewImg = document.getElementById("mainCommentPreviewImg");
  const mainCommentImageMeta = document.getElementById("mainCommentImageMeta");

  /* ===============================
     Edit post UI (NEW)
     =============================== */
  const editPostOverlay = document.getElementById("editPostOverlay");
  const closeEditPostBtn = document.getElementById("closeEditPostBtn");
  const cancelEditPostBtn = document.getElementById("cancelEditPostBtn");
  const saveEditPostBtn = document.getElementById("saveEditPostBtn");
  const editPostTitle = document.getElementById("editPostTitle");
  const editPostText = document.getElementById("editPostText");
  const editPostError = document.getElementById("editPostError");

  /* ===============================
     Guard
     =============================== */
  if (!postContainer || !commentsBox) {
    location.replace("forbidden.html");
    return;
  }

  /* ===============================
     PostId ×—×•×‘×”
     =============================== */
  const postId = new URLSearchParams(location.search).get("postId");
  if (!postId) {
    location.replace("forbidden.html");
    return;
  }

  /* =====================================================================================
     Global State (×œ××¡×š ×¤×•×¡×˜)
     ===================================================================================== */
  let payload = null;
  let uid = null;
  let username = "××©×ª××©";
  let isAuthed = false;

  // current post snapshot (needed for edit rules)
  let currentPostObj = null; // {title,text,author,authorUid,time,image,lastCommentTime,...}
  let canEditPostNow = false;

  // ×× ×™×¢×ª ×“××‘×œ-×©×œ×™×—×•×ª (×ª×’×•×‘×•×ª / replies)
  let mainSending = false;
  const replySendingMap = Object.create(null);

  // Comments cache (×œ××™×•×Ÿ/×—×™×¤×•×© ×‘×œ×™ ×œ×©×‘×•×¨ ×©×•× ×“×‘×¨)
  let commentsCache = [];
  let commentsRenderedHtml = "";
  let commentsLimit = 200;          // ×©×•××¨ ×›××• ×©×”×™×”
  let commentsPagingStep = 200;     // ×©×“×¨×•×’: "×˜×¢×Ÿ ×¢×•×“"
  let canLoadMore = false;

  // Live listeners (×©×“×¨×•×’)
  let liveCommentsRef = null;
  let liveCommentsAttached = false;

  // Replies UI cache
  const repliesOpenState = Object.create(null);          // id => boolean
  const repliesLiveRefs = Object.create(null);           // id => firebase ref
  const repliesLiveAttached = Object.create(null);       // id => boolean

  // Payload wait hard limit (××•× ×¢ "×˜×¢×™× ×” ××™× ×¡×•×¤×™×ª" ×‘-WebView ×ª×§×•×œ)
  const PAYLOAD_MAX_MS = 12000; // 12s
  const PAYLOAD_POLL_MS = 200;
  const payloadStartAt = nowTs();

  /* =====================================================================================
     Image state (comment + reply)
     - Strategy: preview via ObjectURL (×›××¢×˜ ×‘×œ×™ ×©×’×™××•×ª)
       upload via storage.put(file) (×œ×œ× FileReader)
       fallback: putString(data_url) ×¨×§ ×× ×¦×¨×™×š
     ===================================================================================== */
  const MAX_IMG = 9 * 1024 * 1024; // 9MB

  let mainCommentImageFile = null;
  let mainCommentPreviewUrl = "";
  let mainCommentPreviewCanRevoke = false;

  function clearMainCommentImage(resetInput) {
    try {
      if (mainCommentPreviewUrl && mainCommentPreviewCanRevoke) {
        try { URL.revokeObjectURL(mainCommentPreviewUrl); } catch {}
      }
    } catch {}
    mainCommentImageFile = null;
    mainCommentPreviewUrl = "";
    mainCommentPreviewCanRevoke = false;

    try {
      if (mainCommentPreviewImg) mainCommentPreviewImg.setAttribute("src", "");
      if (mainCommentPreviewWrap) mainCommentPreviewWrap.style.display = "none";
      if (removeMainCommentImageBtn) removeMainCommentImageBtn.style.display = "none";
      if (resetInput && mainCommentImageInput) mainCommentImageInput.value = "";
      if (mainCommentImageMeta) mainCommentImageMeta.textContent = "×¤×•×¨××˜×™× × ×ª××›×™×: JPG/PNG/WebP. ××•××œ×¥ ×¢×“ 9MB.";
    } catch {}
  }

  if (chooseMainCommentImageBtn && mainCommentImageInput) {
    chooseMainCommentImageBtn.addEventListener("click", function () {
      try {
        mainCommentImageInput.value = "";
        mainCommentImageInput.click();
      } catch {}
    });
  }

  if (removeMainCommentImageBtn) {
    removeMainCommentImageBtn.addEventListener("click", function () {
      clearMainCommentImage(true);
    });
  }

  if (mainCommentImageInput) {
    mainCommentImageInput.addEventListener("change", function () {
      try {
        const f = (mainCommentImageInput.files && mainCommentImageInput.files[0]) ? mainCommentImageInput.files[0] : null;
        if (!f) return;

        if (!isLikelyImageFile(f)) {
          setStatus("×§×•×‘×¥ ×œ× × ×ª××š. ×‘×—×¨ ×ª××•× ×” (JPG/PNG/WebP).", "error");
          clearMainCommentImage(true);
          return;
        }

        if (Number(f.size || 0) > MAX_IMG) {
          setStatus("×”×ª××•× ×” ×’×“×•×œ×” ××“×™ (" + bytesToHuman(f.size) + "). ×¢×“ 9MB.", "error");
          clearMainCommentImage(true);
          return;
        }

        mainCommentImageFile = f;

        // preview with ObjectURL (preferred)
        try {
          if (mainCommentPreviewUrl && mainCommentPreviewCanRevoke) {
            try { URL.revokeObjectURL(mainCommentPreviewUrl); } catch {}
          }
        } catch {}

        mainCommentPreviewUrl = "";
        mainCommentPreviewCanRevoke = false;

        try {
          if (mainCommentImageMeta) mainCommentImageMeta.textContent = "× ×‘×—×¨×” ×ª××•× ×”: " + safeText(f.name) + " (" + bytesToHuman(f.size) + ")";
        } catch {}

        let previewSet = false;
        try {
          if (window.URL && typeof URL.createObjectURL === "function") {
            const u = URL.createObjectURL(f);
            mainCommentPreviewUrl = u;
            mainCommentPreviewCanRevoke = true;
            if (mainCommentPreviewImg) mainCommentPreviewImg.setAttribute("src", u);
            if (mainCommentPreviewWrap) mainCommentPreviewWrap.style.display = "block";
            if (removeMainCommentImageBtn) removeMainCommentImageBtn.style.display = "inline-block";
            previewSet = true;
          }
        } catch {}

        // fallback to FileReader quietly (no noisy errors)
        if (!previewSet) {
          readFileAsDataURLWithRetry(f, 3, function (durl, ok) {
            if (!ok) {
              // ×œ× ××¦×™×’×™× "×œ× ×”×¦×œ×—×ª×™ ×œ×§×¨×•×" ××’×¨×¡×™×‘×™ â€“ ×¨×§ ×¡×˜×˜×•×¡ ×¢×“×™×Ÿ
              setStatus("×œ× ×”×¦×œ×—×ª×™ ×œ×”×¦×™×’ ×ª×¦×•×’×” ××§×“×™××”, ××‘×œ ×× ×¡×” ×œ×”×¢×œ×•×ª ×›×¨×’×™×œ.", "warn");
              return;
            }
            mainCommentPreviewUrl = durl;
            mainCommentPreviewCanRevoke = false;
            if (mainCommentPreviewImg) mainCommentPreviewImg.setAttribute("src", durl);
            if (mainCommentPreviewWrap) mainCommentPreviewWrap.style.display = "block";
            if (removeMainCommentImageBtn) removeMainCommentImageBtn.style.display = "inline-block";
          });
        }
      } catch {}
    });
  }

  /* =====================================================================================
     Composer UX: ×¡×¤×™×¨×ª ×ª×•×•×™× (×©×“×¨×•×’)
     ===================================================================================== */
  const MAIN_MAX = 800;
  if (mainText && mainCharCount) {
    const updateCount = () => {
      const len = safeText(mainText.value).length;
      mainCharCount.textContent = `${len}/${MAIN_MAX}`;
    };
    mainText.addEventListener("input", updateCount);
    updateCount();
  }

  /* =====================================================================================
     Bind composer buttons (feature × ×©××¨)
     ===================================================================================== */
  openMainBtn.addEventListener("click", openMain);
  closeMainBtn.addEventListener("click", closeMain);
  sendMainBtn.addEventListener("click", sendMain);

  function openMain() {
    mainComposer.classList.remove("hidden");
    openMainBtn.style.display = "none";

    setTimeout(() => {
      try { mainText.focus(); } catch {}
      try {
        mainComposer.scrollIntoView({ behavior: "smooth", block: "center" });
      } catch {}
    }, 50);
  }

  function closeMain() {
    mainComposer.classList.add("hidden");
    openMainBtn.style.display = "block";
    mainText.value = "";
    if (mainCharCount) mainCharCount.textContent = `0/${MAIN_MAX}`;

    // reset image
    clearMainCommentImage(true);
  }

  /* =====================================================================================
     Search + Sort for comments (×©×“×¨×•×’ - ×œ× ××‘×˜×œ ×¤×™×¦'×¨)
     ===================================================================================== */
  if (commentSearch) {
    commentSearch.addEventListener("input", debounce(() => {
      renderCommentsFromCache();
    }, 120));
  }

  if (commentSort) {
    commentSort.addEventListener("change", () => {
      renderCommentsFromCache();
    });
  }

  if (loadMoreCommentsBtn) {
    loadMoreCommentsBtn.addEventListener("click", () => {
      commentsLimit += commentsPagingStep;
      setStatus("×˜×•×¢×Ÿ ×¢×•×“ ×ª×’×•×‘×•×ªâ€¦", "info");
      loadComments(false, true);
    });
  }

  /* =====================================================================================
     Auth Flow Start
     ===================================================================================== */
  waitForPayload();

  /* =====================================================================================
     1ï¸âƒ£ ×§×‘×œ×ª payload ××§×•×“×•×œ×¨
     - ×¢× Hard limit ×›×“×™ ×©×œ× ×™×”×™×• ×œ×•×¤×™× ××™× ×¡×•×¤×™×™×
     ===================================================================================== */
  function waitForPayload() {
    try {
      const elapsed = nowTs() - payloadStartAt;
      if (elapsed > PAYLOAD_MAX_MS) {
        location.replace("forbidden.html");
        return;
      }

      const raw = window.AppInventor.getWebViewString();
      if (!raw) return setTimeout(waitForPayload, PAYLOAD_POLL_MS);

      payload = JSON.parse(raw);
    } catch (e) {
      return setTimeout(waitForPayload, PAYLOAD_POLL_MS);
    }

    login();
  }

  /* =====================================================================================
     2ï¸âƒ£ ×”×ª×—×‘×¨×•×ª Firebase
     ===================================================================================== */
  function login() {
    if (!payload || !payload.email || !payload.password || !payload.token) {
      location.replace("forbidden.html");
      return;
    }

    setStatus("××××ª ×”×ª×—×‘×¨×•×ªâ€¦", "info");

    firebase.auth()
      .signInWithEmailAndPassword(payload.email, payload.password)
      .then((cred) => {
        uid = cred.user.uid;
        return validateToken(uid, payload.token);
      })
      .then(() => fetchUsername(uid))
      .then((name) => {
        username = name || "××©×ª××©";
        isAuthed = true;

        setStatus("××—×•×‘×¨ ×›Ö¾" + username, "ok");

        // ×ª××™×“ × ×˜×¢×Ÿ ×¤×•×¡×˜ ××”-DB ×›×“×™ ×œ×—×©×‘ ×”×¨×©××•×ª ×¢×¨×™×›×” + ×ª××•× ×” + ×’×‘×•×œ ×¦×‘×¢
        loadPost();

        // ×ª×’×•×‘×•×ª
        loadComments(true, false);

        // Live comments (×©×“×¨×•×’)
        attachLiveComments();

      })
      .catch(() => {
        location.replace("forbidden.html");
      });
  }

  /* =====================================================================================
     3ï¸âƒ£ ××™××•×ª token
     ===================================================================================== */
  function validateToken(uid, token) {
    return firebase.database()
      .ref("sessions/" + uid + "/token")
      .once("value")
      .then((snap) => {
        if (!snap.exists() || snap.val() !== token) {
          location.replace("forbidden.html");
          throw new Error("invalid token");
        }
      });
  }

  /* =====================================================================================
     4ï¸âƒ£ ×©×œ×™×¤×ª ×©× ××©×ª××©
     ===================================================================================== */
  function fetchUsername(uid) {
    return firebase.database()
      .ref("users/" + uid + "/username")
      .once("value")
      .then((snap) => snap.val());
  }

  /* =====================================================================================
     5ï¸âƒ£ ×˜×¢×™× ×ª ×¤×•×¡×˜ ×Ö¾DB (××œ×)
     - ×›×•×œ×œ ×ª××•× ×” ×× ×§×™×™××ª
     - ×›×•×œ×œ ×’×‘×•×œ ×¦×‘×¢×•× ×™ ×œ×¤×™ userColor(author)
     - ×›×•×œ×œ ×›×¤×ª×•×¨ ×¢×¨×™×›×” ×¢×“ 24 ×©×¢×•×ª (×¨×§ ×”××—×‘×¨)
     ===================================================================================== */
  function loadPost() {
    setStatus("×˜×•×¢×Ÿ ×¤×•×¡×˜â€¦", "info");

    firebase.database()
      .ref("posts/" + postId)
      .once("value")
      .then((snap) => {
        if (!snap.exists()) {
          postContainer.innerHTML = "<p>×”×¤×•×¡×˜ ×œ× × ××¦×.</p>";
          setStatus("×”×¤×•×¡×˜ ×œ× × ××¦×.", "error");
          return;
        }

        const p = snap.val() || {};
        currentPostObj = p;

        const author = safeText(p.author || "");
        const border = userColor(author);
        const authorUid = safeText(p.authorUid || ""); // ×× ×§×™×™× ×‘×¢×ª×™×“
        const postTime = Number(p.time || 0);
       const imagePath = safeText(p.imagePath || "").trim();   // âœ… ×–×” ××” ×©× ×©××¨ ×¢×›×©×™×•
const legacyUrl = sanitizeImageUrl(p.image || "");      // âœ… ×¨×§ ×ª××™××•×ª ×œ××—×•×¨
const cached = imagePath ? getCachedSignedUrlForPath(imagePath) : "";
const initialSrc = cached || legacyUrl;

// cache ×œ× ×™×•×•×˜ ×—×–×¨×”
try {
  sessionStorage.setItem("currentPost", JSON.stringify({
    id: postId,
    title: safeText(p.title || ""),
    text: safeText(p.text || ""),
    author: author || "",
    imagePath: imagePath || "",
    imageUrl: initialSrc || ""   // ×›×“×™ ×©×™×¨××” ××™×™×“ ×× ×›×‘×¨ ×™×©
  }));
} catch {}
        
postContainer.innerHTML = `
  <div class="post post-user-border" style="border-right-color:${escapeHTML(border)};">
    <h3>${escapeHTML(p.title || "")}</h3>
    <p>${escapeHTML(p.text || "")}</p>

    <small>×××ª: ${escapeHTML(author)}</small>

    ${(imagePath || initialSrc) ? `
      <div class="post-image-wrap" data-img-wrap="1">
        <img class="post-image js-open-viewer"
             ${imagePath ? `data-image-path="${escapeHTML(imagePath)}"` : ``}
             ${initialSrc ? `src="${escapeHTML(initialSrc)}"` : ``} />
      </div>
    ` : ``}

    ${canEditPostNow ? `
      <button type="button"
              class="post-action"
              data-action="editPost">
        ×¢×¨×•×š ×¤×•×¡×˜
      </button>
    ` : ``}

  </div>
`;

bindPostActions();
hydrateSignedImages(postContainer);

        setStatus("×¤×•×¡×˜ × ×˜×¢×Ÿ.", "ok");
      })
      .catch(() => {
        postContainer.innerHTML = "<p>×©×’×™××” ×‘×˜×¢×™× ×ª ×”×¤×•×¡×˜.</p>";
        setStatus("×©×’×™××” ×‘×˜×¢×™× ×ª ×”×¤×•×¡×˜.", "error");
      });
  }

  /* =====================================================================================
     Post action buttons (×©×“×¨×•×’)
     ===================================================================================== */
  function bindPostActions() {
    if (postContainer.__actionsBound) return;
    postContainer.__actionsBound = true;

    postContainer.addEventListener("click", (e) => {
     // âœ… open viewer for post image too
const img = e.target.closest(".js-open-viewer");
if (img) {
  const hint = img.getAttribute("data-hint") || "";
  const path = safeText(img.getAttribute("data-image-path") || "").trim();
  const src  = img.getAttribute("src") || "";

  if (path) {
    fetchSignedUrlForPath(path).then((url) => {
      if (url) openMiniViewer(url, hint);
      else openMiniViewer(src, hint);
    });
  } else {
    openMiniViewer(src, hint);
  }
  return;
}


      const action = btn.getAttribute("data-action");
      if (!action) return;

      if (action === "copyLink") {
        const link = location.href;
        copyToClipboard(link);
        setStatus("×”×§×™×©×•×¨ ×”×•×¢×ª×§.", "ok");
      }

      if (action === "share") {
        const link = location.href;
        tryShareOrCopy(link);
      }

      if (action === "report") {
        reportPost();
      }

      if (action === "editPost") {
        openEditPostModal();
      }
    }, false);
  }

  function tryShareOrCopy(text) {
    try {
      if (navigator.share) {
        navigator.share({ title: "×¤×•×¨×•×", text: "×§×™×©×•×¨ ×œ×¤×•×¡×˜:", url: text })
          .then(() => setStatus("×©×•×ª×£.", "ok"))
          .catch(() => {
            copyToClipboard(text);
            setStatus("××™×Ÿ ×©×™×ª×•×£ ××•×‘× ×”. ×”×¢×ª×§×ª×™ ×§×™×©×•×¨.", "ok");
          });
      } else {
        copyToClipboard(text);
        setStatus("××™×Ÿ ×©×™×ª×•×£ ××•×‘× ×”. ×”×¢×ª×§×ª×™ ×§×™×©×•×¨.", "ok");
      }
    } catch {
      copyToClipboard(text);
      setStatus("×”×•×¢×ª×§ ×§×™×©×•×¨.", "ok");
    }
  }

  /* =====================================================================================
     Report post (×©×“×¨×•×’)
     - × ×©××¨, ×›×™ ×‘×™×§×©×ª ×œ×‘×˜×œ ×¨×§ ×“×™×•×•×— ×¢×œ ×ª×’×•×‘×•×ª
     ===================================================================================== */
  function reportPost() {
    if (!isAuthed || !uid) {
      setStatus("×œ× ×××•××ª. ×œ× × ×™×ª×Ÿ ×œ×“×•×•×—.", "error");
      return;
    }

    const reportObj = {
      type: "post",
      postId: postId,
      reporterUid: uid,
      reporterName: username,
      time: nowTs(),
      reason: "report"
    };

    firebase.database()
      .ref("reports")
      .push(reportObj)
      .then(() => setStatus("×“×•×•×— ×‘×”×¦×œ×—×”. ×ª×•×“×”.", "ok"))
      .catch(() => setStatus("×©×’×™××” ×‘×“×™×•×•×—.", "error"));
  }

  /* =====================================================================================
     EDIT POST (NEW) â€“ ×¢×“ 24 ×©×¢×•×ª, ×¨×§ ×”××—×‘×¨
     ===================================================================================== */
  function editPostErrorShow(msg) {
    if (!editPostError) return;
    editPostError.textContent = msg;
    editPostError.style.display = "block";
  }
  function editPostErrorHide() {
    if (!editPostError) return;
    editPostError.textContent = "";
    editPostError.style.display = "none";
  }

  function openEditPostModal() {
    if (!canEditPostNow) {
      setStatus("××™×Ÿ ×”×¨×©××” ×œ×¢×¨×•×š (×¨×§ ×”××—×‘×¨ ×•×¢×“ 24 ×©×¢×•×ª).", "error");
      return;
    }
    editPostErrorHide();

    const t = safeText((currentPostObj && currentPostObj.title) ? currentPostObj.title : "");
    const x = safeText((currentPostObj && currentPostObj.text) ? currentPostObj.text : "");

    if (editPostTitle) editPostTitle.value = t;
    if (editPostText) editPostText.value = x;

    if (editPostOverlay) editPostOverlay.style.display = "flex";
    setTimeout(() => { try { editPostTitle && editPostTitle.focus(); } catch {} }, 50);
  }

  function closeEditPostModal() {
    editPostErrorHide();
    if (editPostOverlay) editPostOverlay.style.display = "none";
  }

  if (closeEditPostBtn) closeEditPostBtn.addEventListener("click", closeEditPostModal);
  if (cancelEditPostBtn) cancelEditPostBtn.addEventListener("click", closeEditPostModal);

  if (editPostOverlay) {
    editPostOverlay.addEventListener("click", function (e) {
      if (e.target === editPostOverlay) closeEditPostModal();
    });
  }

  if (saveEditPostBtn) {
    saveEditPostBtn.addEventListener("click", function () {
      editPostErrorHide();

      if (!isAuthed || !uid) {
        editPostErrorShow("×œ× ×××•××ª. × ×¡×” ×©×•×‘.");
        return;
      }
      if (!canEditPostNow) {
        editPostErrorShow("××™×Ÿ ×”×¨×©××” ×œ×¢×¨×•×š (×¨×§ ×”××—×‘×¨ ×•×¢×“ 24 ×©×¢×•×ª).");
        return;
      }

      const title = safeText(editPostTitle ? editPostTitle.value : "").trim();
      const text = safeText(editPostText ? editPostText.value : "").trim();

      if (title.length < 3) { editPostErrorShow("×›×•×ª×¨×ª ×§×¦×¨×” ××“×™. ××™× ×™××•× 3 ×ª×•×•×™×."); return; }
      if (text.length < 3) { editPostErrorShow("×ª×•×›×Ÿ ×§×¦×¨ ××“×™. ××™× ×™××•× 3 ×ª×•×•×™×."); return; }

      setStatus("×©×•××¨ ×¢×¨×™×›×”â€¦", "info");
      saveEditPostBtn.disabled = true;

      // Selective update: ×¨×§ title/text (×œ× ××©× ×™× time, ×œ× × ×•×’×¢×™× ×‘××‘×˜×—×”)
      firebase.database()
        .ref("posts/" + postId)
        .update({
          title: title,
          text: text
        })
        .then(() => {
          setStatus("×”×¤×•×¡×˜ ×¢×•×“×›×Ÿ.", "ok");
          closeEditPostModal();
          // ×¨×¢× ×•×Ÿ ×¤×•×¡×˜ ×œ-UI + cache
          loadPost();
        })
        .catch(() => {
          editPostErrorShow("×©×’×™××” ×‘×©××™×¨×ª ×”×¢×¨×™×›×”. × ×¡×” ×©×•×‘.");
          setStatus("×©×’×™××” ×‘×©××™×¨×ª ×”×¢×¨×™×›×”.", "error");
        })
        .finally(() => {
          saveEditPostBtn.disabled = false;
        });
    });
  }

  /* =====================================================================================
     6ï¸âƒ£ ×˜×¢×™× ×ª ×ª×’×•×‘×•×ª (×¢× cache + ×©×“×¨×•×’×™×)
     ===================================================================================== */
  function loadComments(isFirst = false, isLoadMore = false) {
    if (!isAuthed) return;

    if (isFirst) {
      commentsBox.innerHTML = "<div class='loader'></div>";
    }

    const limit = Math.max(1, Number(commentsLimit || 200));

    firebase.database()
      .ref("comments/" + postId)
      .orderByChild("time")
      .limitToLast(limit)
      .once("value")
      .then((snap) => {
        const items = [];
        snap.forEach((cSnap) => {
          const v = cSnap.val() || {};
          items.push({
            id: cSnap.key,
            text: safeText(v.text),
            author: safeText(v.author),
            authorUid: safeText(v.authorUid || ""),
            time: Number(v.time || 0),
            imagePath: safeText(v.imagePath || "").trim(),
image: sanitizeImageUrl(v.image || "") // ×ª××™××•×ª ×œ××—×•×¨ ×‘×œ×‘×“

          });
        });

        canLoadMore = items.length >= limit;
        if (loadMoreCommentsBtn) {
          loadMoreCommentsBtn.style.display = canLoadMore ? "inline-block" : "none";
        }

        commentsCache = items;

        renderCommentsFromCache();

        if (isLoadMore) {
          setStatus("× ×˜×¢× ×• ×¢×•×“ ×ª×’×•×‘×•×ª.", "ok");
        } else if (isFirst) {
          setStatus("×ª×’×•×‘×•×ª × ×˜×¢× ×•.", "ok");
        }
      })
      .catch(() => {
        commentsBox.innerHTML = "<p>×©×’×™××” ×‘×˜×¢×™× ×ª ×ª×’×•×‘×•×ª.</p>";
        setStatus("×©×’×™××” ×‘×˜×¢×™× ×ª ×ª×’×•×‘×•×ª.", "error");
      });
  }

  /* =====================================================================================
     Render comments from cache (×—×™×¤×•×© + ××™×•×Ÿ)
     ===================================================================================== */
  function renderCommentsFromCache() {
    const q = safeText(commentSearch?.value).trim().toLowerCase();
    const mode = safeText(commentSort?.value) || "newest";

    let list = commentsCache.slice();

    if (q) {
      list = list.filter((c) => {
        const t = (c.text || "").toLowerCase();
        const a = (c.author || "").toLowerCase();
        const hasImg = (c.imagePath || c.image) ? "×ª××•× ×”" : "";

        return t.includes(q) || a.includes(q) || hasImg.includes(q);
      });
    }

    if (mode === "oldest") {
      list.sort((a, b) => (a.time || 0) - (b.time || 0));
    } else if (mode === "author") {
      list.sort((a, b) => (a.author || "").localeCompare(b.author || "", "he"));
    } else {
      list.sort((a, b) => (b.time || 0) - (a.time || 0));
    }

    if (list.length === 0) {
      commentsBox.innerHTML = q ? "<p>×œ× × ××¦××• ×ª×•×¦××•×ª.</p>" : "<p>××™×Ÿ ×ª×’×•×‘×•×ª ×¢×“×™×™×Ÿ.</p>";
      commentsRenderedHtml = commentsBox.innerHTML;
      return;
    }

    commentsBox.innerHTML = "";
for (const c of list) {
  renderComment(c.id, c);
}

// âœ… ×—×•×‘×” ××—×¨×™ ×‘× ×™×™×” ××—×“×©
hydrateSignedImages(commentsBox);

commentsRenderedHtml = commentsBox.innerHTML;

  }

  /* =====================================================================================
     7ï¸âƒ£ Render single comment
     - ×‘×•×˜×œ ×“×™×•×•×— ×¢×œ ×ª×’×•×‘×•×ª: ×”×›×¤×ª×•×¨ ×”×•×—×œ×£ ×‘"×¢×¨×•×š" (×œ××—×‘×¨)
     - ×ª××•× ×” ×œ×ª×’×•×‘×” (×ª×¦×•×’×” ×§×˜× ×”) ×× ×§×™×™××ª
     ===================================================================================== */
  function canEditItem(author, authorUid, itemTime) {
    try {
      const a = safeText(author || "");
      const au = safeText(authorUid || "");
      const t = Number(itemTime || 0) || 0;

      const isOwner = (au && uid && au === uid) || (!!a && a === username);
      const DAY_MS = 24 * 60 * 60 * 1000;
      const withinDay = t ? ((nowTs() - t) <= DAY_MS) : false;

      return !!(isOwner && withinDay);
    } catch (e) {
      return false;
    }
  }

  function renderComment(id, c) {
    const color = userColor(c.author);
    const canEdit = canEditItem(c.author, c.authorUid, c.time);

    const div = document.createElement("div");
    div.className = "comment";
    div.style.borderRightColor = color;
    div.setAttribute("data-comment-id", id);

const imgPath = safeText(c.imagePath || "").trim();
const legacyUrl = sanitizeImageUrl(c.image || "");
const cached = imgPath ? getCachedSignedUrlForPath(imgPath) : "";
const initialSrc = cached || legacyUrl;

    div.innerHTML = `
      <div class="comment-header" style="display:flex; justify-content:space-between; align-items:center;">
        <b style="color:${escapeHTML(color)};">${escapeHTML(c.author)}</b>
        <small>${escapeHTML(fmtDateTime(c.time))}</small>
      </div>
      <p class="comment-text">${escapeHTML(c.text)}</p>

      ${(imgPath || initialSrc) ? `
        <div data-img-wrap="1" style="display:${initialSrc ? "block" : "none"};">
          <img class="mini-image js-open-viewer"
               data-hint="×ª××•× ×” ×‘×ª×’×•×‘×”"
               ${imgPath ? `data-image-path="${escapeHTML(imgPath)}"` : ``}
               ${initialSrc ? `src="${escapeHTML(initialSrc)}"` : ``}
               alt="×ª××•× ×”" />
        </div>
      ` : ``}

      <div class="comment-actions" style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
        <button type="button" class="btn-reply" data-action="openReply" data-id="${escapeHTML(id)}">×”×©×‘</button>

        <span class="reply-count"
              id="reply-count-${escapeHTML(id)}"
              data-action="toggleReplies"
              data-id="${escapeHTML(id)}"
              style="cursor:pointer; user-select:none;">
          ×˜×•×¢×Ÿ ×ª×’×•×‘×•×ªâ€¦
        </span>

        <button type="button"
                class="btn-copy"
                data-action="copyComment"
                data-id="${escapeHTML(id)}"
                style="padding:6px 10px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;">
          ×”×¢×ª×§
        </button>

        ${canEdit ? `
          <button type="button"
                  class="btn-edit"
                  data-action="editComment"
                  data-id="${escapeHTML(id)}"
                  style="padding:6px 10px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;font-weight:bold;">
            ×¢×¨×•×š
          </button>
        ` : ``}

        <!-- DISABLED: reporting comments per request (kept for length) -->
        <!--
        <button type="button"
                class="btn-report"
                data-action="reportComment"
                data-id="${escapeHTML(id)}"
                style="padding:6px 10px;border-radius:10px;border:1px solid rgba(255,0,0,0.35);background:rgba(255,0,0,0.06);cursor:pointer;">
          ×“×•×•×—
        </button>
        -->
      </div>

      <div class="replies hidden" id="replies-${escapeHTML(id)}"></div>
    `;

    commentsBox.appendChild(div);

    updateReplyCount(id);
  }

  /* =====================================================================================
     Delegation for comment actions (×™×¦×™×‘ ×‘-WebView)
     + ×©×“×¨×•×’: ×¤×ª×™×—×ª viewer ×¢×œ ×ª××•× ×•×ª
     ===================================================================================== */
  (function bindCommentDelegation() {
    if (commentsBox.__delegationBound) return;
    commentsBox.__delegationBound = true;

    commentsBox.addEventListener("click", (e) => {

      // open viewer for any image with .js-open-viewer
      try {
       const img = e.target.closest(".js-open-viewer");
if (img) {
  const hint = img.getAttribute("data-hint") || "";
  const path = safeText(img.getAttribute("data-image-path") || "").trim();
  const src  = img.getAttribute("src") || "";

  if (path) {
    fetchSignedUrlForPath(path).then((url) => {
      if (url) openMiniViewer(url, hint);
      else openMiniViewer(src, hint);
    });
  } else {
    openMiniViewer(src, hint);
  }
  return;
}

      } catch {}

      const el = e.target.closest("[data-action]");
      if (!el) return;

      const action = el.getAttribute("data-action");
      const id = el.getAttribute("data-id");
      if (!action || !id) return;

      if (action === "openReply") {
        openReply(id);
      }

      if (action === "toggleReplies") {
        toggleReplies(id);
      }

      if (action === "copyComment") {
        const commentNode = el.closest(".comment");
        const textNode = commentNode ? commentNode.querySelector(".comment-text") : null;
        const txt = textNode ? textNode.innerText : "";
        copyToClipboard(txt);
        setStatus("×”×ª×’×•×‘×” ×”×•×¢×ª×§×”.", "ok");
      }

      if (action === "editComment") {
        beginInlineEditComment(id);
      }

      // DISABLED per request (kept for length)
      if (action === "reportComment") {
        // reportComment(id);
      }

    }, false);
  })();

  /* =====================================================================================
     Replies feature â€“ × ×©××¨ + ××©×•×“×¨×’
     - ×¨×™×¤×œ×™×™ ×’× ×™×›×•×œ ×œ×›×œ×•×œ ×ª××•× ×” (×›××• ×ª×’×•×‘×”) + ×¢×¨×™×›×” ×‘××§×•× ×“×™×•×•×—
     - ×—×©×•×‘: ×¨×™×¤×œ×™×™ ×œ× × ×¡×¤×¨ ×‘-count ×©×œ ×ª×’×•×‘×•×ª ×œ×¤×•×¡×˜ (×–×” × ×©××¨ ×‘-forum)
     ===================================================================================== */

  window.updateReplyCount = updateReplyCount;
  window.toggleReplies = toggleReplies;
  window.openReply = openReply;
  window.sendReply = sendReply;

  function updateReplyCount(id) {
    if (!isAuthed) return;

    firebase.database()
      .ref("replies/" + postId + "/" + id)
      .once("value")
      .then((s) => {
        const el = document.getElementById("reply-count-" + id);
        if (!el) return;
        const count = s.numChildren();
        el.textContent = count ? `${count} ×ª×’×•×‘×•×ª â–¾` : "××™×Ÿ ×ª×’×•×‘×•×ª";
      })
      .catch(() => {});
  }

  function toggleReplies(id) {
    const box = document.getElementById("replies-" + id);
    if (!box) return;

    const isOpen = !box.classList.contains("hidden");

    if (isOpen) {
      box.classList.add("hidden");
      repliesOpenState[id] = false;
      detachRepliesLive(id);
      return;
    }

    box.classList.remove("hidden");
    repliesOpenState[id] = true;

    box.innerHTML = "<div class='loader'></div>";

    firebase.database()
      .ref("replies/" + postId + "/" + id)
      .orderByChild("time")
      .limitToLast(200)
      .once("value")
.then((s) => {
  let html = "";

  if (!s.exists()) {
    html = `
      <div style="padding:10px 0; opacity:.75;">
        ××™×Ÿ ×ª×’×•×‘×•×ª ×¢×“×™×™×Ÿ. ×ª×”×™×” ×”×¨××©×•×Ÿ.
      </div>
    `;
  } else {
    const arr = [];
    s.forEach((r) => {
      const d = r.val() || {};
      arr.push({
        rid: r.key,
        author: safeText(d.author),
        authorUid: safeText(d.authorUid || ""),
        text: safeText(d.text),
        time: Number(d.time || 0),

        imagePath: safeText(d.imagePath || "").trim(), // âœ…
        image: sanitizeImageUrl(d.image || "")         // âœ… legacy
      });
    });

    arr.sort((a, b) => (a.time || 0) - (b.time || 0));

    for (const d of arr) {
      html += buildReplyHTML(id, d);
    }
  }

  html += buildReplyComposerHTML(id);

  box.innerHTML = html;

  // âœ… ×§×•×“× hydrate ×›×“×™ ×©×”×ª××•× ×•×ª ×™×§×‘×œ×• src
  hydrateSignedImages(box);

  // âœ… ×•××– ×œ×™×™×‘ + ×¡×¤×™×¨×” + bind input ×œ×ª××•× ×” (× ×¢×©×” ×‘×ª×•×š attachRepliesLive)
  attachRepliesLive(id);
  updateReplyCount(id);
})

      .catch(() => {
        box.innerHTML = "<p>×©×’×™××” ×‘×˜×¢×™× ×ª ×ª×’×•×‘×•×ª-×¢×œ-×ª×’×•×‘×”.</p>";
      });
  }

function buildReplyHTML(commentId, d) {
  const c = userColor(d.author);
  const canEdit = canEditItem(d.author, d.authorUid, d.time);

  // âœ… ×—×“×©: × ×ª×™×‘ ×‘-Storage
  const imgPath = safeText(d.imagePath || "").trim();

  // âœ… ×ª××™××•×ª ×œ××—×•×¨: ×× ×™×© ×¢×“×™×™×Ÿ URL ×™×©×Ÿ ×‘×©×“×” image
  const legacyUrl = sanitizeImageUrl(d.image || "");

  // âœ… ×× ×™×© URL ×—×ª×•× ×‘×–×™×›×¨×•×Ÿ (cache), × ×¦×™×’ ××™×“; ××—×¨×ª × ×¡×ª×™×¨ ×¢×“ hydrate
  const cached = imgPath ? getCachedSignedUrlForPath(imgPath) : "";
  const initialSrc = cached || legacyUrl;

  return `
    <div class="reply" data-reply-id="${escapeHTML(d.rid || "")}" style="
      border-right: 4px solid ${escapeHTML(c)};
      padding:10px 10px;
      margin:10px 0;
      border-radius:10px;
      background: rgba(0,0,0,0.03);
    ">
      <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
        <b style="color:${escapeHTML(c)};">${escapeHTML(d.author || "")}</b>
        <small style="opacity:.75;">${escapeHTML(fmtTime(d.time || 0))}</small>
      </div>

      <p class="reply-text" id="reply-text-${escapeHTML(commentId)}-${escapeHTML(d.rid || "")}" style="margin:6px 0 0 0;">${escapeHTML(d.text || "")}</p>

      ${(imgPath || initialSrc) ? `
        <div data-img-wrap="1" style="display:${initialSrc ? "block" : "none"};">
          <img class="mini-image js-open-viewer"
               data-hint="×ª××•× ×” ×‘×¨×™×¤×œ×™×™"
               ${imgPath ? `data-image-path="${escapeHTML(imgPath)}"` : ``}
               ${initialSrc ? `src="${escapeHTML(initialSrc)}"` : ``}
               alt="×ª××•× ×”" />
        </div>
      ` : ``}

      <div style="margin-top:6px; display:flex; gap:10px; flex-wrap:wrap;">
        <button type="button"
                data-reply-action="copyReply"
                data-comment-id="${escapeHTML(commentId)}"
                data-reply-id="${escapeHTML(d.rid || "")}"
                style="padding:6px 10px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;">
          ×”×¢×ª×§
        </button>

        ${canEdit ? `
          <button type="button"
                  data-reply-action="editReply"
                  data-comment-id="${escapeHTML(commentId)}"
                  data-reply-id="${escapeHTML(d.rid || "")}"
                  style="padding:6px 10px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;font-weight:bold;">
            ×¢×¨×•×š
          </button>
        ` : ``}
      </div>
    </div>
  `;
}

  function buildReplyComposerHTML(commentId) {
    return `
      <div class="reply-composer" style="
        margin-top:12px;
        padding:12px;
        border-radius:12px;
        border:1px solid rgba(0,0,0,0.10);
        background:#fff;
      ">
        <div style="font-weight:bold; margin-bottom:8px;">×”×•×¡×£ ×ª×’×•×‘×” ×œ×ª×’×•×‘×”</div>

        <textarea id="reply-textarea-${escapeHTML(commentId)}"
                  placeholder="×›×ª×•×‘ ×ª×’×•×‘×”..."
                  maxlength="600"
                  rows="3"
                  style="
                    width:100%;
                    box-sizing:border-box;
                    padding:10px 12px;
                    border-radius:10px;
                    border:1px solid rgba(0,0,0,0.15);
                    outline:none;
                    resize:vertical;
                  "></textarea>

        <!-- =====================================================================================
             REPLY IMAGE (NEW) â€“ ×ª××•× ×” ×œ×¨×™×¤×œ×™×™ (××•×¤×¦×™×•× ×œ×™)
             ===================================================================================== -->
        <div style="
          margin-top:10px;
          border:1px solid rgba(0,0,0,0.10);
          border-radius:14px;
          padding:12px;
          background: rgba(0,0,0,0.02);
        ">
          <div class="img-actions-row">
            <div style="display:flex; flex-direction:column; gap:4px;">
              <div style="font-weight:bold;">×ª××•× ×” ×œ×¨×™×¤×œ×™×™ (××•×¤×¦×™×•× ×œ×™)</div>
              <div style="font-size:12px; opacity:.75;">×¤×•×¨××˜×™× × ×ª××›×™×: JPG/PNG/WebP. ××•××œ×¥ ×¢×“ 9MB.</div>
            </div>

            <div style="display:flex; gap:10px; flex-wrap:wrap;">
              <button type="button"
                      class="img-btn img-btn-primary"
                      data-reply-action="chooseReplyImage"
                      data-id="${escapeHTML(commentId)}">×‘×—×¨ ×ª××•× ×”</button>

              <button type="button"
                      class="img-btn img-btn-danger"
                      data-reply-action="removeReplyImage"
                      data-id="${escapeHTML(commentId)}"
                      style="display:none;"
                      id="reply-remove-img-${escapeHTML(commentId)}">×”×¡×¨ ×ª××•× ×”</button>
            </div>
          </div>

          <input id="reply-image-${escapeHTML(commentId)}" type="file" accept="image/*" style="display:none;" />

          <div id="reply-preview-wrap-${escapeHTML(commentId)}" style="display:none;">
            <div class="img-preview">
              <img id="reply-preview-img-${escapeHTML(commentId)}" alt="×ª×¦×•×’×” ××§×“×™××”" src="" />
            </div>
          </div>
        </div>

        <div style="margin-top:10px; display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <small style="opacity:.75;">××§×¡×™××•× 600 ×ª×•×•×™×.</small>
          <div style="display:flex; gap:10px;">
            <button type="button"
                    class="reply-send-btn"
                    data-reply-action="sendReply"
                    data-id="${escapeHTML(commentId)}"
                    style="
                      padding:8px 12px;
                      border-radius:10px;
                      border:none;
                      background: rgb(17,17,87);
                      color:#fff;
                      cursor:pointer;
                      font-weight:bold;
                    ">×©×œ×—</button>
            <button type="button"
                    class="reply-close-btn"
                    data-reply-action="closeReplies"
                    data-id="${escapeHTML(commentId)}"
                    style="
                      padding:8px 12px;
                      border-radius:10px;
                      border:1px solid rgba(0,0,0,0.15);
                      background:#fff;
                      cursor:pointer;
                      font-weight:bold;
                    ">×¡×’×•×¨</button>
          </div>
        </div>

        <div id="reply-error-${escapeHTML(commentId)}" style="
          display:none;
          margin-top:10px;
          padding:10px 12px;
          border-radius:12px;
          background: rgba(255,0,0,0.08);
          color:#8a0000;
          font-size:13px;
        "></div>
      </div>
    `;
  }

  // Reply image state per commentId
  const replyImageState = Object.create(null); // commentId => {file, previewUrl, canRevoke}

  function initReplyImageState(commentId) {
    const id = safeText(commentId || "");
    if (!id) return;
    if (!replyImageState[id]) {
      replyImageState[id] = { file: null, previewUrl: "", canRevoke: false };
    }
  }

  function clearReplyImage(commentId, resetInput) {
    initReplyImageState(commentId);
    const st = replyImageState[commentId];

    try {
      if (st.previewUrl && st.canRevoke) {
        try { URL.revokeObjectURL(st.previewUrl); } catch {}
      }
    } catch {}

    st.file = null;
    st.previewUrl = "";
    st.canRevoke = false;

    try {
      const img = document.getElementById("reply-preview-img-" + commentId);
      const wrap = document.getElementById("reply-preview-wrap-" + commentId);
      const inp = document.getElementById("reply-image-" + commentId);
      const rm = document.getElementById("reply-remove-img-" + commentId);

      if (img) img.setAttribute("src", "");
      if (wrap) wrap.style.display = "none";
      if (rm) rm.style.display = "none";
      if (resetInput && inp) inp.value = "";
    } catch {}
  }

  /* =====================================================================================
     Delegation ×‘×ª×•×š replies containers (×©×“×¨×•×’ ×™×¦×™×‘×•×ª)
     + ×¢×¨×™×›×” ×œ×¨×™×¤×œ×™×™
     + ×ª××•× ×•×ª ×œ×¨×™×¤×œ×™×™
     ===================================================================================== */
  (function bindRepliesDelegation() {
    if (commentsBox.__repliesDelegationBound) return;
    commentsBox.__repliesDelegationBound = true;

    commentsBox.addEventListener("click", (e) => {
      const a = e.target.closest("[data-reply-action]");
      if (!a) return;

      const act = a.getAttribute("data-reply-action");
      const cid = a.getAttribute("data-id") || a.getAttribute("data-comment-id");
      const rid = a.getAttribute("data-reply-id");

      if (!act || !cid) return;

      if (act === "sendReply") {
        sendReply(cid);
      }

      if (act === "closeReplies") {
        toggleReplies(cid);
      }

      if (act === "copyReply") {
        const replyNode = a.closest(".reply");
        const p = replyNode ? replyNode.querySelector(".reply-text") : null;
        const txt = p ? p.innerText : "";
        copyToClipboard(txt);
        setStatus("×”×ª×’×•×‘×”-×¢×œ-×ª×’×•×‘×” ×”×•×¢×ª×§×”.", "ok");
      }

      if (act === "editReply") {
        if (!rid) return;
        beginInlineEditReply(cid, rid);
      }

      if (act === "chooseReplyImage") {
        initReplyImageState(cid);
        try {
          const inp = document.getElementById("reply-image-" + cid);
          if (inp) {
            inp.value = "";
            inp.click();
          }
        } catch {}
      }

      if (act === "removeReplyImage") {
        clearReplyImage(cid, true);
      }

      // DISABLED per request (kept for length)
      if (act === "reportReply") {
        // if (!rid) return;
        // reportReply(cid, rid);
      }

    }, false);

    // change handler for each reply image input (event delegation is hard for change)
    // solution: attach when replies open (selective & safe)
  })();

  function bindReplyImageInput(commentId) {
    try {
      const inp = document.getElementById("reply-image-" + commentId);
      if (!inp || inp.__bound) return;
      inp.__bound = true;

      inp.addEventListener("change", function () {
        try {
          const f = (inp.files && inp.files[0]) ? inp.files[0] : null;
          if (!f) return;

          if (!isLikelyImageFile(f)) {
            replyErrorShow(commentId, "×§×•×‘×¥ ×œ× × ×ª××š. ×‘×—×¨ ×ª××•× ×” (JPG/PNG/WebP).");
            clearReplyImage(commentId, true);
            return;
          }

          if (Number(f.size || 0) > MAX_IMG) {
            replyErrorShow(commentId, "×”×ª××•× ×” ×’×“×•×œ×” ××“×™ (" + bytesToHuman(f.size) + "). ×¢×“ 9MB.");
            clearReplyImage(commentId, true);
            return;
          }

          initReplyImageState(commentId);
          const st = replyImageState[commentId];
          st.file = f;

          // cleanup preview
          try {
            if (st.previewUrl && st.canRevoke) { try { URL.revokeObjectURL(st.previewUrl); } catch {} }
          } catch {}
          st.previewUrl = "";
          st.canRevoke = false;

          const img = document.getElementById("reply-preview-img-" + commentId);
          const wrap = document.getElementById("reply-preview-wrap-" + commentId);
          const rm = document.getElementById("reply-remove-img-" + commentId);

          let previewSet = false;
          try {
            if (window.URL && typeof URL.createObjectURL === "function") {
              const u = URL.createObjectURL(f);
              st.previewUrl = u;
              st.canRevoke = true;
              if (img) img.setAttribute("src", u);
              if (wrap) wrap.style.display = "block";
              if (rm) rm.style.display = "inline-block";
              previewSet = true;
            }
          } catch {}

          if (!previewSet) {
            readFileAsDataURLWithRetry(f, 3, function (durl, ok) {
              if (!ok) {
                replyErrorShow(commentId, "×œ× ×”×¦×œ×—×ª×™ ×œ×”×¦×™×’ ×ª×¦×•×’×” ××§×“×™××”, ××‘×œ ×× ×¡×” ×œ×”×¢×œ×•×ª ×›×¨×’×™×œ.");
                return;
              }
              st.previewUrl = durl;
              st.canRevoke = false;
              if (img) img.setAttribute("src", durl);
              if (wrap) wrap.style.display = "block";
              if (rm) rm.style.display = "inline-block";
            });
          }

        } catch {}
      });
    } catch {}
  }

  function openReply(id) {
    const box = document.getElementById("replies-" + id);
    if (!box) return;

    if (box.classList.contains("hidden")) {
      toggleReplies(id);
      setTimeout(() => {
        const ta = document.getElementById("reply-textarea-" + id);
        try { ta && ta.focus(); } catch {}
      }, 150);
      return;
    }

    const ta = document.getElementById("reply-textarea-" + id);
    try { ta && ta.focus(); } catch {}
  }

  function replyErrorShow(commentId, msg) {
    const el = document.getElementById("reply-error-" + commentId);
    if (!el) return;
    el.textContent = msg;
    el.style.display = "block";
  }

  function replyErrorHide(commentId) {
    const el = document.getElementById("reply-error-" + commentId);
    if (!el) return;
    el.textContent = "";
    el.style.display = "none";
  }

/* =====================================================================================
   Image prepare/compress + upload (FROM forum file mechanism)
   - Prepare only at send-time (no heavy work on selection)
   - Prefer WEBP when supported, else JPEG/PNG
   - Max dimension 1600, quality ~0.82
   - HEIC/HEIF: upload as-is (avoid decode failures)
   - Upload: ref.put(blob) preferred, fallback: putString(data_url)
   ===================================================================================== */

function dataURLToBlob(dataUrl) {
  try {
    const parts = safeText(dataUrl || "").split(",");
    if (parts.length < 2) return null;
    const meta = parts[0];
    const b64 = parts[1];
    let mime = "application/octet-stream";
    const m = /data:([^;]+);base64/i.exec(meta);
    if (m && m[1]) mime = m[1];
    const bin = atob(b64);
    const len = bin.length;
    const arr = new Uint8Array(len);
    for (let i = 0; i < len; i++) arr[i] = bin.charCodeAt(i);
    return new Blob([arr], { type: mime });
  } catch (e) {
    return null;
  }
}

function canvasToBlobSafe(canvas, outType, quality, cb) {
  try {
    if (canvas && typeof canvas.toBlob === "function") {
      canvas.toBlob(function (blob) { cb(blob); }, outType, quality);
      return;
    }
  } catch {}
  try {
    let dataUrl = "";
    try { dataUrl = canvas.toDataURL(outType, quality); } catch { dataUrl = canvas.toDataURL(); }
    const blob2 = dataURLToBlob(dataUrl);
    cb(blob2);
  } catch {
    cb(null);
  }
}

function getPreviewUrlForFile(file, done) {
  try {
    if (window.URL && typeof URL.createObjectURL === "function") {
      try {
        const u = URL.createObjectURL(file);
        done(u, true);
        return;
      } catch {}
    }
  } catch {}

  try {
    const r = new FileReader();
    r.onerror = function () { done("", false); };
    r.onload = function () { done(safeText(r.result || ""), false); };
    r.readAsDataURL(file);
  } catch {
    done("", false);
  }
}

function supportsWebPExport() {
  try {
    const c = document.createElement("canvas");
    if (!c || typeof c.toDataURL !== "function") return false;
    const u = c.toDataURL("image/webp");
    return (u && u.startsWith("data:image/webp"));
  } catch (e) {
    return false;
  }
}

function yieldToUI() {
  return new Promise((resolve) => {
    try { setTimeout(resolve, 0); } catch { resolve(); }
  });
}

function readBlobAsDataURLWithRetry(blob, tries, done) {
  try {
    let left = Number(tries || 1);
    if (left < 1) left = 1;

    const attempt = function () {
      try {
        const r = new FileReader();
        r.onerror = function () {
          left--;
          if (left <= 0) { done("", false); return; }
          setTimeout(attempt, 160);
        };
        r.onload = function () {
          const dataUrl = safeText(r.result || "");
          if (!dataUrl || !dataUrl.startsWith("data:")) {
            left--;
            if (left <= 0) { done("", false); return; }
            setTimeout(attempt, 160);
            return;
          }
          done(dataUrl, true);
        };
        r.readAsDataURL(blob);
      } catch (e1) {
        left--;
        if (left <= 0) { done("", false); return; }
        setTimeout(attempt, 160);
      }
    };

    attempt();
  } catch (e0) {
    done("", false);
  }
}

function prepareImageForUpload(file) {
  // ×¢×™×‘×•×“ "×—×›×" ×¨×§ ×‘×–××Ÿ ×©×œ×™×—×”. ××‘×•×¡×¡ ×× ×’× ×•×Ÿ ×”×§×•×‘×¥ ×©×©×œ×—×ª.
  return new Promise(function (resolve) {
    (function run() {
      try {
        if (!file) { resolve({ blob: null, contentType: "", ext: "" }); return; }

        const origType = safeText(file.type || "").toLowerCase();
        const origName = safeText(file.name || "");
        let ext = "";
        if (origName.includes(".")) ext = origName.split(".").pop().toLowerCase();

        const size = Number(file.size || 0);

        // HEIC/HEIF: ×œ× ×× ×¡×™× ×“×™×§×•×“/×›×™×•×•×¥ ×›×“×™ ×œ× ×œ×”×¤×™×œ WebView ×—×œ×©
        const isHeic = (origType.includes("heic") || origType.includes("heif") || ext === "heic" || ext === "heif");
        if (isHeic) {
          setStatus("×ª××•× ×ª HEIC/HEIF: ×ª×•×¢×œ×” ×›××• ×©×”×™× (×œ×œ× ××•×¤×˜×™××™×–×¦×™×”).", "warn");
          resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "heic" });
          return;
        }

        // ×× ×§×˜×Ÿ (<= ~700KB) â€“ ×œ× ××›×•×•×¦×™× (×—×•×¡×š CPU)
        const SHOULD_TRY = size > (700 * 1024);
        if (!SHOULD_TRY) {
          resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });
          return;
        }

        // ×¤×•×¨××˜ ×™×¢×“
        const canWebp = supportsWebPExport();
        let outType = "image/jpeg";
        let outExt = "jpg";
        if (canWebp) {
          outType = "image/webp";
          outExt = "webp";
        } else if (origType === "image/png" || ext === "png") {
          outType = "image/png";
          outExt = "png";
        }

        const maxDim = 1600;
        const quality = 0.82;

        yieldToUI()
          .then(function () {
            // createImageBitmap ×× ×§×™×™× (××”×™×¨ ×‘×”×¨×‘×” ××›××” WebViews)
            if (typeof createImageBitmap === "function") {
              return createImageBitmap(file)
                .then((bmp) => ({ kind: "bitmap", src: bmp }))
                .catch(() => ({ kind: "img", src: null }));
            }
            return { kind: "img", src: null };
          })
          .then(function (decoded) {
            if (decoded && decoded.kind === "bitmap" && decoded.src) return decoded;

            // fallback: Image() ×¢× ObjectURL/DataURL
            return new Promise(function (resolveImg) {
              getPreviewUrlForFile(file, function (srcUrl, canRevoke) {
                if (!srcUrl) { resolveImg({ kind: "fail" }); return; }
                const img = new Image();
                img.onload = function () {
                  try { if (canRevoke && srcUrl) URL.revokeObjectURL(srcUrl); } catch {}
                  resolveImg({ kind: "img", src: img });
                };
                img.onerror = function () {
                  try { if (canRevoke && srcUrl) URL.revokeObjectURL(srcUrl); } catch {}
                  resolveImg({ kind: "fail" });
                };
                img.src = srcUrl;
              });
            });
          })
          .then(function (decoded) {
            try {
              if (!decoded || decoded.kind === "fail" || !decoded.src) {
                resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });
                return;
              }

              let w = 0, h = 0;
              if (decoded.kind === "bitmap") {
                w = decoded.src.width || 0;
                h = decoded.src.height || 0;
              } else {
                w = decoded.src.naturalWidth || decoded.src.width || 0;
                h = decoded.src.naturalHeight || decoded.src.height || 0;
              }

              if (!w || !h) {
                try { if (decoded.kind === "bitmap" && decoded.src && decoded.src.close) decoded.src.close(); } catch {}
                resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });
                return;
              }

              // ×× ×›×‘×¨ ×§×˜×Ÿ + ×œ× ×›×‘×“ ××“×™ â€“ ×œ× ××›×•×•×¦×™×
              if (Math.max(w, h) <= maxDim && size < (2.2 * 1024 * 1024)) {
                setStatus("×”×ª××•× ×” ×ª×•×¢×œ×” ×›×¤×™ ×©×”×™× (××™×Ÿ ×¦×•×¨×š ×‘×›×™×•×•×¥).", "info");
                try { if (decoded.kind === "bitmap" && decoded.src && decoded.src.close) decoded.src.close(); } catch {}
                resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });
                return;
              }

              let scale = 1;
              if (w > maxDim || h > maxDim) scale = Math.min(maxDim / w, maxDim / h);
              const nw = Math.max(1, Math.round(w * scale));
              const nh = Math.max(1, Math.round(h * scale));

              const canvas = document.createElement("canvas");
              canvas.width = nw;
              canvas.height = nh;
              const ctx = canvas.getContext("2d");
              if (!ctx) {
                try { if (decoded.kind === "bitmap" && decoded.src && decoded.src.close) decoded.src.close(); } catch {}
                resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });
                return;
              }

              ctx.imageSmoothingEnabled = true;
              try { ctx.imageSmoothingQuality = "high"; } catch {}

              // ×× ×™×—×¡ ×”×§×˜× ×” ×’×“×•×œ â€“ ×¦×™×•×¨ ×‘×©× ×™ ×©×œ×‘×™× (×™×¦×™×‘ ×™×•×ª×¨)
              const ratio = Math.max(w / nw, h / nh);
              if (ratio > 2.2) {
                const midW = Math.max(nw, Math.round(w / 2));
                const midH = Math.max(nh, Math.round(h / 2));
                const tmp = document.createElement("canvas");
                tmp.width = midW;
                tmp.height = midH;
                const tctx = tmp.getContext("2d");
                if (tctx) {
                  tctx.imageSmoothingEnabled = true;
                  try { tctx.imageSmoothingQuality = "high"; } catch {}
                  tctx.drawImage(decoded.src, 0, 0, midW, midH);
                  ctx.drawImage(tmp, 0, 0, nw, nh);
                } else {
                  ctx.drawImage(decoded.src, 0, 0, nw, nh);
                }
              } else {
                ctx.drawImage(decoded.src, 0, 0, nw, nh);
              }

              try { if (decoded.kind === "bitmap" && decoded.src && decoded.src.close) decoded.src.close(); } catch {}

              yieldToUI().then(function () {
                canvasToBlobSafe(canvas, outType, quality, function (blob) {
                  try {
                    if (!blob) {
                      resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });
                      return;
                    }

                    // ×× ×™×¦× ×’×“×•×œ ×™×•×ª×¨ ××”××§×•×¨ â€“ ××©××™×¨×™× ××§×•×¨
                    try {
                      if (Number(blob.size || 0) >= Number(file.size || 0)) {
                        resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });
                        return;
                      }
                    } catch {}

                    setStatus("×‘×•×¦×¢×” ××•×¤×˜×™××™×–×¦×™×” ×œ×ª××•× ×” ×›×“×™ ×œ×”××™×¥ ×˜×¢×™× ×”.", "ok");
                    resolve({ blob: blob, contentType: outType, ext: outExt });
                  } catch {
                    resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });
                  }
                });
              });

            } catch {
              try { if (decoded.kind === "bitmap" && decoded.src && decoded.src.close) decoded.src.close(); } catch {}
              resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });
            }
          })
          .catch(function () {
            resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });
          });

      } catch {
        const origName = safeText(file && file.name ? file.name : "");
        let ext = "jpg";
        if (origName.includes(".")) ext = origName.split(".").pop().toLowerCase();
        resolve({ blob: file, contentType: (file && file.type) ? file.type : "application/octet-stream", ext: ext || "jpg" });
      }
    })();
  });
}

function uploadBlobToStorage(blobOrFile, storagePath, contentType, onProgress) {
  return new Promise(function (resolve, reject) {
    try {
      if (!blobOrFile || !storagePath) { reject("missing"); return; }

      const ref = firebase.storage().ref(storagePath);
      const meta = {};
      const ct = String(contentType || "").trim();
      if (ct) meta.contentType = ct;

      let task = null;
      try {
        task = ref.put(blobOrFile, meta);
      } catch {
        task = null;
      }

      if (task) {
        task.on("state_changed",
          function (snap) {
            try {
              const bytes = Number(snap.bytesTransferred || 0);
              const total = Number(snap.totalBytes || 0);
              if (total > 0 && typeof onProgress === "function") {
                onProgress(Math.round((bytes / total) * 100));
              }
            } catch {}
          },
          function (err) { reject(err); },
          function () {
            // âœ… ×‘××§×•× getDownloadURL() ××—×–×™×¨×™× ××ª ×”× ×ª×™×‘
            resolve(storagePath);
          }
        );
        return;
      }

      // fallback: data_url
      readBlobAsDataURLWithRetry(blobOrFile, 3, function (durl, ok) {
        if (!ok) { reject("read_failed"); return; }

        const task2 = ref.putString(durl, "data_url");
        task2.on("state_changed",
          function (snap) {
            try {
              const bytes = Number(snap.bytesTransferred || 0);
              const total = Number(snap.totalBytes || 0);
              if (total > 0 && typeof onProgress === "function") {
                onProgress(Math.round((bytes / total) * 100));
              }
            } catch {}
          },
          function (err) { reject(err); },
          function () {
            // âœ… ×’× ×¤×”: ××—×–×™×¨×™× × ×ª×™×‘
            resolve(storagePath);
          }
        );
      });

    } catch (e0) {
      reject(e0);
    }
  });
}


  /* =====================================================================================
     CRITICAL: Update lastCommentTime for forum sort (includes replies)
     - ×–×” ××” ×©×’×•×¨× ×œ×¤×•×¡×˜ ×œ×§×¤×•×¥ ×‘××™×•×Ÿ "×ª×’×•×‘×” ××—×¨×•× ×”" ×‘×¤×•×¨×•×
     - ×œ× × ×•×’×¢ ×‘×¡×¤×™×¨×ª ×ª×’×•×‘×•×ª (commentsCount × ×©××¨ ×¨×§ ×œ×ª×’×•×‘×•×ª, ×œ× ×œ×¨×™×¤×œ×™×™×–)
     ===================================================================================== */
  function bumpPostLastCommentTime(ts) {
    try {
      const t = Number(ts || 0) || nowTs();
      firebase.database().ref("posts/" + postId + "/lastCommentTime").set(t);
    } catch {}
  }

  function incrementPostCommentsCount() {
    try {
      // count ONLY comments (not replies) => aligns with your request
      firebase.database().ref("posts/" + postId + "/commentsCount").transaction(function (cur) {
        const x = Number(cur || 0) || 0;
        return x + 1;
      });
    } catch {}
  }

  /* =====================================================================================
     Send reply (now supports optional image + bumps lastCommentTime)
     ===================================================================================== */
  function sendReply(commentId) {
    if (!isAuthed) return;

    const ta = document.getElementById("reply-textarea-" + commentId);
    if (!ta) return;

    replyErrorHide(commentId);

    const raw = safeText(ta.value).trim();
    if (!raw && !(replyImageState[commentId] && replyImageState[commentId].file)) {
      replyErrorShow(commentId, "×›×ª×•×‘ ××©×”×• ××• ×¦×¨×£ ×ª××•× ×”.");
      return;
    }

    if (replySendingMap[commentId]) return;
    replySendingMap[commentId] = true;

    const text = clampTextLen(raw, 600);
    const replyRef = firebase.database().ref("replies/" + postId + "/" + commentId).push();
    const replyId = replyRef.key;

    const st = replyImageState[commentId] ? replyImageState[commentId] : null;
    const file = st && st.file ? st.file : null;

 const finishWrite = function (imagePath) {
  const obj = {
    text: text,
    author: username,
    time: nowTs(),
    authorUid: uid || ""
  };

  if (imagePath) obj.imagePath = String(imagePath);

  return replyRef.set(obj);
};

    // if image: upload first
    let chain = Promise.resolve("");

  if (file) {
  if (!isLikelyImageFile(file) || Number(file.size || 0) > MAX_IMG) {
    replyErrorShow(commentId, "×”×ª××•× ×” ×œ× ×ª×§×™× ×” ××• ×’×“×•×œ×” ××“×™. ×‘×—×¨ ××—×“×©.");
    clearReplyImage(commentId, true);
    replySendingMap[commentId] = false;
    return;
  }

  setStatus("××›×™×Ÿ ×ª××•× ×” ×œ×¨×™×¤×œ×™×™â€¦", "info");

  chain = prepareImageForUpload(file)
    .then(function (prep) {
      const blob = prep && prep.blob ? prep.blob : file;
      const ct = prep && prep.contentType ? prep.contentType : (file.type || "application/octet-stream");
      const ext = prep && prep.ext ? prep.ext : (safeText(file.name || "").includes(".") ? safeText(file.name).split(".").pop().toLowerCase() : "jpg");

      const name = nowTs() + "_" + (uid || "u") + "." + (ext || "jpg");
      const path = "reply-images/" + postId + "/" + commentId + "/" + replyId + "/" + name;

      setStatus("××¢×œ×” ×ª××•× ×” ×œ×¨×™×¤×œ×™×™â€¦", "info");

    return uploadBlobToStorage(blob, path, ct, function () {})
  .then(function (returnedPath) {
    setStatus("×©×•××¨ ×ª×’×•×‘×”â€¦", "info");
    return returnedPath; // ×–×” ×”× ×ª×™×‘
  });

    });
}


    chain
      .then(function (url) {
        return finishWrite(url || "");
      })
      .then(() => {
        ta.value = "";
        clearReplyImage(commentId, true);

        updateReplyCount(commentId);

        // THIS is the key for forum sorting:
        bumpPostLastCommentTime(nowTs());

        // refresh open box gently
        if (repliesOpenState[commentId]) {
          toggleReplies(commentId);
          setTimeout(() => toggleReplies(commentId), 50);
        }

        setStatus("× ×©×œ×— ×¨×™×¤×œ×™×™.", "ok");
      })
      .catch((err) => {
        const code = err && err.code ? String(err.code) : "";
        const msg = err && err.message ? String(err.message) : String(err || "");
        const finalMsg = "×©×’×™××” ×‘×©×œ×™×—×ª ×¨×™×¤×œ×™×™: " + (msg || "×œ× ×™×“×•×¢");
        replyErrorShow(commentId, finalMsg);
        setStatus("××™×¨×¢×” ×©×’×™××” ×‘×©×œ×™×—×ª ×”×¨×™×¤×œ×™×™.", "error");
      })
      .finally(() => {
        replySendingMap[commentId] = false;
      });
  }

  /* =====================================================================================
     Main comment send (×›×•×œ×œ ×ª××•× ×”) + bump lastCommentTime + increment commentsCount
     ===================================================================================== */
 function sendMain() {
  if (!isAuthed) return;

  const raw = safeText(mainText.value).trim();

  if (!raw && !mainCommentImageFile) {
    setStatus("×›×ª×•×‘ ×ª×’×•×‘×” ××• ×¦×¨×£ ×ª××•× ×”.", "warn");
    return;
  }

  if (mainSending) return;
  mainSending = true;

  sendMainBtn.disabled = true;

  const text = clampTextLen(raw, MAIN_MAX);

  const commentRef = firebase.database().ref("comments/" + postId).push();
  const commentId = commentRef.key;

 const finishWrite = function (imagePath) {
  const obj = {
    text: text,
    author: username,
    time: nowTs(),
    authorUid: uid || ""
  };

  if (imagePath) obj.imagePath = String(imagePath);

  return commentRef.set(obj);
};

  let chain = Promise.resolve("");

  if (mainCommentImageFile) {
    const f = mainCommentImageFile;

    if (!isLikelyImageFile(f) || Number(f.size || 0) > MAX_IMG) {
      setStatus("×”×ª××•× ×” ×œ× ×ª×§×™× ×” ××• ×’×“×•×œ×” ××“×™. ×‘×—×¨ ××—×“×©.", "error");
      clearMainCommentImage(true);
      sendMainBtn.disabled = false;
      mainSending = false;
      return;
    }

    setStatus("××›×™×Ÿ ×ª××•× ×” ×œ×”×¢×œ××”â€¦", "info");

    chain = prepareImageForUpload(f)
      .then(function (prep) {
        const blob = prep && prep.blob ? prep.blob : f;
        const ct = prep && prep.contentType ? prep.contentType : (f.type || "application/octet-stream");
        const ext = prep && prep.ext ? prep.ext : (safeText(f.name || "").includes(".") ? safeText(f.name).split(".").pop().toLowerCase() : "jpg");

        const name = nowTs() + "_" + (uid || "u") + "." + (ext || "jpg");
        const path = "comment-images/" + postId + "/" + commentId + "/" + name;

        setStatus("××¢×œ×” ×ª××•× ×” ×œ×ª×’×•×‘×”â€¦", "info");

        return uploadBlobToStorage(blob, path, ct, function () {})
  .then(function (returnedPath) {
    setStatus("×©×•××¨ ×ª×’×•×‘×”â€¦", "info");
    return returnedPath; // ×–×” ×”× ×ª×™×‘
  });

      });
  }

  chain
    .then(function (url) {
      return finishWrite(url || "");
    })
    .then(() => {
      closeMain();

      // key for forum sorting:
      bumpPostLastCommentTime(nowTs());

      // count ONLY comments (not replies)
      incrementPostCommentsCount();

      // keep existing behavior
      loadComments(false, false);
      setStatus("×ª×’×•×‘×” × ×©×œ×—×”.", "ok");
    })
.catch((err) => {
  const code = err && err.code ? String(err.code) : "";
  const msg  = err && err.message ? String(err.message) : String(err || "");
  setStatus("×©×’×™××” ×‘×©×œ×™×—×ª ×ª×’×•×‘×”: " + (code ? code + " - " : "") + msg, "error");
})

    .finally(() => {
      mainSending = false;
      sendMainBtn.disabled = false;
    });
}

  /* =====================================================================================
     Inline edit â€“ COMMENT (NEW)
     ===================================================================================== */
  function beginInlineEditComment(commentId) {
    try {
      const cid = safeText(commentId || "");
      if (!cid) return;

      // find comment in cache to validate permission
      const c = commentsCache.find(x => x.id === cid);
      if (!c) return;

      if (!canEditItem(c.author, c.authorUid, c.time)) {
        setStatus("××™×Ÿ ×”×¨×©××” ×œ×¢×¨×•×š ×ª×’×•×‘×” (×¨×§ ×”××—×‘×¨ ×•×¢×“ 24 ×©×¢×•×ª).", "error");
        return;
      }

      const commentNode = commentsBox.querySelector('.comment[data-comment-id="' + cid + '"]');
      if (!commentNode) return;

      // avoid duplicate editor
      if (commentNode.querySelector(".inline-edit-box")) return;

      const textEl = commentNode.querySelector(".comment-text");
      const oldText = textEl ? safeText(textEl.innerText || "") : safeText(c.text || "");

      const box = document.createElement("div");
      box.className = "inline-edit-box";
      box.innerHTML = `
        <div style="font-weight:bold; margin-bottom:8px;">×¢×¨×™×›×ª ×ª×’×•×‘×”</div>
        <textarea id="edit-comment-ta-${escapeHTML(cid)}" rows="4" maxlength="800">${escapeHTML(oldText)}</textarea>
        <div style="margin-top:10px; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center;">
          <small style="opacity:.75;">××§×¡×™××•× 800 ×ª×•×•×™×.</small>
          <div style="display:flex; gap:10px;">
            <button type="button" data-inline-action="saveCommentEdit" data-id="${escapeHTML(cid)}"
              style="padding:8px 12px;border-radius:10px;border:none;background:rgb(17,17,87);color:#fff;cursor:pointer;font-weight:bold;">×©××•×¨</button>
            <button type="button" data-inline-action="cancelCommentEdit" data-id="${escapeHTML(cid)}"
              style="padding:8px 12px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;font-weight:bold;">×‘×™×˜×•×œ</button>
          </div>
        </div>
        <div id="edit-comment-err-${escapeHTML(cid)}" style="display:none;margin-top:10px;padding:10px 12px;border-radius:12px;background:rgba(255,0,0,0.08);color:#8a0000;font-size:13px;"></div>
      `;

      commentNode.appendChild(box);

      setTimeout(() => {
        try {
          const ta = document.getElementById("edit-comment-ta-" + cid);
          ta && ta.focus();
        } catch {}
      }, 50);

    } catch {}
  }

  /* =====================================================================================
     Inline edit â€“ REPLY (NEW)
     ===================================================================================== */
  function beginInlineEditReply(commentId, replyId) {
    try {
      const cid = safeText(commentId || "");
      const rid = safeText(replyId || "");
      if (!cid || !rid) return;

      // find reply node
      const repliesBox = document.getElementById("replies-" + cid);
      if (!repliesBox) return;

      // locate reply
      const replyNode = repliesBox.querySelector('.reply[data-reply-id="' + rid + '"]');
      if (!replyNode) return;

      // avoid duplicate editor
      if (replyNode.querySelector(".inline-edit-box")) return;

      // permission: fetch reply once (selective)
      firebase.database()
        .ref("replies/" + postId + "/" + cid + "/" + rid)
        .once("value")
        .then((snap) => {
          if (!snap.exists()) return;

          const d = snap.val() || {};
          const author = safeText(d.author || "");
          const authorUid = safeText(d.authorUid || "");
          const t = Number(d.time || 0);

          if (!canEditItem(author, authorUid, t)) {
            setStatus("××™×Ÿ ×”×¨×©××” ×œ×¢×¨×•×š ×¨×™×¤×œ×™×™ (×¨×§ ×”××—×‘×¨ ×•×¢×“ 24 ×©×¢×•×ª).", "error");
            return;
          }

          const textEl = replyNode.querySelector(".reply-text");
          const oldText = textEl ? safeText(textEl.innerText || "") : safeText(d.text || "");

          const box = document.createElement("div");
          box.className = "inline-edit-box";
          box.innerHTML = `
            <div style="font-weight:bold; margin-bottom:8px;">×¢×¨×™×›×ª ×¨×™×¤×œ×™×™</div>
            <textarea id="edit-reply-ta-${escapeHTML(cid)}-${escapeHTML(rid)}" rows="4" maxlength="600">${escapeHTML(oldText)}</textarea>
            <div style="margin-top:10px; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center;">
              <small style="opacity:.75;">××§×¡×™××•× 600 ×ª×•×•×™×.</small>
              <div style="display:flex; gap:10px;">
                <button type="button" data-inline-action="saveReplyEdit" data-comment-id="${escapeHTML(cid)}" data-reply-id="${escapeHTML(rid)}"
                  style="padding:8px 12px;border-radius:10px;border:none;background:rgb(17,17,87);color:#fff;cursor:pointer;font-weight:bold;">×©××•×¨</button>
                <button type="button" data-inline-action="cancelReplyEdit" data-comment-id="${escapeHTML(cid)}" data-reply-id="${escapeHTML(rid)}"
                  style="padding:8px 12px;border-radius:10px;border:1px solid rgba(0,0,0,0.15);background:#fff;cursor:pointer;font-weight:bold;">×‘×™×˜×•×œ</button>
              </div>
            </div>
            <div id="edit-reply-err-${escapeHTML(cid)}-${escapeHTML(rid)}" style="display:none;margin-top:10px;padding:10px 12px;border-radius:12px;background:rgba(255,0,0,0.08);color:#8a0000;font-size:13px;"></div>
          `;

          replyNode.appendChild(box);

          setTimeout(() => {
            try {
              const ta = document.getElementById("edit-reply-ta-" + cid + "-" + rid);
              ta && ta.focus();
            } catch {}
          }, 50);

        })
        .catch(() => {});
    } catch {}
  }

  /* =====================================================================================
     Inline edit delegation (comment + reply)
     ===================================================================================== */
  (function bindInlineEditDelegation() {
    if (commentsBox.__inlineEditBound) return;
    commentsBox.__inlineEditBound = true;

    commentsBox.addEventListener("click", function (e) {
      const el = e.target.closest("[data-inline-action]");
      if (!el) return;

      const act = el.getAttribute("data-inline-action");

      if (act === "cancelCommentEdit") {
        const id = el.getAttribute("data-id");
        const node = commentsBox.querySelector('.comment[data-comment-id="' + id + '"]');
        if (!node) return;
        const box = node.querySelector(".inline-edit-box");
        if (box) box.remove();
      }

      if (act === "saveCommentEdit") {
        const id = el.getAttribute("data-id");
        const ta = document.getElementById("edit-comment-ta-" + id);
        const err = document.getElementById("edit-comment-err-" + id);
        if (!ta) return;

        const newText = safeText(ta.value).trim();
        if (newText.length < 1) {
          if (err) { err.style.display = "block"; err.textContent = "×”×˜×§×¡×˜ ×¨×™×§."; }
          return;
        }

        // permission re-check (selective)
        const c = commentsCache.find(x => x.id === id);
        if (!c || !canEditItem(c.author, c.authorUid, c.time)) {
          setStatus("××™×Ÿ ×”×¨×©××” ×œ×¢×¨×•×š ×ª×’×•×‘×”.", "error");
          return;
        }

        setStatus("×©×•××¨ ×¢×¨×™×›×ª ×ª×’×•×‘×”â€¦", "info");

        firebase.database()
          .ref("comments/" + postId + "/" + id)
          .update({ text: clampTextLen(newText, 800) })
          .then(() => {
            setStatus("×”×ª×’×•×‘×” ×¢×•×“×›× ×”.", "ok");
            // local cache update
            const idx = commentsCache.findIndex(x => x.id === id);
            if (idx !== -1) commentsCache[idx].text = clampTextLen(newText, 800);
            renderCommentsFromCache();
          })
          .catch(() => {
            if (err) { err.style.display = "block"; err.textContent = "×©×’×™××” ×‘×©××™×¨×”. × ×¡×” ×©×•×‘."; }
            setStatus("×©×’×™××” ×‘×©××™×¨×”.", "error");
          });
      }

      if (act === "cancelReplyEdit") {
        const cid = el.getAttribute("data-comment-id");
        const rid = el.getAttribute("data-reply-id");
        const box = commentsBox.querySelector('.reply[data-reply-id="' + rid + '"] .inline-edit-box');
        if (box) box.remove();
      }

      if (act === "saveReplyEdit") {
        const cid = el.getAttribute("data-comment-id");
        const rid = el.getAttribute("data-reply-id");
        const ta = document.getElementById("edit-reply-ta-" + cid + "-" + rid);
        const err = document.getElementById("edit-reply-err-" + cid + "-" + rid);
        if (!ta) return;

        const newText = safeText(ta.value).trim();
        if (newText.length < 1) {
          if (err) { err.style.display = "block"; err.textContent = "×”×˜×§×¡×˜ ×¨×™×§."; }
          return;
        }

        setStatus("×©×•××¨ ×¢×¨×™×›×ª ×¨×™×¤×œ×™×™â€¦", "info");

        // permission re-check by read (selective)
        firebase.database()
          .ref("replies/" + postId + "/" + cid + "/" + rid)
          .once("value")
          .then((snap) => {
            if (!snap.exists()) throw new Error("missing");
            const d = snap.val() || {};
            if (!canEditItem(d.author, d.authorUid, d.time)) throw new Error("no_perm");

            return firebase.database()
              .ref("replies/" + postId + "/" + cid + "/" + rid)
              .update({ text: clampTextLen(newText, 600) });
          })
          .then(() => {
            setStatus("×”×¨×™×¤×œ×™×™ ×¢×•×“×›×Ÿ.", "ok");
            // refresh replies box gently
            if (repliesOpenState[cid]) {
              toggleReplies(cid);
              setTimeout(() => toggleReplies(cid), 50);
            }
          })
          .catch(() => {
            if (err) { err.style.display = "block"; err.textContent = "×©×’×™××” ×‘×©××™×¨×” ××• ××™×Ÿ ×”×¨×©××”."; }
            setStatus("×©×’×™××” ×‘×©××™×¨×”.", "error");
          });
      }

    }, false);
  })();

  /* =====================================================================================
     Live comments (×©×“×¨×•×’)
     - ×ª×•××š ×’× ×‘×ª××•× ×” ×œ×©×™× ×•×™×™×/×”×•×¡×¤×•×ª
     ===================================================================================== */
  function attachLiveComments() {
    if (liveCommentsAttached) return;
    liveCommentsAttached = true;

    liveCommentsRef = firebase.database()
      .ref("comments/" + postId)
      .orderByChild("time")
      .limitToLast(50);

    liveCommentsRef.on("child_added", (snap) => {
      const id = snap.key;
      const v = snap.val() || {};

      if (commentsCache.some((x) => x.id === id)) return;

     commentsCache.push({
  id,
  text: safeText(v.text),
  author: safeText(v.author),
  authorUid: safeText(v.authorUid || ""),
  time: Number(v.time || 0),

  imagePath: safeText(v.imagePath || "").trim(),   // âœ… ×—×“×©
  image: sanitizeImageUrl(v.image || "")           // âœ… legacy
});


      renderCommentsFromCache();
    });

    liveCommentsRef.on("child_changed", (snap) => {
      const id = snap.key;
      const v = snap.val() || {};

      const idx = commentsCache.findIndex((x) => x.id === id);
      if (idx === -1) return;

      commentsCache[idx] = {
  ...commentsCache[idx],
  text: safeText(v.text),
  author: safeText(v.author),
  authorUid: safeText(v.authorUid || commentsCache[idx].authorUid || ""),
  time: Number(v.time || commentsCache[idx].time || 0),

  imagePath: safeText(v.imagePath || commentsCache[idx].imagePath || "").trim(), // âœ…
  image: sanitizeImageUrl(v.image || commentsCache[idx].image || "")             // âœ… legacy
};


      renderCommentsFromCache();
    });
  }

  /* =====================================================================================
     Live replies (×¨×§ ×›×©×”×ª×™×‘×” ×¤×ª×•×—×”)
     + bind reply image input on open
     ===================================================================================== */
  function attachRepliesLive(commentId) {
    if (repliesLiveAttached[commentId]) return;
    repliesLiveAttached[commentId] = true;

    // ensure reply image input is bound for this open box
    bindReplyImageInput(commentId);

    const ref = firebase.database()
      .ref("replies/" + postId + "/" + commentId)
      .orderByChild("time")
      .limitToLast(25);

    repliesLiveRefs[commentId] = ref;

    ref.on("child_added", (snap) => {
      if (!repliesOpenState[commentId]) return;

      updateReplyCount(commentId);

      const box = document.getElementById("replies-" + commentId);
      if (!box) return;

      const active = document.activeElement;
      const isTypingHere = active && active.id === ("reply-textarea-" + commentId);
      if (isTypingHere) return;

      try {
        box.classList.add("hidden");
        repliesOpenState[commentId] = false;
        toggleReplies(commentId);
      } catch {}
    });
  }

  function detachRepliesLive(commentId) {
    try {
      const ref = repliesLiveRefs[commentId];
      if (ref) ref.off();
    } catch {}
    repliesLiveRefs[commentId] = null;
    repliesLiveAttached[commentId] = false;
  }

  /* =====================================================================================
     DISABLED: Report comment / reply (per request)
     - kept as code (length) but not used
     ===================================================================================== */
  function reportComment(commentId) {
    // DISABLED
    // if (!isAuthed || !uid) { setStatus("×œ× ×××•××ª. ×œ× × ×™×ª×Ÿ ×œ×“×•×•×—.", "error"); return; }
    // firebase.database().ref("reports").push({ type:"comment", postId, commentId, reporterUid:uid, reporterName:username, time:nowTs(), reason:"report" })
    //   .then(() => setStatus("×“×•×•×— ×‘×”×¦×œ×—×”.", "ok"))
    //   .catch(() => setStatus("×©×’×™××” ×‘×“×™×•×•×—.", "error"));
  }

  function reportReply(commentId, replyId) {
    // DISABLED
    // if (!isAuthed || !uid) { setStatus("×œ× ×××•××ª. ×œ× × ×™×ª×Ÿ ×œ×“×•×•×—.", "error"); return; }
    // firebase.database().ref("reports").push({ type:"reply", postId, commentId, replyId, reporterUid:uid, reporterName:username, time:nowTs(), reason:"report" })
    //   .then(() => setStatus("×“×•×•×— ×‘×”×¦×œ×—×”.", "ok"))
    //   .catch(() => setStatus("×©×’×™××” ×‘×“×™×•×•×—.", "error"));
  }

  /* =====================================================================================
     Cleanup on unload (×©×“×¨×•×’ ×™×¦×™×‘×•×ª)
     ===================================================================================== */
  window.addEventListener("beforeunload", () => {
    try {
      if (liveCommentsRef) liveCommentsRef.off();
    } catch {}
    liveCommentsAttached = false;

    for (const k in repliesLiveRefs) {
      try {
        if (repliesLiveRefs[k]) repliesLiveRefs[k].off();
      } catch {}
    }
  });

});
</script>

</body>
</html>
