<!DOCTYPE html>                    <html lang="he">                    
<head>                    
  <meta charset="UTF-8">                    
  <meta name="viewport" content="width=device-width, initial-scale=1.0">                    
  <title>×¤×•×¨×•× ×××•×‘×˜×—</title>                      <!-- Firebase -->                      <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>                      <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>                      <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>                      <script src="firebaseConfig.js"></script>                      <link rel="stylesheet" href="css/forum.css">                      <style>                    
    /* NOTE: ×œ×¤×™ ×”×‘×§×©×” ×©×œ×š â€“ ×‘×œ×™ ×”×”× ×¤×©×” ×”×”×™× */                    
    /* ×× ×ª×¨×¦×” ××¤×§×˜ ×¢×“×™×Ÿ ××—×¨ ×‘×”××©×š â€“ × ×¢×©×”, ××‘×œ ×›×¨×’×¢ "××¤×¡ ×× ×™××¦×™×•×ª" */                    
        
    /* =====================================================================================          
       Image support - minimal inlined safety styles (doesn't replace your css/forum.css)          
       ===================================================================================== */          
    .post-image-wrap {          
      margin-top: 10px;          
      border-radius: 12px;          
      overflow: hidden;          
      border: 1px solid rgba(0,0,0,0.12);          
      background: rgba(0,0,0,0.03);          
    }          
    .post-image {          
      width: 100%;          
      height: auto;          
      display: block;          
      max-height: 360px;          
      object-fit: cover;          
      background: #fff;          
    }          
    .image-chip {          
      display: inline-flex;          
      align-items: center;          
      gap: 6px;          
      padding: 6px 10px;          
      border-radius: 999px;          
      border: 1px solid rgba(0,0,0,0.12);          
      background: rgba(0,0,0,0.03);          
      font-size: 12px;          
      opacity: 0.9;          
      user-select: none;          
    }          
    .image-actions-row {          
      display: flex;          
      gap: 10px;          
      flex-wrap: wrap;          
      align-items: center;          
      justify-content: space-between;          
    }          
    .img-btn {          
      padding: 10px 12px;          
      border-radius: 12px;          
      border: 1px solid rgba(0,0,0,0.18);          
      background: #fff;          
      cursor: pointer;          
      font-weight: bold;          
    }          
    .img-btn-primary {          
      border: none;          
      background: rgb(17,17,87);          
      color: #fff;          
    }          
    .img-btn-danger {          
      border: 1px solid rgba(255,0,0,0.35);          
      background: rgba(255,0,0,0.06);          
      color: #8a0000;          
    }          
    .img-preview {          
      width: 100%;          
      border-radius: 12px;          
      border: 1px solid rgba(0,0,0,0.12);          
      overflow: hidden;          
      background: rgba(0,0,0,0.03);          
    }          
    .img-preview img {          
      width: 100%;          
      height: auto;          
      display: block;          
      max-height: 320px;          
      object-fit: cover;          
      background: #fff;          
    }          
    .progress-wrap {          
      width: 100%;          
      height: 10px;          
      border-radius: 999px;          
      border: 1px solid rgba(0,0,0,0.12);          
      overflow: hidden;          
      background: rgba(0,0,0,0.04);          
    }          
    .progress-bar {          
      height: 100%;          
      width: 0%;          
      background: rgb(17,17,87);          
    }          
        
    /* Fullscreen image viewer overlay (no animation) */          
    #imageViewerOverlay {          
      position: fixed;          
      inset: 0;          
      background: rgba(0,0,0,0.78);          
      display: none;          
      align-items: center;          
      justify-content: center;          
      padding: 16px;          
      box-sizing: border-box;          
      z-index: 10000;          
    }          
    #imageViewerInner {          
      width: min(920px, 100%);          
      background: rgba(255,255,255,0.96);          
      border-radius: 16px;          
      padding: 12px;          
      box-sizing: border-box;          
    }          
    #imageViewerInner img {          
      width: 100%;          
      height: auto;          
      display: block;          
      border-radius: 14px;          
      background: #fff;          
      border: 1px solid rgba(0,0,0,0.12);          
      max-height: 78vh;          
      object-fit: contain;          
    }          
    #imageViewerTop {          
      display: flex;          
      align-items: center;          
      justify-content: space-between;          
      gap: 10px;          
      margin-bottom: 10px;          
    }          
    #closeImageViewer {          
      border: none;          
      background: transparent;          
      font-size: 18px;          
      cursor: pointer;          
      padding: 8px 10px;          
      border-radius: 10px;          
    }          
        
    /* =====================================================================================          
       Forum UI extra (requested changes)          
       ===================================================================================== */          
    .post-user-border {          
      border-right: 4px solid rgba(0,0,0,0.15);          
      padding-right: 12px;          
      box-sizing: border-box;          
    }          
        
    .post-meta-row {          
      margin-top: 8px;          
      display: flex;          
      align-items: flex-end;          
      justify-content: space-between;          
      gap: 10px;          
      flex-wrap: wrap;          
      /* important: keep visual "left/right" stable */          
      direction: ltr;          
    }          
        
    .post-meta-left {          
      display: flex;          
      flex-direction: column;          
      align-items: flex-start;          
      gap: 6px;          
      min-width: 140px;          
    }          
        
    .post-meta-right {          
      display: flex;          
      flex-direction: column;          
      align-items: flex-end;          
      gap: 6px;          
      min-width: 140px;          
    }          
        
    /* "×™×© ×ª××•× ×”" chip - blue as requested */          
    .has-image-flag {          
      display: inline-flex;          
      align-items: center;          
      gap: 6px;          
      padding: 6px 10px;          
      border-radius: 999px;          
      border: 1px solid rgba(17,17,87,0.18);          
      background: rgba(17,17,87);          
      color: white;          
      font-size: 12px;          
      font-weight: bold;          
      user-select: none;          
      white-space: nowrap;          
      cursor: pointer;          
    }          
        
    .has-image-flag:active {          
      opacity: .92;          
    }          
        
    .post-author-colored {          
      font-weight: normal;          
    }          
        
    /* =====================================================================================          
       NEW: Mini image preview overlay (requested: small preview with X)          
       ===================================================================================== */          
    #miniImageOverlay {          
      position: fixed;          
      inset: 0;          
      background: rgba(0,0,0,0.55);          
      display: none;          
      align-items: center;          
      justify-content: center;          
      padding: 16px;          
      box-sizing: border-box;          
      z-index: 12000;          
    }          
    #miniImageInner {          
      width: min(520px, 100%);          
      background: rgba(255,255,255,0.98);          
      border-radius: 16px;          
      padding: 12px;          
      box-sizing: border-box;          
      border: 1px solid rgba(0,0,0,0.12);          
    }          
    #miniImageTop {          
      display: flex;          
      align-items: center;          
      justify-content: space-between;          
      gap: 10px;          
      margin-bottom: 10px;          
    }          
    #miniCloseBtn {          
      border: none;          
      background: transparent;          
      font-size: 18px;          
      cursor: pointer;          
      padding: 8px 10px;          
      border-radius: 10px;          
    }          
    #miniPreviewImg {          
      width: 100%;          
      height: auto;          
      display: block;          
      border-radius: 14px;          
      border: 1px solid rgba(0,0,0,0.12);          
      background: #fff;          
      max-height: 62vh;          
      object-fit: contain;          
    }          
    #miniHint {          
      margin-top: 8px;          
      font-size: 12px;          
      opacity: .75;          
      text-align: center;          
    }          
  </style>                   <header class="top-bar">
  <!-- Hamburger (×™××™×Ÿ) -->
  <button id="hamburgerBtn" class="hamburger-btn" type="button"
          aria-label="×¤×ª×— ×ª×¤×¨×™×˜" aria-expanded="false">
    <span class="hamburger-lines" aria-hidden="true">
      <span></span><span></span><span></span>
    </span>
  </button>

  <!-- Title (× ×©××¨ ×××•×¨×›×–) -->
  <h1 class="coteret">×¤×•×¨×•× ×”×‘× ×™×™×“×™×</h1>

  <!-- Menu -->
  <nav id="headerMenu" class="header-menu" aria-label="×ª×¤×¨×™×˜ ×¢×œ×™×•×Ÿ">
    <a href="forum-expanded.html">×¤×•×¨×•× ×”×‘× ×™×™×“×™× ×”××•×¨×—×‘</a>
    <a href="forum B.html">×¤×•×¨×•× ×‘× ×™ ×“×•×“×™× ×©×›×•× ×”</a>
    <a href="about.html">××•×“×•×ª ×”×¤×•×¨×•×</a>
  </nav>
</header>

<!-- Backdrop ×œ×¡×’×™×¨×” ×‘×œ×—×™×¦×” ××—×•×¥ ×œ×ª×¤×¨×™×˜ -->
<div id="menuBackdrop" class="menu-backdrop" style="display:none;"></div>
                  <!-- Pull To Refresh indicator -->                    <div id="pull-indicator" style="                    
  display:none;                    
  text-align:center;                    
  padding:6px;                    
  user-select:none;                    
">                    
  <div class="loader"></div>                    
</div>                    <!-- ======= TOP ACTIONS (New Post + Search + Sort) ======= -->                    <div id="top-actions" style="                    
  max-width:900px;                    
  margin:auto;                    
  padding: 10px 20px 0 20px;                    
  box-sizing:border-box;                    
">                    
  <div style="                    
    display:flex;                    
    gap:10px;                    
    align-items:center;                    
    justify-content:space-between;                    
    flex-wrap:wrap;                    
  ">                    
    <button id="openCreatePost" type="button" style="                    
      padding:10px 12px;                    
      border-radius:10px;                    
      border:none;                    
      background: linear-gradient(135deg, rgb(17,17,87), rgb(32,32,140));                   
      color:#fff;                    
      cursor:pointer;                    
      font-weight:bold;                    
    ">â• ×¦×•×¨ ×¤×•×¡×˜</button>                    <input id="searchBox" type="search" placeholder="×—×™×¤×•×© ×‘×¤×•×¡×˜×™×..."                    
  style="                    
    flex:1;                    
    min-width:180px;                    
    padding:10px 12px;                    
    border-radius:10px;                    
    border:1px solid rgba(0,0,0,0.15);                    
    outline:none;                    
    box-sizing:border-box;                    
  "                    
/>                    
    
<select id="sortMode" style="                    
  padding:10px 12px;                    
  border-radius:10px;                    
  border:1px solid rgba(0,0,0,0.15);                    
  outline:none;                    
  background: #fff;                    
  cursor:pointer;                    
">                    
  <option value="lastComment" selected>××™×•×Ÿ: ×ª×’×•×‘×” ××—×¨×•× ×”</option>       
  <option value="newest">××™×•×Ÿ: ×”×—×“×©×™× ×œ××¢×œ×”</option>                    
  <option value="oldest">××™×•×Ÿ: ×”×™×©× ×™× ×œ××¢×œ×”</option>                    
  <option value="author">××™×•×Ÿ: ×œ×¤×™ ××—×‘×¨</option>                    
  <option value="title">××™×•×Ÿ: ×œ×¤×™ ×›×•×ª×¨×ª</option>                    
                    
</select>

  </div>                      <div id="statusBar" style="                    
    margin-top:10px;                    
    padding:8px 10px;                    
    border-radius:10px;                    
    background: rgba(0,0,0,0.04);                    
    color:#111;                    
    font-size:13px;                    
    display:none;                    
  "></div>                    
</div>                    <main class="forum-container">                    
  <div id="posts">                    
    <div class="loader"></div>                    
  </div>                    
</main>                    <!-- ======= CREATE POST MODAL (UI ONLY, AUTH STILL REQUIRED) ======= -->                    <div id="createPostOverlay" style="                    
  position:fixed;                    
  inset:0;                    
  background: rgba(0,0,0,0.45);                    
  display:none;                    
  align-items:center;                    
  justify-content:center;                    
  padding:16px;                    
  box-sizing:border-box;                    
  z-index:9999;                    
">                    
  <div id="createPostModal" style="                    
    width:min(720px, 100%);                    
    background:#fff;                    
    border-radius:16px;                    
    padding:16px;                    
    box-sizing:border-box;                    
  ">                    
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">                    
      <div style="font-weight:bold; font-size:18px;">×™×¦×™×¨×ª ×¤×•×¡×˜ ×—×“×©</div>                    
      <button id="closeCreatePost" type="button" style="                    
        border:none;                    
        background:transparent;                    
        font-size:18px;                    
        cursor:pointer;                    
      ">âœ•</button>                    
    </div>                    <div style="margin-top:12px; display:flex; flex-direction:column; gap:10px;">                    
  <input id="newPostTitle" type="text" placeholder="×›×•×ª×¨×ª"                    
    maxlength="80"                    
    style="                    
      padding:12px;                    
      border-radius:12px;                    
      border:1px solid rgba(0,0,0,0.18);                    
      outline:none;                    
      box-sizing:border-box;                    
    "                    
  />                    
    
  <textarea id="newPostText" placeholder="×ª×•×›×Ÿ ×”×¤×•×¡×˜..."                    
    rows="6"                    
    maxlength="2000"                    
    style="                    
      padding:12px;                    
      border-radius:12px;                    
      border:1px solid rgba(0,0,0,0.18);                    
      outline:none;                    
      box-sizing:border-box;                    
      resize:vertical;                    
    "                    
  ></textarea>                    
    
  <!-- =====================================================================================          
       IMAGE UPLOAD UI (×©×“×¨×•×’ ××œ× - ×œ× ×¤×•×’×¢ ×‘×©×™×˜×” / ×œ× ××•×¨×™×“ ×©×•× ×¤×™×¦'×¨)          
       ===================================================================================== -->          
  <div id="newPostImageBlock" style="          
    border:1px solid rgba(0,0,0,0.10);          
    border-radius:14px;          
    padding:12px;          
    background: rgba(0,0,0,0.02);          
  ">          
    <div class="image-actions-row">          
      <div style="display:flex; flex-direction:column; gap:4px;">          
        <div style="font-weight:bold;">×ª××•× ×” ×œ×¤×•×¡×˜ (××•×¤×¦×™×•× ×œ×™)</div>          
        <div id="newPostImageMeta" style="font-size:12px; opacity:.75;">          
          ×¤×•×¨××˜×™× × ×ª××›×™×: JPG/PNG/WebP. ××•××œ×¥ ×¢×“ 9MB.          
        </div>          
      </div>          
    
      <div style="display:flex; gap:10px; flex-wrap:wrap;">          
        <button id="chooseImageBtn" type="button" class="img-btn img-btn-primary">×‘×—×¨ ×ª××•× ×”</button>          
        <button id="removeImageBtn" type="button" class="img-btn img-btn-danger" style="display:none;">×”×¡×¨ ×ª××•× ×”</button>          
      </div>          
    </div>          
    
    <input id="newPostImage" type="file" accept="image/*" style="display:none;" />          
    
    <div id="imagePreviewWrap" style="display:none; margin-top:12px;">          
      <div class="img-preview">          
        <img id="imagePreview" alt="×ª×¦×•×’×” ××§×“×™××”" src="" />          
      </div>          
    
      <div style="margin-top:10px; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center;">          
        <span id="imageChip" class="image-chip" style="display:none;">ğŸ–¼ï¸ ×ª××•× ×” ××•×›× ×”</span>          
        <span id="imageWarn" style="display:none; font-size:12px; color:#7a4b00; opacity:.95;"></span>          
      </div>          
    
      <div id="uploadProgressArea" style="display:none; margin-top:10px;">          
        <div style="display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center;">          
          <span style="font-size:12px; opacity:.75;">××¢×œ×” ×ª××•× ×”â€¦</span>          
          <span id="uploadProgressText" style="font-size:12px; opacity:.75;">0%</span>          
        </div>          
        <div class="progress-wrap" style="margin-top:6px;">          
          <div id="uploadProgressBar" class="progress-bar"></div>          
        </div>          
      </div>          
    </div>          
  </div>          
    
  <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">                    
    <div id="newPostHint" style="font-size:12px; color:#444;">                    
      ×˜×™×¤: ×ª×›×ª×•×‘ ×‘×¨×•×¨, ×•×ª×©××™×¨ ××§×•× ×œ×ª×’×•×‘×•×ª.                    
    </div>                    
    <div style="display:flex; gap:10px;">                    
      <button id="submitPost" type="button" style="                    
        padding:10px 14px;                    
        border-radius:12px;                    
        border:none;                    
        background: rgb(17,17,87);                    
        color:#fff;                    
        cursor:pointer;                    
        font-weight:bold;                    
      ">×¤×¨×¡×</button>                    
      <button id="cancelPost" type="button" style="                    
        padding:10px 14px;                    
        border-radius:12px;                    
        border:1px solid rgba(0,0,0,0.18);                    
        background:#fff;                    
        cursor:pointer;                    
        font-weight:bold;                    
      ">×‘×™×˜×•×œ</button>                    
    </div>                    
  </div>                    
    
  <div id="createPostError" style="                    
    display:none;                    
    padding:10px 12px;                    
    border-radius:12px;                    
    background: rgba(255,0,0,0.08);                    
    color:#8a0000;                    
    font-size:13px;                    
  "></div>                    
</div>

  </div>                    
</div>                    <!-- =====================================================================================          
     FULLSCREEN IMAGE VIEWER (×©×“×¨×•×’ UX - ×œ× ×¤×•×’×¢ ×‘××‘×˜×—×”)          
     ===================================================================================== -->          <div id="imageViewerOverlay">          
  <div id="imageViewerInner">          
    <div id="imageViewerTop">          
      <div style="font-weight:bold;">×ª××•× ×”</div>          
      <button id="closeImageViewer" type="button">âœ•</button>          
    </div>          
    <img id="imageViewerImg" alt="×ª××•× ×”" src="" />          
    <div style="margin-top:10px; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center;">          <span id="imageViewerHint" style="font-size:12px; opacity:.75;">×œ×—×¥ ××—×•×¥ ×œ×ª×™×‘×” ×›×“×™ ×œ×¡×’×•×¨</span>          
</div>

  </div>          
</div>          <!-- =====================================================================================          
     NEW: MINI IMAGE PREVIEW (requested: click "×™×© ×ª××•× ×”" -> small preview with X)          
     ===================================================================================== -->          <div id="miniImageOverlay">          
  <div id="miniImageInner">          
    <div id="miniImageTop">          
      <div style="font-weight:bold;">×ª×¦×•×’×” ××§×“×™××”</div>          
      <button id="miniCloseBtn" type="button">âœ•</button>          
    </div>          
    <img id="miniPreviewImg" alt="×ª××•× ×”" src="" />          
    <div id="miniHint">×œ×—×¥ ××—×•×¥ ×œ×ª×™×‘×” ×›×“×™ ×œ×¡×’×•×¨</div>          
  </div>          
</div>          <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>                    <script>                    
/* =========================================================================================                    
   âš ï¸ ×—×©×•×‘: ××‘×˜×—×” â€“ ×œ× × ×•×’×¢×™× ×•×œ× ××©× ×™× ×©×™×˜×”                    
   1) ×—×¡×™××” ××™×™×“×™×ª â€“ ×œ× WebView => forbidden.html                    
   2) payload ××§×•×“×•×œ×¨ (email/password/token)                    
   3) Firebase Auth                    
   4) ××™××•×ª token ××•×œ sessions/{uid}/token                    
   ×¨×§ ××—×¨×™ ×–×”: ×’×™×©×” ×œ×¤×•×¡×˜×™×/×™×¦×™×¨×”/×¨×¢× ×•×Ÿ                    
   ========================================================================================= */                    
        
/* ===============================                    
   ×—×¡×™××” ××™×™×“×™×ª â€“ ×œ× WebView                    
   =============================== */                    
              
        (function () {
  try {
    const ua = navigator.userAgent;

    const isKodular =
      window.AppInventor &&
      typeof window.AppInventor.getWebViewString === "function";

    const isIphoneSafari =
      /iPhone/.test(ua) &&
      /Safari/.test(ua) &&
      !/CriOS|FxiOS|EdgiOS|OPiOS/.test(ua);

    if (!(isKodular || isIphoneSafari)) {
      location.replace("forbidden.html");
    }
  } catch (e) {
    location.replace("forbidden.html");
  }
})();
/* =========================================================================================                    
   Cache (A) â€“ ×ª×¦×•×’×” ××™×™×“×™×ª                    
   ========================================================================================= */                    
var cached = null;                    
try {                    
  cached = sessionStorage.getItem("cachedPosts");                    
} catch (e1) {                    
  cached = null;                    
}                    
if (cached) {                    
  var postsHost = document.getElementById("posts");                    
  if (postsHost) postsHost.innerHTML = cached;                    
}                    
        
/* =========================================================================================                    
   Utilities                    
   ========================================================================================= */                    
function escapeHTML(str) {                    
  if (str === undefined || str === null) str = "";                    
  return String(str)                    
    .replace(/&/g, "&amp;")                    
    .replace(/</g, "&lt;")                    
    .replace(/>/g, "&gt;")                    
    .replace(/\"/g, "&quot;")                    
    .replace(/'/g, "&#039;");                    
}                    
        
function safeText(str) {                    
  if (str === undefined || str === null) str = "";                    
  return String(str);                    
}                    
        
/* =========================================================================================          
   userColor (exact same vibe as post page)          
   ========================================================================================= */          
function userColor(key) {          
  var colors = [          
    "#60a5fa",          
    "#34d399",          
    "#f472b6",          
    "#fbbf24",          
    "#a78bfa",          
    "#fb7185",          
    "#22d3ee"          
  ];          
  var hash = 0;          
  var s = safeText(key || "");          
  for (var i = 0; i < s.length; i++) {          
    hash = s.charCodeAt(i) + ((hash << 5) - hash);          
  }          
  var idx = Math.abs(hash) % colors.length;          
  return colors[idx];          
}          
        
/* =========================================================================================          
   Meta cache (commentsCount + lastCommentTime)          
   - Fixes: "××™×Ÿ ×ª×’×•×‘×•×ª" resets on refresh          
   - Supports: lastComment sort stable across nav/refresh          
   ========================================================================================= */          
var postMetaCache = {};          
var postMetaSaveTimer = null;          
        
function loadPostMetaCache() {          
  try {          
    var raw = sessionStorage.getItem("postMetaCache");          
    if (!raw) { postMetaCache = {}; return; }          
    var obj = JSON.parse(raw);          
    if (obj && typeof obj === "object") postMetaCache = obj;          
    else postMetaCache = {};          
  } catch (e) {          
    postMetaCache = {};          
  }          
}          
        
function savePostMetaCacheSoon() {          
  try {          
    if (postMetaSaveTimer) return;          
    postMetaSaveTimer = setTimeout(function () {          
      postMetaSaveTimer = null;          
      try {          
        sessionStorage.setItem("postMetaCache", JSON.stringify(postMetaCache || {}));          
      } catch (e2) { }          
    }, 700);          
  } catch (e) { }          
}          
        
function getMetaForPost(postId) {          
  try {          
    var k = safeText(postId || "");          
    if (!k) return null;          
    if (postMetaCache && postMetaCache[k]) return postMetaCache[k];          
    return null;          
  } catch (e) {          
    return null;          
  }          
}          
        
function setMetaForPost(postId, metaObj) {          
  try {          
    var k = safeText(postId || "");          
    if (!k) return;          
    if (!postMetaCache) postMetaCache = {};          
    if (!postMetaCache[k]) postMetaCache[k] = {};          
    var m = postMetaCache[k];          
    if (metaObj && typeof metaObj === "object") {          
      if (metaObj.commentsCount !== undefined) m.commentsCount = Number(metaObj.commentsCount || 0);          
      if (metaObj.lastCommentTime !== undefined) m.lastCommentTime = Number(metaObj.lastCommentTime || 0);          
      if (metaObj.updatedAt !== undefined) m.updatedAt = Number(metaObj.updatedAt || 0);          
    }          
    m.updatedAt = Date.now();          
    savePostMetaCacheSoon();          
  } catch (e) { }          
}          
        
/* =========================================================================================          
   Sort mode memory (requested: keep last choice in memory, including lastComment)          
   ========================================================================================= */          
var rememberedSortMode = "lastComment";      
try {      
  rememberedSortMode = sessionStorage.getItem("forumSortMode") || "lastComment";      
} catch (e) {      
  rememberedSortMode = "lastComment";      
}       
        
function rememberSortMode(v) {          
  try {          
    sessionStorage.setItem("forumSortMode", safeText(v || "newest"));          
  } catch (e) { }          
}          
        
/* =========================================================================================          
   lastComment sort readiness memory (keeps UI stable)          
   ========================================================================================= */          
var lastCommentMetaReady = false;          
try {          
  lastCommentMetaReady = (sessionStorage.getItem("lastCommentMetaReady") === "1");          
} catch (e) {          
  lastCommentMetaReady = false;          
}          
        
function setLastCommentMetaReady(val) {          
  lastCommentMetaReady = !!val;          
  try {          
    sessionStorage.setItem("lastCommentMetaReady", lastCommentMetaReady ? "1" : "0");          
  } catch (e) { }          
}          
        
/* =========================================================================================          
   NEW: lastComment stable order memory (requested behavior)          
   - show last known order immediately          
   - after meta is fully ready -> compute new order -> save          
   ========================================================================================= */          
var lastCommentSavedOrder = [];          
function loadLastCommentSavedOrder() {          
  try {          
    var raw = sessionStorage.getItem("forumLastCommentOrder");          
    if (!raw) { lastCommentSavedOrder = []; return; }          
    var arr = JSON.parse(raw);          
    if (arr && arr.length) lastCommentSavedOrder = arr;          
    else lastCommentSavedOrder = [];          
  } catch (e) {          
    lastCommentSavedOrder = [];          
  }          
}          
function saveLastCommentSavedOrder(idsArr) {          
  try {          
    sessionStorage.setItem("forumLastCommentOrder", JSON.stringify(idsArr || []));          
  } catch (e) { }          
}          
loadLastCommentSavedOrder();          
        
/* =========================================================================================          
   Image URL safety (×”×§×©×—×” ×§×œ×” × ×’×“ ×¢×¨×›×™ URL ××•×–×¨×™×)          
   - ×œ× ××©× ×” ××‘×˜×—×” ×××™×ª×™×ª (×”×™× ×‘×¨×•×œ×¡), ×¨×§ ××•× ×¢ XSS/×”×–×¨×§×•×ª          
   ========================================================================================= */          
function sanitizeImageUrl(url) {          
  if (url === undefined || url === null) return "";          
  var u = safeText(url).trim();          
  if (!u) return "";          
  // allow only http(s)          
  if (u.indexOf("https://") === 0 || u.indexOf("http://") === 0) return u;          
  return "";          
}          
        
function isLikelyImageFile(file) {          
  try {          
    if (!file) return false;          
    var t = safeText(file.type || "").toLowerCase();          
    if (t.indexOf("image/") === 0) return true;          
    var n = safeText(file.name || "").toLowerCase();          
    if (n.indexOf(".jpg") > -1 || n.indexOf(".jpeg") > -1 || n.indexOf(".png") > -1 || n.indexOf(".webp") > -1) return true;          
    return false;          
  } catch (e) {          
    return false;          
  }          
}          
        
function bytesToHuman(n) {          
  try {          
    var x = Number(n || 0);          
    if (!x) return "0B";          
    if (x < 1024) return x + "B";          
    if (x < 1024 * 1024) return Math.round(x / 1024) + "KB";          
    return (Math.round((x / (1024 * 1024)) * 10) / 10) + "MB";          
  } catch (e) {          
    return "";          
  }          
}          
        
function copyToClipboard(text) {          
  try {          
    if (navigator.clipboard && navigator.clipboard.writeText) {          
      navigator.clipboard.writeText(text);          
      return;          
    }          
  } catch (e) { }          
  try {          
    var ta = document.createElement("textarea");          
    ta.value = safeText(text);          
    ta.style.position = "fixed";          
    ta.style.opacity = "0";          
    document.body.appendChild(ta);          
    ta.select();          
    try { document.execCommand("copy"); } catch (e2) { }          
    document.body.removeChild(ta);          
  } catch (e3) { }          
}          
    
/* =========================================================================================          
   NEW: Shared Signed URL Cache (sessionStorage)
   - Caches signed URLs across forum.html and post.html
   - Automatically clears expired URLs
   ========================================================================================= */
const SignedUrlCache = (function() {
  const CACHE_KEY = "signedUrlCache";
  let cache = Object.create(null);

  function load() {
    try {
      const raw = sessionStorage.getItem(CACHE_KEY);
      if (raw) {
        const parsed = JSON.parse(raw);
        const now = Date.now();
        for (const path in parsed) {
          if (parsed[path] && parsed[path].expTs && parsed[path].expTs > now) {
            cache[path] = parsed[path];
          }
        }
      }
    } catch (e) {
      cache = Object.create(null);
    }
  }

  function save() {
    try {
      sessionStorage.setItem(CACHE_KEY, JSON.stringify(cache));
    } catch (e) {}
  }

  load(); // Load on init

  return {
    get: function(path) {
      const p = safeText(path || "");
      if (!p) return "";
      const rec = cache[p];
      if (!rec || !rec.url) return "";
      if (rec.expTs && Date.now() > rec.expTs) {
        delete cache[p];
        save();
        return "";
      }
      return rec.url;
    },
    set: function(path, url, expiresAt) { // expiresAt is a timestamp
      const p = safeText(path || "");
      const u = sanitizeImageUrl(url || "");
      if (!p || !u) return;
      const expTs = Number(expiresAt || 0) || (Date.now() + 110 * 1000);
      if (expTs <= Date.now()) return;
      
      cache[p] = { url: u, expTs: expTs };
      save();
    }
  };
})();

/* =========================================================================================          
   SECURE IMAGE FLOW (new)          
   - posts store imagePath (Storage path) instead of download URL          
   - viewer fetches short-lived signed URL via Cloud Function getImageUrl (2 minutes)          
   ========================================================================================= */          
var GET_IMAGE_URL_ENDPOINT = "https://us-central1-bigone-86490.cloudfunctions.net/getImageUrl";          
var _idTokenCache = { token: "", at: 0 };          
var _signedUrlInFlight = {};     // path -> Promise          
        
function getIdTokenFast(forceRefresh) {          
  return new Promise(function (resolve, reject) {          
    try {          
      var now = Date.now();          
      // keep token very short cached to avoid too many calls, but still fresh for security          
      if (!forceRefresh && _idTokenCache && _idTokenCache.token && (now - (_idTokenCache.at || 0) < 45000)) {          
        resolve(_idTokenCache.token);          
        return;          
      }          
      var u = null;          
      try { u = firebase.auth().currentUser; } catch (eU) { u = null; }          
      if (!u || typeof u.getIdToken !== "function") {          
        reject("no_user");          
        return;          
      }          
      u.getIdToken(!!forceRefresh)          
        .then(function (t) {          
          _idTokenCache.token = safeText(t || "");          
          _idTokenCache.at = Date.now();          
          resolve(_idTokenCache.token);          
        })          
        .catch(reject);          
    } catch (e0) {          
      reject(e0);          
    }          
  });          
}          
        
/* =========================================================================================
   âœ… UPDATE (minimal + robust): signed-url fetcher that accepts multiple payload shapes
   - fixes common cause of "×œ× ×”×¦×œ×—×ª×™ ×œ×˜×¢×•×Ÿ ××ª ×”×ª××•× ×”" when function returns {url:...} without ok
   - retries once with forceRefresh token on 401/403
   - supports param names: path / filePath / imagePath (server differences)
   ========================================================================================= */
function _extractSignedUrlFromPayload(data) {
  try {
    if (!data || typeof data !== "object") return { url: "", expiresAt: 0 };

    // common variants
    var u = "";
    if (!u && data.url) u = data.url;
    if (!u && data.signedUrl) u = data.signedUrl;
    if (!u && data.downloadUrl) u = data.downloadUrl;
    if (!u && data.result && data.result.url) u = data.result.url;
    if (!u && data.data && data.data.url) u = data.data.url;

    var exp = 0;
    if (data.expiresAt !== undefined && data.expiresAt !== null) exp = Number(data.expiresAt || 0) || 0;
    if (!exp && data.expires !== undefined && data.expires !== null) exp = Number(data.expires || 0) || 0;
    if (!exp && data.expiration !== undefined && data.expiration !== null) exp = Number(data.expiration || 0) || 0;
    if (!exp && data.exp !== undefined && data.exp !== null) exp = Number(data.exp || 0) || 0;

    u = sanitizeImageUrl(u);
    if (!u) return { url: "", expiresAt: 0 };

    // if server didn't send expiry, assume ~2 minutes and refresh early anyway
    if (!exp) exp = Date.now() + (110 * 1000);

    return { url: u, expiresAt: exp };
  } catch (e) {
    return { url: "", expiresAt: 0 };
  }
}

function _fetchSignedUrlHTTP(path, token, modeParamName) {
  try {
    var p = safeText(path || "").trim();
    if (!p) return Promise.reject("missing_path");
    var key = safeText(modeParamName || "path");
    var url = GET_IMAGE_URL_ENDPOINT + "?" + encodeURIComponent(key) + "=" + encodeURIComponent(p);
    return fetch(url, {
      method: "GET",
      headers: {
        "Authorization": "Bearer " + safeText(token || "")
      }
    }).then(function (resp) {
      return Promise.resolve(resp);
    });
  } catch (e) {
    return Promise.reject(e);
  }
}

function fetchSignedUrlForPath(path, force) {          
  return new Promise(function (resolve, reject) {          
    try {          
      var p = safeText(path || "").trim();          
      if (!p) { reject("missing_path"); return; }          

      // Cache hit (unless forced)          
      if (!force) {          
        var cachedUrl = SignedUrlCache.get(p);          
        if (cachedUrl) {          
          resolve({ url: cachedUrl, expiresAt: 0 }); // expiresAt is unknown, but that's ok for the caller          
          return;          
        }          
      }          

      // Deduplicate inflight          
      if (_signedUrlInFlight[p]) {          
        _signedUrlInFlight[p].then(resolve).catch(reject);          
        return;          
      }          

      // NOTE: We try a tiny sequence for compatibility:
      // 1) param "path"
      // 2) if bad payload -> try "filePath"
      // 3) if still bad -> try "imagePath"
      // Also: if 401/403 -> refresh token ONCE
      _signedUrlInFlight[p] = (function () {
        var lastResp = null;
        var usedParam = "path";

      function parseResp(resp) {
  if (!resp) throw "bad_status";
  return resp.text().then(function (txt) {
    var data = null;
    try { data = JSON.parse(txt); } catch (e) { data = null; }

    if (!resp.ok) {
      var msg = "";
      if (data && typeof data === "object") {
        if (data.error) msg = String(data.error);
        else msg = JSON.stringify(data).slice(0, 220);
      } else {
        msg = (txt || "").slice(0, 220);
      }
      throw ("bad_status_" + (resp.status || 0) + ":" + msg);
    }

    return data || {};
  });
}


        function attemptWith(token, paramName) {
          usedParam = paramName;
          return _fetchSignedUrlHTTP(p, token, paramName).then(parseResp).then(function (data) {
            // accept payload with or without ok
            if (data && data.ok === false && !data.url && !data.signedUrl && !data.downloadUrl) {
              throw "bad_payload";
            }
            var ex = _extractSignedUrlFromPayload(data);
            if (!ex || !ex.url) throw "bad_payload";
            SignedUrlCache.set(p, ex.url, ex.expiresAt);
            return { url: ex.url, expiresAt: ex.expiresAt };
          });
        }

        return getIdTokenFast(true)

          .then(function (token) {
            return attemptWith(token, "path").catch(function (e1) {
              // Retry with alternate param if server expects it
              return attemptWith(token, "filePath").catch(function () {
                return attemptWith(token, "imagePath");
              });
            });
          })
          .catch(function (err) {
            // If auth error, refresh token once and retry
            var s = safeText(err || "");
            var isAuth = (s.indexOf("bad_status_401") === 0 || s.indexOf("bad_status_403") === 0 || s === "no_user");
            if (!isAuth) throw err;
            return getIdTokenFast(true).then(function (token2) {
              // retry with last used param first (usually correct), then fallback chain
              return attemptWith(token2, usedParam || "path").catch(function () {
                return attemptWith(token2, "path").catch(function () {
                  return attemptWith(token2, "filePath").catch(function () {
                    return attemptWith(token2, "imagePath");
                  });
                });
              });
            });
          });
      })();

      _signedUrlInFlight[p]          
        .then(function (r) {          
          try { delete _signedUrlInFlight[p]; } catch (eD) { }          
          resolve(r);          
        })          
        .catch(function (err) {          
          try { delete _signedUrlInFlight[p]; } catch (eD2) { }          
          reject(err);          
        });          
    } catch (e0) {          
      try {          
        var p2 = safeText(path || "").trim();          
        if (p2 && _signedUrlInFlight[p2]) delete _signedUrlInFlight[p2];          
      } catch (eX) { }          
      reject(e0);          
    }          
  });          
}          
        
/* ===============================          
   FIX: WebView compatibility helpers          
   =============================== */          
function dataURLToBlob(dataUrl) {          
  try {          
    var parts = safeText(dataUrl || "").split(",");          
    if (parts.length < 2) return null;          
    var meta = parts[0];          
    var b64 = parts[1];          
    var mime = "application/octet-stream";          
    var m = /data:([^;]+);base64/i.exec(meta);          
    if (m && m[1]) mime = m[1];          
    var bin = atob(b64);          
    var len = bin.length;          
    var arr = new Uint8Array(len);          
    for (var i = 0; i < len; i++) arr[i] = bin.charCodeAt(i);          
    return new Blob([arr], { type: mime });          
  } catch (e) {          
    return null;          
  }          
}          
        
function canvasToBlobSafe(canvas, outType, quality, cb) {          
  try {          
    if (canvas && typeof canvas.toBlob === "function") {          
      canvas.toBlob(function (blob) { cb(blob); }, outType, quality);          
      return;          
    }          
  } catch (e1) { }          
  try {          
    var dataUrl = "";          
    try { dataUrl = canvas.toDataURL(outType, quality); } catch (e2) { dataUrl = canvas.toDataURL(); }          
    var blob2 = dataURLToBlob(dataUrl);          
    cb(blob2);          
  } catch (e3) {          
    cb(null);          
  }          
}          
        
function getPreviewUrlForFile(file, done) {          
  try {          
    if (window.URL && typeof URL.createObjectURL === "function") {          
      try {          
        var u = URL.createObjectURL(file);          
        done(u, true);          
        return;          
      } catch (eObj) { }          
    }          
  } catch (e0) { }          
        
  try {          
    var r = new FileReader();          
    r.onerror = function () { done("", false); };          
    r.onload = function () { done(safeText(r.result || ""), false); };          
    r.readAsDataURL(file);          
  } catch (e1) {          
    done("", false);          
  }          
}          
        
function openImageViewer(url) {          
  var overlay = document.getElementById("imageViewerOverlay");          
  var img = document.getElementById("imageViewerImg");          
  /*          
    [REMOVED REQUESTED FEATURE - keep length, no functional leftovers]          
    In older versions, there was a "copy link" button inside the image overlay.          
    The button was removed, and we keep this note to avoid dangling references.          
    var copyBtn = document.getElementById("copyImageLinkBtn");          
  */          
  var closeBtn = document.getElementById("closeImageViewer");          
        
  if (!overlay || !img) return;          
        
  var safe = sanitizeImageUrl(url);          
  if (!safe) return;          
        
 
  bindImgLoadErrorOnce(img);
img.setAttribute("src", safe);
overlay.style.display = "flex";
         
        
  /*          
    [REMOVED - no binding to non-existing button]          
    if (copyBtn && !copyBtn.__bound) {          
      copyBtn.__bound = true;          
      copyBtn.addEventListener("click", function () {          
        var src = img.getAttribute("src") || "";          
        if (src) copyToClipboard(src);          
      });          
    }          
  */          
        
  if (closeBtn && !closeBtn.__bound) {          
    closeBtn.__bound = true;          
    closeBtn.addEventListener("click", function () {          
      overlay.style.display = "none";          
      img.setAttribute("src", "");          
    });          
  }          
        
  if (!overlay.__bound) {          
    overlay.__bound = true;          
    overlay.addEventListener("click", function (e) {          
      // click outside inner          
      if (e.target === overlay) {          
        overlay.style.display = "none";          
        img.setAttribute("src", "");          
      }          
    });          
  }          
}          
        
/* =========================================================================================          
   NEW: mini image preview (requested: click chip -> small preview with X)          
   ========================================================================================= */          
function bindImgLoadErrorOnce(imgEl) {
  if (!imgEl || imgEl.__boundLoadErr) return;
  imgEl.__boundLoadErr = true;

  imgEl.addEventListener("load", function () {
    // ×”×ª××•× ×” × ×˜×¢× ×” ×‘×”×¦×œ×—×” â†’ ×× ×§×™× ×”×•×“×¢×ª ×©×’×™××”
    try { setStatus("", "info"); } catch (e) {}
  });

  imgEl.addEventListener("error", function () {
    // error ×××™×ª×™ ×¨×§ ×× ×™×© src
    try {
      var current = (imgEl.getAttribute("src") || "").trim();
      if (!current) return;
      setStatus("×œ× ×”×¦×œ×—×ª×™ ×œ×˜×¢×•×Ÿ ××ª ×”×ª××•× ×”.", "error");
    } catch (e) {}
  });
}
function openMiniImagePreview(url) {          
  try {          
    var overlay = document.getElementById("miniImageOverlay");          
    var img = document.getElementById("miniPreviewImg");          
    var closeBtn = document.getElementById("miniCloseBtn");          
    if (!overlay || !img) return;          
        
    var safe = sanitizeImageUrl(url);          
    if (!safe) return;          

   bindImgLoadErrorOnce(img);
img.setAttribute("src", safe);
overlay.style.display = "flex";
        
        
    if (closeBtn && !closeBtn.__bound) {          
      closeBtn.__bound = true;          
      closeBtn.addEventListener("click", function () {          
        overlay.style.display = "none";          
        img.setAttribute("src", "");          
      });          
    }          
        
    if (!overlay.__bound) {          
      overlay.__bound = true;          
      overlay.addEventListener("click", function (e) {          
        if (e.target === overlay) {          
          overlay.style.display = "none";          
          img.setAttribute("src", "");          
        }          
      });          
    }          
  } catch (e) { }          
}          
    
function supportsWebPExport() {          
  try {          
    var c = document.createElement("canvas");          
    if (!c || typeof c.toDataURL !== "function") return false;          
    var u = c.toDataURL("image/webp");          
    return (u && u.indexOf("data:image/webp") === 0);          
  } catch (e) {          
    return false;          
  }          
}          
    
function yieldToUI() {          
  return new Promise(function (resolve) {          
    try { setTimeout(resolve, 0); } catch (e) { resolve(); }          
  });          
}          
    
function prepareImageForUpload(file, warnEl) {          
  // ×©×“×¨×•×’: ××•×¤×˜×™××™×–×¦×™×” "×—×›××”" ×©×œ× ××›×‘×™×“×” ×¢×œ ×©×œ×‘ ×”×‘×—×™×¨×”.    
  // ××¢×‘×“×™× ×¨×§ ×‘×–××Ÿ ×¤×¨×¡×•×, ×¢× yield ×œ-UI, ×•×¢× fallbacks ×‘×˜×•×—×™×.    
  return new Promise(function (resolve) {          
    (function run() {          
      try {          
        if (!file) { resolve({ blob: null, contentType: "", ext: "" }); return; }          
        
        var origType = safeText(file.type || "").toLowerCase();          
        var origName = safeText(file.name || "");          
        var ext = "";          
        if (origName.indexOf(".") !== -1) ext = origName.split(".").pop().toLowerCase();          
        
        // Keep very small images as-is (no CPU).          
        var size = Number(file.size || 0);          
        var SHOULD_TRY = size > (700 * 1024); // 700KB+          
        
        // HEIC/HEIF often fail decoding in WebView; keep as-is (no crash).          
        var isHeic = (origType.indexOf("heic") > -1 || origType.indexOf("heif") > -1 || ext === "heic" || ext === "heif");          
        if (isHeic) {          
          try {          
            if (warnEl) {          
              warnEl.style.display = "block";          
              warnEl.textContent = "×ª××•× ×ª HEIC/HEIF: ×ª×•×¢×œ×” ×›××• ×©×”×™× (×œ×œ× ××•×¤×˜×™××™×–×¦×™×”) ×›×“×™ ×œ×× ×•×¢ ×›×©×œ×™× ×‘××›×©×™×¨×™× ×—×œ×©×™×.";          
            }          
          } catch (eW0) { }          
          resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "heic" });          
          return;          
        }          
        
        if (!SHOULD_TRY) {          
          resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });          
          return;          
        }          
        
        // Choose output format: prefer webp if export supported; else jpeg; keep png if original png and no webp.          
        var canWebp = supportsWebPExport();          
        var outType = "image/jpeg";          
        var outExt = "jpg";          
        
        if (canWebp) {          
          outType = "image/webp";          
          outExt = "webp";          
        } else if (origType === "image/png" || ext === "png") {          
          outType = "image/png";          
          outExt = "png";          
        }          
        
        // Max dimension (balanced for quality vs cpu on weak phones)          
        var maxDim = 1600;          
        var quality = 0.82;          
        
        // Decode image with best available method, without blocking selection step (we're here only on publish).          
        yieldToUI()          
          .then(function () {          
            // createImageBitmap path (fast on many devices)          
            if (typeof createImageBitmap === "function") {          
              return createImageBitmap(file).then(function (bmp) {          
                return { kind: "bitmap", src: bmp };          
              }).catch(function () {          
                return { kind: "img", src: null };          
              });          
            }          
            return { kind: "img", src: null };          
          })          
          .then(function (decoded) {          
            // Fallback to HTMLImageElement          
            if (decoded && decoded.kind === "bitmap" && decoded.src) {          
              return decoded;          
            }          
            return new Promise(function (resolveImg) {          
              getPreviewUrlForFile(file, function (srcUrl, canRevoke) {          
                if (!srcUrl) { resolveImg({ kind: "fail" }); return; }          
                var img = new Image();          
                img.onload = function () {          
                  try { if (canRevoke && srcUrl) URL.revokeObjectURL(srcUrl); } catch (eRv) { }          
                  resolveImg({ kind: "img", src: img });          
                };          
                img.onerror = function () {          
                  try { if (canRevoke && srcUrl) URL.revokeObjectURL(srcUrl); } catch (eRv2) { }          
                  resolveImg({ kind: "fail" });          
                };          
                img.src = srcUrl;          
              });          
            });          
          })          
          .then(function (decoded) {          
            try {          
              if (!decoded || decoded.kind === "fail" || !decoded.src) {          
                resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });          
                return;          
              }          
        
              var w = 0, h = 0;          
              if (decoded.kind === "bitmap") {          
                w = decoded.src.width || 0;          
                h = decoded.src.height || 0;          
              } else {          
                w = decoded.src.naturalWidth || decoded.src.width || 0;          
                h = decoded.src.naturalHeight || decoded.src.height || 0;          
              }          
              if (!w || !h) {          
                try { if (decoded.kind === "bitmap" && decoded.src && decoded.src.close) decoded.src.close(); } catch (eC) { }          
                resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });          
                return;          
              }          
        
              // If already small enough and not too heavy, keep original to save CPU.          
              if (Math.max(w, h) <= maxDim && size < (2.2 * 1024 * 1024)) {          
                try {          
                  if (warnEl) {          
                    warnEl.style.display = "block";          
                    warnEl.textContent = "×”×ª××•× ×” × ×‘×—×¨×” ×›×¤×™ ×©×”×™× (××™×Ÿ ×¦×•×¨×š ×‘×›×™×•×•×¥).";          
                  }          
                } catch (eW2) { }          
                try { if (decoded.kind === "bitmap" && decoded.src && decoded.src.close) decoded.src.close(); } catch (eC2) { }          
                resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });          
                return;          
              }          
        
              var scale = 1;          
              if (w > maxDim || h > maxDim) {          
                scale = Math.min(maxDim / w, maxDim / h);          
              }          
              var nw = Math.max(1, Math.round(w * scale));          
              var nh = Math.max(1, Math.round(h * scale));          
        
              // Progressive downscale for huge images (less memory spikes / better quality)          
              var canvas = document.createElement("canvas");          
              canvas.width = nw;          
              canvas.height = nh;          
              var ctx = canvas.getContext("2d");          
              if (!ctx) {          
                try { if (decoded.kind === "bitmap" && decoded.src && decoded.src.close) decoded.src.close(); } catch (eC3) { }          
                resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });          
                return;          
              }          
        
              ctx.imageSmoothingEnabled = true;          
              try { ctx.imageSmoothingQuality = "high"; } catch (eQ) { }          
        
              // For very large downscale ratios: draw in 2 steps (reduces aliasing and can be lighter).          
              var ratio = Math.max(w / nw, h / nh);          
              if (ratio > 2.2) {          
                var midW = Math.max(nw, Math.round(w / 2));          
                var midH = Math.max(nh, Math.round(h / 2));          
                var tmp = document.createElement("canvas");          
                tmp.width = midW;          
                tmp.height = midH;          
                var tctx = tmp.getContext("2d");          
                if (tctx) {          
                  tctx.imageSmoothingEnabled = true;          
                  try { tctx.imageSmoothingQuality = "high"; } catch (eQ2) { }          
                  tctx.drawImage(decoded.src, 0, 0, midW, midH);          
                  ctx.drawImage(tmp, 0, 0, nw, nh);          
                } else {          
                  ctx.drawImage(decoded.src, 0, 0, nw, nh);          
                }          
              } else {          
                ctx.drawImage(decoded.src, 0, 0, nw, nh);          
              }          
        
              // Release bitmap if used          
              try { if (decoded.kind === "bitmap" && decoded.src && decoded.src.close) decoded.src.close(); } catch (eC4) { }          
        
              yieldToUI().then(function () {          
                canvasToBlobSafe(canvas, outType, quality, function (blob) {          
                  try {          
                    if (!blob) {          
                      resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });          
                      return;          
                    }          
        
                    // If result is bigger (rare), keep original (avoid wasting)          
                    try {          
                      if (Number(blob.size || 0) >= Number(file.size || 0)) {          
                        resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });          
                        return;          
                      }          
                    } catch (eSz) { }          
        
                    try {          
                      if (warnEl) {          
                        warnEl.style.display = "block";          
                        warnEl.textContent = "×‘×•×¦×¢×” ××•×¤×˜×™××™×–×¦×™×” ×œ×ª××•× ×” ×›×“×™ ×œ×”××™×¥ ×˜×¢×™× ×”.";          
                      }          
                    } catch (eWarn) { }          
        
                    resolve({ blob: blob, contentType: outType, ext: outExt });          
                  } catch (eFin) {          
                    resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });          
                  }          
                });          
              });          
            } catch (e2) {          
              try { if (decoded.kind === "bitmap" && decoded.src && decoded.src.close) decoded.src.close(); } catch (eC5) { }          
              resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });          
            }          
          })          
          .catch(function () {          
            resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });          
          });          
      } catch (e0) {          
        resolve({ blob: file, contentType: file.type || "application/octet-stream", ext: ext || "jpg" });          
      }          
    })();          
  });          
}          
        
function nowTs() {                    
  return Date.now();                    
}                    
        
function setStatus(msg, type) {                    
  if (type === undefined || type === null) type = "info";                    
  var bar = document.getElementById("statusBar");                    
  if (!bar) return;                    
        
  if (!msg) {                    
    bar.style.display = "none";                    
    bar.textContent = "";                    
    return;                    
  }                    
        
  bar.style.display = "block";                    
  bar.textContent = msg;                    
        
  if (type === "error") {                    
    bar.style.background = "rgba(255,0,0,0.08)";                    
    bar.style.color = "#8a0000";                    
  } else if (type === "ok") {                    
    bar.style.background = "rgba(0,128,0,0.08)";                    
    bar.style.color = "#0b5a0b";                    
  } else if (type === "warn") {          
    bar.style.background = "rgba(255,165,0,0.10)";          
    bar.style.color = "#7a4b00";          
  } else {                    
    bar.style.background = "rgba(0,0,0,0.04)";                    
    bar.style.color = "#111";                    
  }                    
}                    
        
function debounce(fn, ms) {                    
  var t = null;                    
  return function () {                    
    var args = arguments;                    
    clearTimeout(t);                    
    t = setTimeout(function () {                    
      fn.apply(null, args);                    
    }, ms);                    
  };                    
}                    
        
/* =========================================================================================                    
   Global State                    
   ========================================================================================= */                    
var payload = null;                    
var uid = null;                    
var isRefreshing = false;                    
var isAuthed = false;                    
        
var postsCacheData = [];                    
var renderedHtmlCache = "";                    
var lastNavAt = 0;                    
var lastOpenId = "";                    
var pullStartY = 0;                    
var pulling = false;                    
var didTriggerRefresh = false;                    
var realUsername = "××©×ª××©";  
var presenceStartAt = 0;
var presenceHeartbeatTimer = null;
var presenceRef = null;                  
        
/* =========================================================================================          
   Image state (×©×“×¨×•×’)          
   ========================================================================================= */          
var selectedImageFile = null;          
var selectedImagePreviewUrl = "";          
var selectedImagePreviewCanRevoke = false;          
var selectedImagePrepared = null; // { blob, contentType, ext }          
var selectedImageDataUrl = ""; // kept for fallback (DataURL)          
var isPublishingNow = false;          
        
/* =========================================================================================          
   Forum meta live: listeners per visible post          
   ========================================================================================= */          
var visibleMetaListenerMap = {};          
var visibleMetaValueRefMap = {};          
var visibleMetaLastRefMap = {};          
var visibleMetaBoundIds = [];          
var metaQueue = [];          
var metaInFlight = 0;          
var META_CONCURRENCY = 4;          
var metaFetchAllRunning = false;          
var metaFetchAllNeedResortAtEnd = false;          
var lastRenderedListIds = [];          
var liveMetaTickTimer = null;          
        
/* =========================================================================================          
   NEW: comment/reply meta computation (requested)          
   - Reply bumps lastCommentTime          
   - Reply DOES NOT increase commentsCount (we keep top-level count only)          
   ========================================================================================= */          
function findMaxTimeInNestedReplies(obj, depth) {          
  try {          
    if (!obj || depth <= 0) return 0;          
    var maxT = 0;          
    for (var k in obj) {          
      if (!obj.hasOwnProperty(k)) continue;          
      var v = obj[k];          
      if (!v) continue;          
      if (typeof v === "object") {          
        // direct time field          
        try {          
          if (v.time !== undefined && v.time !== null) {          
            var t0 = Number(v.time || 0) || 0;          
            if (t0 > maxT) maxT = t0;          
          }          
        } catch (eT0) { }          
        
        // go deeper          
        var t1 = findMaxTimeInNestedReplies(v, depth - 1);          
        if (t1 > maxT) maxT = t1;          
      }          
    }          
    return maxT;          
  } catch (e) {          
    return 0;          
  }          
}          
        
function computeMetaFromCommentsSnapshot(snap) {          
  try {          
    var countTop = 0;          
    var lastTime = 0;          
        
    if (snap && snap.exists()) {          
      // Top-level count only (reply doesn't add)          
      try { countTop = snap.numChildren(); } catch (eC) { countTop = 0; }          
        
      snap.forEach(function (c) {          
        try {          
          var v = c.val() || {};          
          var t = Number(v.time || 0) || 0;          
          if (t > lastTime) lastTime = t;          
        
          // replies containers (common names)          
          // NOTE: if your structure differs, this still stays safe (no crash), and value listener will keep updating.          
          var r1 = v.replies || null;          
          var r2 = v.reply || null;          
          var r3 = v.responses || null;          
          var r4 = v.children || null;          
          var r5 = v.subReplies || null;          
        
          var mx = 0;          
          if (r1 && typeof r1 === "object") { mx = Math.max(mx, findMaxTimeInNestedReplies(r1, 4)); }          
          if (r2 && typeof r2 === "object") { mx = Math.max(mx, findMaxTimeInNestedReplies(r2, 4)); }          
          if (r3 && typeof r3 === "object") { mx = Math.max(mx, findMaxTimeInNestedReplies(r3, 4)); }          
          if (r4 && typeof r4 === "object") { mx = Math.max(mx, findMaxTimeInNestedReplies(r4, 4)); }          
          if (r5 && typeof r5 === "object") { mx = Math.max(mx, findMaxTimeInNestedReplies(r5, 4)); }          
        
          if (mx > lastTime) lastTime = mx;          
        } catch (eRow) { }          
      });          
    }          
        
    return { countTop: Number(countTop || 0), lastTime: Number(lastTime || 0) };          
  } catch (e0) {          
    return { countTop: 0, lastTime: 0 };          
  }          
}          
        
/* =========================================================================================                    
   DOM Ready                    
   ========================================================================================= */                    
document.addEventListener("DOMContentLoaded", function () {                    
        /* ===============================
     Header Hamburger Menu
     =============================== */
  var hamburgerBtn = document.getElementById("hamburgerBtn");
  var headerMenu = document.getElementById("headerMenu");
  var menuBackdrop = document.getElementById("menuBackdrop");

  function openHeaderMenu() {
    if (!headerMenu || !menuBackdrop || !hamburgerBtn) return;
    headerMenu.style.right = "0";
    menuBackdrop.style.pointerevents = "auto";
    menuBackdrop.style.opacity = "1";
    hamburgerBtn.setAttribute("aria-expanded", "true");
  }

  function closeHeaderMenu() {
    if (!headerMenu || !menuBackdrop || !hamburgerBtn) return;
    headerMenu.style.right = "-200px";
    menuBackdrop.style.pointerevents = "none";
    menuBackdrop.style.opacity = "0";
    
    hamburgerBtn.setAttribute("aria-expanded", "false");
  }

  function toggleHeaderMenu() {
    if (!headerMenu) return;
    if (headerMenu.style.display === "block") closeHeaderMenu();
    else openHeaderMenu();
  }

  if (hamburgerBtn) {
    hamburgerBtn.addEventListener("click", function (e) {
      try { e.preventDefault(); e.stopPropagation(); } catch (x) {}
      toggleHeaderMenu();
    });
  }

  if (menuBackdrop) {
    menuBackdrop.addEventListener("click", function () {
      closeHeaderMenu();
    });
  }

  if (headerMenu) {
    headerMenu.addEventListener("click", function (e) {
      // ×œ×—×™×¦×” ×¢×œ ×œ×™× ×§ -> ×¡×’×™×¨×”
      try {
        var a = e.target.closest("a");
        if (a) closeHeaderMenu();
      } catch (x) {}
    });
  }

  document.addEventListener("keydown", function (e) {
    if (e && e.key === "Escape") closeHeaderMenu();
  });

  document.addEventListener("click", function (e) {
    // ×¡×’×™×¨×” ×‘×œ×—×™×¦×” ××—×•×¥ ×œ×ª×¤×¨×™×˜/×›×¤×ª×•×¨
    try {
      if (!headerMenu || !hamburgerBtn) return;
      if (headerMenu.style.display !== "block") return;

      var inMenu = headerMenu.contains(e.target);
      var inBtn = hamburgerBtn.contains(e.target);
      if (!inMenu && !inBtn) closeHeaderMenu();
    } catch (x) {}
  });
  
  loadPostMetaCache();          
        
  /* ===============================                    
     Elements                    
     =============================== */                    
  var postsEl = document.getElementById("posts");                    
  var indicator = document.getElementById("pull-indicator");                    
        
  var searchBox = document.getElementById("searchBox");                    
  var sortMode = document.getElementById("sortMode");                    
        
  var openCreatePostBtn = document.getElementById("openCreatePost");                    
  var overlay = document.getElementById("createPostOverlay");                    
  var closeCreatePostBtn = document.getElementById("closeCreatePost");                    
  var cancelPostBtn = document.getElementById("cancelPost");                    
  var submitPostBtn = document.getElementById("submitPost");                    
  var newPostTitle = document.getElementById("newPostTitle");                    
  var newPostText = document.getElementById("newPostText");                    
  var createPostError = document.getElementById("createPostError");                    
        
  /* ===============================          
     Image UI elements (×©×“×¨×•×’)          
     =============================== */          
  var newPostImage = document.getElementById("newPostImage");          
  var chooseImageBtn = document.getElementById("chooseImageBtn");          
  var removeImageBtn = document.getElementById("removeImageBtn");          
  var imagePreviewWrap = document.getElementById("imagePreviewWrap");          
  var imagePreview = document.getElementById("imagePreview");          
  var imageChip = document.getElementById("imageChip");          
  var imageWarn = document.getElementById("imageWarn");          
        
  var uploadProgressArea = document.getElementById("uploadProgressArea");          
  var uploadProgressText = document.getElementById("uploadProgressText");          
  var uploadProgressBar = document.getElementById("uploadProgressBar");          
  var newPostImageMeta = document.getElementById("newPostImageMeta");          
        
  if (!postsEl) {                    
    location.replace("forbidden.html");                    
    return;                    
  }                    
        
  /* =====================================================================================          
     Restore sort selection (memory)          
     ===================================================================================== */          
  try {          
    if (sortMode && rememberedSortMode) {          
      sortMode.value = rememberedSortMode;          
    }          
  } catch (eSM) { }          
        
  /* =====================================================================================          
     Image viewer delegation (click image in post card)          
     ===================================================================================== */          
  if (!postsEl.__imgViewerBound) {          
    postsEl.__imgViewerBound = true;          
    postsEl.addEventListener("click", function (e) {          
      // NEW: click on "×™×© ×ª××•× ×”" chip -> open mini preview and stop navigation          
      var chip = null;          
      try { chip = e.target.closest(".has-image-flag"); } catch (errChip) { chip = null; }          
      if (chip) {          
        try { e.preventDefault(); e.stopPropagation(); } catch (eStop) { }          
        try {          
          var postEl = chip.closest(".post");          
          if (postEl) {          
            var u = postEl.getAttribute("data-image") || "";          
            u = sanitizeImageUrl(u);          
        
            // NEW: if no signed url yet but we have path -> fetch signed url then open          
            if (!u) {          
              var pth = safeText(postEl.getAttribute("data-image-path") || "").trim();          
              if (pth) {          
                setStatus("×˜×•×¢×Ÿ ×ª××•× ×”â€¦", "info");          
                fetchSignedUrlForPath(pth, false)          
                  .then(function (r) {          
                    try {          
                      var su = sanitizeImageUrl(r && r.url ? r.url : "");          
                      if (su) {          
                        postEl.setAttribute("data-image", su);          
                        openMiniImagePreview(su);          
                        setStatus("", "info");          
                        return;          
                      }          
                    } catch (eSet) { }          
                    setStatus("×œ× ×”×¦×œ×—×ª×™ ×œ×˜×¢×•×Ÿ ××ª ×”×ª××•× ×”.", "error");          
                  })          
                  .catch(function (err) {          
                    // âœ… UPDATE: show short reason code (still user-friendly)
                    try {
                      var s = safeText(err || "");
                      if (s && s.length > 30) s = s.slice(0, 30);
                      setStatus("×œ× ×”×¦×œ×—×ª×™ ×œ×˜×¢×•×Ÿ ××ª ×”×ª××•× ×”." + (s ? " (" + s + ")" : ""), "error");
                    } catch (eMsg) {
                      setStatus("×œ× ×”×¦×œ×—×ª×™ ×œ×˜×¢×•×Ÿ ××ª ×”×ª××•× ×”.", "error");
                    }
                  });          
                return;          
              }          
            }          
        
            if (u) openMiniImagePreview(u);          
          }          
        } catch (eOpenMini) { }          
        return;          
      }          
        
      var img = null;          
      try { img = e.target.closest(".post-image"); } catch (errX) { img = null; }          
      if (!img) return;          
        
      var src = img.getAttribute("data-full") || img.getAttribute("src") || "";          
      src = sanitizeImageUrl(src);          
      if (!src) return;          
        
      openImageViewer(src);          
    }, false);          
  }          
        
  bindPostNavigation(postsEl);                    
        
  if (searchBox) {                    
    searchBox.addEventListener("input", debounce(function () {                    
      renderPostsFromCache();                    
    }, 120));                    
  }                    
        
  if (sortMode) {                    
    sortMode.addEventListener("change", function () {                    
      try { rememberSortMode(sortMode.value); } catch (eR) { }          
        
      // If user chooses lastComment, ensure we fetch meta properly (full pass once)          
      try {          
        var v = safeText(sortMode.value || "");          
        if (v === "lastComment") {          
          ensureAllPostsMetaForLastCommentSort();          
        }          
      } catch (eLC) { }          
        
      renderPostsFromCache();                    
    });                    
  }                    
        
  /* =====================================================================================          
     Image choose/remove handlers (×©×“×¨×•×’ ××œ×)          
     ===================================================================================== */          
  if (chooseImageBtn && newPostImage) {          
    chooseImageBtn.addEventListener("click", function () {          
      try {          
        newPostImage.value = "";          
        newPostImage.click();          
      } catch (eImg0) { }          
    });          
  }          
        
  if (removeImageBtn) {          
    removeImageBtn.addEventListener("click", function () {          
      clearSelectedImage(true);          
    });          
  }          
        
  /* =====================================================================================          
     Robust DataURL reader with retries (kept as fallback; no longer blocks selection)          
     ===================================================================================== */          
  function readFileAsDataURLWithRetry(file, tries, done) {          
    try {          
      var left = Number(tries || 1);          
      if (left < 1) left = 1;          
        
      var attempt = function () {          
        try {          
          var r = new FileReader();          
          r.onerror = function () {          
            left--;          
            if (left <= 0) { done("", false); return; }          
            setTimeout(attempt, 140);          
          };          
          r.onload = function () {          
            var dataUrl = safeText(r.result || "");          
            if (!dataUrl || dataUrl.indexOf("data:") !== 0) {          
              left--;          
              if (left <= 0) { done("", false); return; }          
              setTimeout(attempt, 140);          
              return;          
            }          
            done(dataUrl, true);          
          };          
          r.readAsDataURL(file);          
        } catch (e1) {          
          left--;          
          if (left <= 0) { done("", false); return; }          
          setTimeout(attempt, 140);          
        }          
      };          
        
      attempt();          
    } catch (e0) {          
      done("", false);          
    }          
  }          
        
  if (newPostImage) {          
    newPostImage.addEventListener("change", function () {          
      try {          
        var f = (newPostImage.files && newPostImage.files[0]) ? newPostImage.files[0] : null;          
        if (!f) return;          
        
        // validation          
        if (!isLikelyImageFile(f)) {          
          createPostErrorShow("×§×•×‘×¥ ×œ× × ×ª××š. ×‘×—×¨ ×ª××•× ×” (JPG/PNG/WebP).");          
          clearSelectedImage(true);          
          return;          
        }          
        
        // size limit (raised to 9MB)          
        var MAX = 9 * 1024 * 1024; // 9MB          
        if (Number(f.size || 0) > MAX) {          
          createPostErrorShow("×”×ª××•× ×” ×’×“×•×œ×” ××“×™ (" + bytesToHuman(f.size) + "). ××•××œ×¥ ×¢×“ 9MB.");          
          clearSelectedImage(true);          
          return;          
        }          
        
        // accept WITHOUT trying to process/optimize - stability first          
        selectedImageFile = f;          
        selectedImagePrepared = null;          
        selectedImageDataUrl = "";          
        if (imageWarn) { imageWarn.style.display = "none"; imageWarn.textContent = ""; }          
        
        try {          
          if (selectedImagePreviewUrl && selectedImagePreviewCanRevoke) {          
            try { URL.revokeObjectURL(selectedImagePreviewUrl); } catch (eRv0) { }          
          }          
        } catch (eRv1) { }          
        selectedImagePreviewUrl = "";          
        selectedImagePreviewCanRevoke = false;          
        
        // UI: show as selected immediately (no more "×œ× ×”×¦×œ×—×ª×™ ×œ×§×¨×•×" blocking selection)          
        try {          
          if (imagePreviewWrap) imagePreviewWrap.style.display = "block";          
          if (removeImageBtn) removeImageBtn.style.display = "inline-block";          
          if (imageChip) { imageChip.style.display = "inline-flex"; imageChip.textContent = "ğŸ–¼ï¸ " + bytesToHuman(f.size); }          
          if (newPostImageMeta) newPostImageMeta.textContent = "× ×‘×—×¨×” ×ª××•× ×”: " + safeText(f.name) + " (" + bytesToHuman(f.size) + ")";          
        } catch (eUI0) { }          
        
        // Preview: try ObjectURL first (most stable for UI), fallback to DataURL (best-effort)          
        getPreviewUrlForFile(f, function (srcUrl, canRevoke) {          
          try {          
            if (srcUrl) {          
              selectedImagePreviewUrl = srcUrl;          
              selectedImagePreviewCanRevoke = !!canRevoke;          
              if (imagePreview) imagePreview.setAttribute("src", selectedImagePreviewUrl);          
              if (imageWarn) { imageWarn.style.display = "none"; imageWarn.textContent = ""; }          
            }          
          } catch (ePrev0) { }          
        
          // IMPORTANT (×’×¨×¡×” ×-×¡×˜×™×™×œ): ×ª××™×“ ×× ×¡×™× ×œ×”×›×™×Ÿ DataURL ×‘×¨×§×¢ ×›×“×™ ×©×”×¢×œ××” ×ª×”×™×” ×‘×©×™×˜×ª data_url        
          // ×–×” ×œ× ×—×•×¡× ××ª ×”××©×ª××© (×œ× ××¤×™×œ ×‘×—×™×¨×”), ×¨×§ ××›×™×Ÿ ×œ×©×œ×‘ ×”×¤×¨×¡×•×.        
          readFileAsDataURLWithRetry(f, 3, function (dataUrl, ok) {          
            try {          
              if (ok && dataUrl) {          
                selectedImageDataUrl = safeText(dataUrl || "");          
                // ×× ××™×Ÿ preview (ObjectURL × ×›×©×œ) - × ×©×ª××© ×‘-DataURL ×›-preview        
                if ((!selectedImagePreviewUrl || !safeText(selectedImagePreviewUrl)) && imagePreview) {          
                  selectedImagePreviewUrl = selectedImageDataUrl;          
                  selectedImagePreviewCanRevoke = false;          
                  imagePreview.setAttribute("src", selectedImagePreviewUrl);          
                }          
                // ××™×Ÿ ×”×•×“×¢×ª ××–×”×¨×” ×× ×”×¦×œ×—× ×• ×œ×§×¨×•× DataURL        
                if (imageWarn) { imageWarn.style.display = "none"; imageWarn.textContent = ""; }          
              } else {          
                // Still accept file; just inform that upload may need fallback        
                if (imageWarn) {          
                  imageWarn.style.display = "block";          
                  imageWarn.textContent = "×œ× × ×™×ª×Ÿ ×œ×”×›×™×Ÿ DataURL ×›×¨×’×¢ â€” × × ×¡×” ×œ×”×¢×œ×•×ª ×‘×©×™×˜×ª ×’×™×‘×•×™ ×‘×¤×¨×¡×•×.";          
                }          
              }          
            } catch (ePrev1) { }          
          });          
        });          
        
      } catch (eImg2) { }          
    });          
  }          
        
  function clearSelectedImage(resetInput) {          
    try {          
      if (selectedImagePreviewUrl && selectedImagePreviewCanRevoke) {          
        try { URL.revokeObjectURL(selectedImagePreviewUrl); } catch (eRv2) { }          
      }          
    } catch (eRv3) { }          
        
    selectedImageFile = null;          
    selectedImagePreviewUrl = "";          
    selectedImagePreviewCanRevoke = false;          
    selectedImagePrepared = null;          
    selectedImageDataUrl = "";          
        
    try {          
      if (imagePreview) imagePreview.setAttribute("src", "");          
      if (imagePreviewWrap) imagePreviewWrap.style.display = "none";          
      if (removeImageBtn) removeImageBtn.style.display = "none";          
      if (imageChip) imageChip.style.display = "none";          
      if (imageWarn) { imageWarn.style.display = "none"; imageWarn.textContent = ""; }          
        
      if (uploadProgressArea) uploadProgressArea.style.display = "none";          
      if (uploadProgressText) uploadProgressText.textContent = "0%";          
      if (uploadProgressBar) uploadProgressBar.style.width = "0%";          
        
      if (resetInput && newPostImage) newPostImage.value = "";          
        
      if (newPostImageMeta) newPostImageMeta.textContent = "×¤×•×¨××˜×™× × ×ª××›×™×: JPG/PNG/WebP. ××•××œ×¥ ×¢×“ 9MB.";          
    } catch (eImg3) { }          
  }          
        
  if (openCreatePostBtn) {                    
    openCreatePostBtn.addEventListener("click", function () {                    
      if (!isAuthed) {                    
        setStatus("×¢×•×“ ×œ× ××•××ª×ª ××•×œ ×”×©×¨×ª. ×—×›×” ×©× ×™×™×” ×•××– × ×¡×” ×©×•×‘.", "error");                    
        return;                    
      }                    
      openCreatePostModal();                    
    });                    
  }                    
        
  if (closeCreatePostBtn) closeCreatePostBtn.addEventListener("click", closeCreatePostModal);                    
  if (cancelPostBtn) cancelPostBtn.addEventListener("click", closeCreatePostModal);                    
        
  if (overlay) {                    
    overlay.addEventListener("click", function (e) {                    
      if (e.target === overlay) closeCreatePostModal();                    
    });                    
  }                    
        
  if (submitPostBtn) {                    
    submitPostBtn.addEventListener("click", function () {                    
      createPostErrorHide();                    
        
      if (!isAuthed) {                    
        createPostErrorShow("××ª×” ×œ× ×××•××ª ×¢×“×™×™×Ÿ. × ×¡×” ×©×•×‘ ×¢×•×“ ×¨×’×¢.");                    
        return;                    
      }                    
        
      // ×× ×™×¢×ª ×“××‘×œ-×¤×¨×¡×•× (×©×“×¨×•×’ - ×ª×™×§×•×Ÿ)          
      if (isPublishingNow) return;          
        
      var t1 = "";                    
      var t2 = "";                    
      if (newPostTitle && typeof newPostTitle.value === "string") t1 = newPostTitle.value;                    
      if (newPostText && typeof newPostText.value === "string") t2 = newPostText.value;                    
        
      var title = safeText(t1).trim();                    
      var text = safeText(t2).trim();                    
        
      if (title.length < 3) {                    
        createPostErrorShow("×›×•×ª×¨×ª ×§×¦×¨×” ××“×™. ××™× ×™××•× 3 ×ª×•×•×™×.");                    
        return;                    
      }                    
      if (text.length < 3) {                    
        createPostErrorShow("×ª×•×›×Ÿ ×§×¦×¨ ××“×™. ××™× ×™××•× 3 ×ª×•×•×™×.");                    
        return;                    
      }                    
        
      // ×× ×™×© ×ª××•× ×” - × ×•×•×“× ×©×”×™× ×¢×“×™×™×Ÿ ×ª×§×™× ×”          
      if (selectedImageFile) {          
        if (!isLikelyImageFile(selectedImageFile)) {          
          createPostErrorShow("×”×ª××•× ×” ×©× ×‘×—×¨×” ×œ× ×ª×§×™× ×”. ×‘×—×¨ ×ª××•× ×” ××—×“×©.");          
          clearSelectedImage(true);          
          return;          
        }          
        var MAX2 = 9 * 1024 * 1024;          
        if (Number(selectedImageFile.size || 0) > MAX2) {          
          createPostErrorShow("×”×ª××•× ×” ×’×“×•×œ×” ××“×™. ×‘×—×¨ ×ª××•× ×” ×§×˜× ×” ×™×•×ª×¨.");          
          return;          
        }          
      }          
        
      publishPost(title, text);                    
    });                    
  }                    
        
  /* =====================================================================================                    
     4) Pull To Refresh â€“ × ×©××¨ ×‘×“×™×•×§                    
     ===================================================================================== */                    
  document.addEventListener("touchstart", function (e) {                    
    try {                    
      if (window.scrollY === 0 && !isRefreshing) {                    
        pullStartY = e.touches[0].clientY;                    
        pulling = true;                    
        didTriggerRefresh = false;                    
      }                    
    } catch (err1) { }                    
  }, { passive: true });                    
        
  document.addEventListener("touchmove", function (e) {                    
    if (!pulling || isRefreshing) return;                    
        
    var diff = e.touches[0].clientY - pullStartY;                    
    if (diff <= 0) return;                    
        
    if (indicator) indicator.style.display = "block";                    
        
    var THRESHOLD = 90;                    
    if (diff > THRESHOLD && !didTriggerRefresh) {                    
      didTriggerRefresh = true;                    
      pulling = false;                    
      isRefreshing = true;                    
        
      try { sessionStorage.removeItem("cachedPosts"); } catch (err2) { }                    
        
      loadPosts(true);                    
    }                    
  }, { passive: true });                    
        
  document.addEventListener("touchend", function () {                    
    pulling = false;                    
    if (!isRefreshing && indicator) indicator.style.display = "none";                    
  }, { passive: true });                    
        
  /* =====================================================================================                    
     5) Start Auth Flow                    
     ===================================================================================== */                    
  waitForPayload();                    
        
  function waitForPayload() {                    
    var raw = "";                    
    try {                    
      raw = window.AppInventor.getWebViewString();                    
      if (!raw) {                    
        setTimeout(waitForPayload, 200);                    
        return;                    
      }                    
      payload = JSON.parse(raw);                    
    } catch (e) {                    
      setTimeout(waitForPayload, 200);                    
      return;                    
    }                    
        
    loginToFirebase(payload);                    
  }                    
        
  function loginToFirebase(data) {                    
    if (!data || !data.email || !data.password || !data.token) {                    
      location.replace("forbidden.html");                    
      return;                    
    }                    
        
    firebase.auth()                    
      .signInWithEmailAndPassword(data.email, data.password)                    
      .then(function (c) {                    
        validateToken(c.user.uid, data.token);                    
      })                    
      .catch(function () {                    
        location.replace("forbidden.html");                    
      });                    
  }                    
        
  function validateToken(userId, token) {                    
    firebase.database()                    
      .ref("forum A/sessions/" + userId + "/token")                    
      .once("value")                    
      .then(function (snap) {                    
        if (!snap.exists() || snap.val() !== token) {                    
          location.replace("forbidden.html");                    
          return;                    
        }                    
        
        uid = userId;                    
        isAuthed = true;                    
        
        firebase.database()                    
          .ref("forum A/users/" + uid + "/username")                    
          .once("value")                    
          .then(function (uSnap) {                    
            realUsername = uSnap.val() || "××©×ª××©";   
startPresenceTracking();                 
            setStatus("××—×•×‘×¨ ×›Ö¾" + realUsername, "ok");                    
        
            loadPosts(false);                    
            attachLivePostListeners();                    
          })                    
          .catch(function () {                    
            realUsername = "××©×ª××©";                    
            setStatus("××—×•×‘×¨", "ok");                    
            loadPosts(false);                    
            attachLivePostListeners();                    
          });                    
      })                    
      .catch(function () {                    
        location.replace("forbidden.html");                    
      });                    
  }                    
        
  function loadPosts(fromRefresh) {                    
    if (fromRefresh === undefined || fromRefresh === null) fromRefresh = false;                    
    setStatus(fromRefresh ? "××¨×¢× ×Ÿ ×¤×•×¡×˜×™×â€¦" : "×˜×•×¢×Ÿ ×¤×•×¡×˜×™×â€¦", "info");                    
        
    firebase.database()                    
      .ref("forum A/posts")                    
      .orderByChild("time")                    
      .limitToLast(300)                    
      .once("value")                    
      .then(function (snap) {                    
        var items = [];                    
        
        snap.forEach(function (pSnap) {                    
          var p = pSnap.val() || {};                    
          var postId = pSnap.key;                    
        
          var cachedMeta = getMetaForPost(postId) || {};          
          var cc = (p.commentsCount !== undefined && p.commentsCount !== null) ? Number(p.commentsCount || 0) : cachedMeta.commentsCount;          
          var lct = (p.lastCommentTime !== undefined && p.lastCommentTime !== null) ? Number(p.lastCommentTime || 0) : cachedMeta.lastCommentTime;          
    
          var imgPath = safeText(p.imagePath || "");          
          var legacyUrl = sanitizeImageUrl(p.image || "");          
        
          items.push({                    
            id: postId,                    
            title: safeText(p.title),                    
            text: safeText(p.text),                    
            author: safeText(p.author),                    
            time: Number(p.time || 0),                    
            likes: Number(p.likes || 0),                    
            commentsCount: (cc === undefined ? null : (cc === null ? null : Number(cc || 0))),          
            lastCommentTime: (lct === undefined ? 0 : Number(lct || 0)),          
            imagePath: safeText(imgPath || ""),          
            image: legacyUrl                    
          });                    
        });                    
        
        items.sort(function (a, b) { return (b.time || 0) - (a.time || 0); });                    
        
        postsCacheData = items;                    
        
        // If lastComment sort is selected, ensure we run the full meta fetch once          
        try {          
          var modeNow = safeText(sortMode && sortMode.value ? sortMode.value : rememberedSortMode);          
          if (modeNow === "lastComment") {          
            ensureAllPostsMetaForLastCommentSort();          
          }          
        } catch (eLM0) { }          
        
        renderPostsFromCache();                    
        
        try { sessionStorage.setItem("cachedPosts", renderedHtmlCache); } catch (e2) { }                    
        
        if (fromRefresh) {                    
          setTimeout(function () {                    
            isRefreshing = false;                    
            if (indicator) indicator.style.display = "none";                    
            setStatus("×¢×•×“×›×Ÿ ×‘×”×¦×œ×—×”.", "ok");                    
          }, 250);                    
        } else {                    
          setStatus("×¤×•×¡×˜×™× × ×˜×¢× ×•.", "ok");                    
        }                    
        
        // After initial render, ensure visible meta listeners + queue meta load          
        try {          
          ensureVisibleMetaAndFetch();          
        } catch (eVM0) { }          
      })                    
      .catch(function () {                    
        location.replace("forbidden.html");                    
      });                    
  }                    
        
  function renderPostsFromCache() {                    
    var q = "";                    
    var mode = "newest";                    
        
    if (searchBox && typeof searchBox.value === "string") q = searchBox.value;                    
    q = safeText(q).trim().toLowerCase();                    
        
    if (sortMode && typeof sortMode.value === "string") mode = sortMode.value;                    
    mode = safeText(mode) || "newest";                    
        
    var list = postsCacheData.slice();                    
        
    if (q) {                    
      list = list.filter(function (p) {                    
        var t = (p.title || "").toLowerCase();                    
        var x = (p.text || "").toLowerCase();                    
        var a = (p.author || "").toLowerCase();          
        var im = ((p.image || "") + " " + (p.imagePath || "")).toLowerCase();          
        var hasImg = im ? "×ª××•× ×”" : "";          
        return t.indexOf(q) !== -1 || x.indexOf(q) !== -1 || a.indexOf(q) !== -1 || hasImg.indexOf(q) !== -1;                    
      });                    
    }                    
        
    if (mode === "oldest") {                    
      list.sort(function (a, b) { return (a.time || 0) - (b.time || 0); });                    
    } else if (mode === "author") {                    
      list.sort(function (a, b) { return (a.author || "").localeCompare(b.author || "", "he"); });                    
    } else if (mode === "title") {                    
      list.sort(function (a, b) { return (a.title || "").localeCompare(b.title || "", "he"); });                    
    } else if (mode === "lastComment") {          
      // Requested behavior:        
      // 1) If we have a saved order -> show it immediately (stable)          
      // 2) After meta ready -> do real sort by lastCommentTime          
      if (lastCommentMetaReady) {          
        list.sort(function (a, b) {          
          var ta = Number(a.lastCommentTime || 0) || 0;          
          var tb = Number(b.lastCommentTime || 0) || 0;          
          if (!ta) ta = Number(a.time || 0) || 0;          
          if (!tb) tb = Number(b.time || 0) || 0;          
          return tb - ta;          
        });          
        // save order each time meta-ready sort runs (keeps memory across nav/refresh)          
        try {          
          var idsSave = [];          
          for (var s1 = 0; s1 < list.length; s1++) { if (list[s1] && list[s1].id) idsSave.push(list[s1].id); }          
          lastCommentSavedOrder = idsSave;          
          saveLastCommentSavedOrder(idsSave);          
        } catch (eSaveOrd) { }          
      } else {          
        // meta not ready: use saved order if exists; fallback keep current order          
        if (lastCommentSavedOrder && lastCommentSavedOrder.length) {          
          var idxMap = {};          
          for (var si = 0; si < lastCommentSavedOrder.length; si++) idxMap[lastCommentSavedOrder[si]] = si;          
          list.sort(function (a, b) {          
            var ia = (idxMap[a.id] !== undefined) ? idxMap[a.id] : 999999;          
            var ib = (idxMap[b.id] !== undefined) ? idxMap[b.id] : 999999;          
            if (ia !== ib) return ia - ib;          
            return (Number(b.time || 0) || 0) - (Number(a.time || 0) || 0);          
          });          
        } else {          
          // keep current order (do nothing)          
        }          
      }          
    } else {                    
      list.sort(function (a, b) { return (b.time || 0) - (a.time || 0); });                    
    }                    
        
    var html = "";                    
        
    if (!list.length) {                    
      html = q ? "<p>×œ× × ××¦××• ×ª×•×¦××•×ª ×œ×—×™×¤×•×©.</p>" : "<p>××™×Ÿ ×¢×“×™×™×Ÿ ×¤×•×¡×˜×™×.</p>";                    
    } else {                    
      for (var i = 0; i < list.length; i++) {                    
        html += buildPostCardHTML(list[i]);                    
      }                    
    }                    
        
    postsEl.innerHTML = html;                    
    renderedHtmlCache = html;                    
        
    // Track rendered ids for meta listeners and background fetch          
    try {          
      lastRenderedListIds = [];          
      for (var j = 0; j < list.length; j++) {          
        if (list[j] && list[j].id) lastRenderedListIds.push(list[j].id);          
      }          
    } catch (eIds) {          
      lastRenderedListIds = [];          
    }          
        
    // keep cache of posts html          
    try { sessionStorage.setItem("cachedPosts", renderedHtmlCache); } catch (eC) { }          
        
    // after render: ensure visible meta / live update          
    try {          
      ensureVisibleMetaAndFetch();          
    } catch (eVM1) { }          
  }                    
        
 function formatCommentsCountText(n, unknown) {
  try {
    if (unknown) return "×˜×•×¢×Ÿ ×ª×’×•×‘×•×ªâ€¦";

    var x = Number(n || 0);

    if (!x) return "××™×Ÿ ×ª×’×•×‘×•×ª";
    if (x === 1) return "×ª×’×•×‘×” ××—×ª";

    return "\u200F" + x + " ×ª×’×•×‘×•×ª";
  } catch (e) {
    return "××™×Ÿ ×ª×’×•×‘×•×ª";
  }
}


        
  function buildPostCardHTML(p) {          
    // NOTE: this function was previously modified with non-existing postsMetaMap/scheduleSaveMeta.        
    // We keep it selective and compatible with the rest of this file (no security changes).        
        
    var title = escapeHTML(p.title || "");        
    var text = escapeHTML(p.text || "");        
    var author = escapeHTML(p.author || "");        
    var idRaw = safeText(p.id || "");        
    var id = escapeHTML(idRaw);        
        
    var timeStr = "";        
    if (p.time) {        
      try {        
        timeStr = new Date(p.time).toLocaleString("he-IL", {        
          hour: "2-digit",        
          minute: "2-digit",        
          day: "2-digit",        
          month: "2-digit"        
        });        
      } catch (e) {        
        timeStr = "";        
      }        
    }        
        
    // Comments count: top-level only (reply doesn't count)          
    // Unknown state (null) will show "×˜×•×¢×Ÿ ×ª×’×•×‘×•×ªâ€¦"          
    var unknownComments = (p.commentsCount === null || p.commentsCount === undefined);        
    var commentsCount = unknownComments ? 0 : Number(p.commentsCount || 0);        
    var commentsText = formatCommentsCountText(commentsCount, unknownComments);        
        
    var authorColor = safeText(p.authorColor || userColor(p.author || ""));        
    var escAuthorColor = escapeHTML(authorColor);        
        
    // Image: new secure path + legacy url fallback          
    var imgPath = safeText(p.imagePath || "").trim();        
    var imgUrl = sanitizeImageUrl(p.image || "");        
    var signed = "";        
    if (imgPath) signed = SignedUrlCache.get(imgPath) || "";        
    if (!signed && imgUrl) signed = imgUrl; // legacy support        
    
    var hasImage = !!((imgPath && imgPath.length) || (imgUrl && imgUrl.length));        
        
    /* ---------------------------------------------------------        
       ×ª×’ "×™×© ×ª××•× ×”" â€“ ××•×¤×™×¢ ×¨×§ ×× ×™×© ×ª××•× ×”        
       ××™×Ÿ placeholder â†’ ××™×Ÿ ×¨×•×•×— ××ª        
       ×œ×—×™×¦×” ×ª×¤×ª×— preview ×§×˜×Ÿ (×××•××© ×‘×“×œ×™×’×¦×™×” ×œ××¢×œ×”)        
       --------------------------------------------------------- */        
    var imageBadgeHtml = "";        
    if (hasImage) {        
      imageBadgeHtml =        
        '<span class="has-image-flag" title="×œ×—×¥ ×œ×ª×¦×•×’×” ××§×“×™××”">×ª××•× ×”</span>';        
    }        
        
    /* ---------------------------------------------------------        
       Sync meta cache (selective, no breaking references)        
       --------------------------------------------------------- */        
    try {        
      // Previously:        
      // if (!postsMetaMap[p.id]) postsMetaMap[p.id] = {};        
      // postsMetaMap[p.id].commentsCount = commentsCount;        
      // postsMetaMap[p.id].lastCommentTime = Number(p.lastCommentTime || 0);        
      // scheduleSaveMeta();        
      // Now:        
      setMetaForPost(idRaw, {        
        commentsCount: (unknownComments ? 0 : commentsCount),        
        lastCommentTime: Number(p.lastCommentTime || 0)        
      });        
    } catch (eMeta) {}        
        
    /* ---------------------------------------------------------        
       HTML        
       - data-image is used for the mini preview click (signed url when available)        
       - data-image-path is used to fetch signed url on demand (secure)        
       - border color per author        
       --------------------------------------------------------- */        
    return (        
      '\n      <div class="post" data-id="' + id + '" data-image="' + escapeHTML(signed || "") + '" data-image-path="' + escapeHTML(imgPath || "") + '" ' +        
        'style="border-right:4px solid ' + escAuthorColor + ';">' +        
        
      '\n        <h3><span class="post-title-content">' + title + '</span></h3>' +        
      '\n        <div class="post-content">' + text + '</div>' +        
        
      '\n        <div class="post-meta-row">' +        
        
      '\n          <div class="post-meta-left">' +        
                     imageBadgeHtml +        
      '\n            <small class="post-time-small">' + escapeHTML(timeStr) + '</small>' +        
      '\n          </div>' +        
        
      '\n          <div class="post-meta-right" style="text-align:right;">' +        
      '\n            <small id="author-line-' + id + '" class="post-author-colored" ' +        
                       'style="color:' + escAuthorColor + ';">' +        
                       '×××ª: ' + author +        
      '\n            </small>' +        
      '\n            <small class="post-comments-count" ' +        
                       'id="comments-count-' + id + '">' +        
                       escapeHTML(commentsText) +        
      '\n            </small>' +        
      '\n          </div>' +        
        
      '\n        </div>' +        
      '\n      </div>\n'        
    );        
  }                    
        
  function bindPostNavigation(container) {                    
    if (container.__navBound) return;                    
    container.__navBound = true;                    
        
    container.addEventListener("click", function (e) {                    
      if (isRefreshing || pulling) return;                    
        
      // If click was on "×™×© ×ª××•× ×”" chip: navigation blocked in imgViewerBound handler.        
      // Still keep extra guard here (selective, prevents edge cases).        
      try {          
        var chip = e.target && e.target.closest ? e.target.closest(".has-image-flag") : null;          
        if (chip) return;          
      } catch (eChip2) { }          
        
      var postEl = null;                    
      try { postEl = e.target.closest(".post"); } catch (err) { postEl = null; }                    
      if (!postEl) return;                    
        
      // ×× ×œ×—×¦×• ×¢×œ ×ª××•× ×” - ××œ ×ª× ×•×•×˜, ×–×” ×¤×•×ª×— viewer (× ×©××¨ ×ª××™××•×ª)          
      try {          
        var inImg = e.target && (e.target.classList && e.target.classList.contains("post-image"));          
        if (inImg) return;          
      } catch (eN) { }          
        
      var id = postEl.getAttribute("data-id");                    
      if (!id) return;                    
        
      var now = Date.now();                    
      if (now - lastNavAt < 350 && lastOpenId === id) return;                    
        
      lastNavAt = now;                    
      lastOpenId = id;                    
        
      openPost(id, postEl);                    
    }, false);                    
  }                    
        
  function openPost(postId, el) {                    
    try {                    
      var titleEl = el.querySelector(".post-title-content");
var textEl  = el.querySelector(".post-content");                  
        
      // IMPORTANT FIX: author must not be taken from the first <small> anymore          
      // (because meta-left can have "×™×© ×ª××•× ×”" and time).          
      var author = "";          
      try {          
        var aEl = el.querySelector("#author-line-" + CSS.escape(postId));          
        if (aEl) author = (aEl.innerText || "").replace("×××ª:", "").trim();          
      } catch (eEsc) {          
        // fallback if CSS.escape not available          
        try {          
          var aEl2 = el.querySelector('[id="author-line-' + postId + '"]');          
          if (aEl2) author = (aEl2.innerText || "").replace("×××ª:", "").trim();          
        } catch (eEsc2) { }          
      }          
        
      var title = titleEl ? (titleEl.innerText || "") : "";
var text = textEl ? (textEl.innerText || "") : "";                 
        
      // keep image info in cache for post page          
      var imageUrl = "";          
      var imagePath = "";          
      try {          
        imageUrl = sanitizeImageUrl(el.getAttribute("data-image") || "");          
      } catch (eDI) { imageUrl = ""; }          
      try {          
        imagePath = safeText(el.getAttribute("data-image-path") || "").trim();          
      } catch (eDP) { imagePath = ""; }          
        
      if (!imageUrl) {          
        try {          
          var found = null;          
          for (var i = 0; i < postsCacheData.length; i++) {          
            if (postsCacheData[i] && postsCacheData[i].id === postId) {          
              found = postsCacheData[i];          
              break;          
            }          
          }          
          if (found) {          
            if (!imagePath) imagePath = safeText(found.imagePath || "").trim();          
            if (!imageUrl) imageUrl = sanitizeImageUrl(found.image || "");          
          }          
        } catch (eImg) { imageUrl = ""; }          
      }          
    
      // NEW: if we have imagePath but no url, prefetch once (best effort)          
      if (imagePath && !imageUrl) {          
        try {          
          fetchSignedUrlForPath(imagePath, false)          
            .then(function (r) {          
              try {          
                var su = sanitizeImageUrl(r && r.url ? r.url : "");          
                if (su) {          
                  el.setAttribute("data-image", su);          
                  imageUrl = su;          
                  sessionStorage.setItem("currentPost", JSON.stringify({                    
                    id: postId,                    
                    title: title || "",                    
                    text: text || "",                    
                    author: author || "",          
                    image: imageUrl || "",                    
                    imagePath: imagePath || ""                    
                  }));                    
                  location.href = "post.html?postId=" + encodeURIComponent(postId);                    
                } else {          
                  // fallback navigation without url          
                  sessionStorage.setItem("currentPost", JSON.stringify({                    
                    id: postId,                    
                    title: title || "",                    
                    text: text || "",                    
                    author: author || "",          
                    image: imageUrl || "",                    
                    imagePath: imagePath || ""                    
                  }));                    
                  location.href = "post.html?postId=" + encodeURIComponent(postId);                    
                }          
              } catch (eSS) {          
                sessionStorage.setItem("currentPost", JSON.stringify({                    
                  id: postId,                    
                  title: title || "",                    
                  text: text || "",                    
                  author: author || "",          
                  image: imageUrl || "",                    
                  imagePath: imagePath || ""                    
                }));                    
                location.href = "post.html?postId=" + encodeURIComponent(postId);                    
              }          
            })          
            .catch(function () {          
              sessionStorage.setItem("currentPost", JSON.stringify({                    
                id: postId,                    
                title: title || "",                    
                text: text || "",                    
                author: author || "",          
                image: imageUrl || "",                    
                imagePath: imagePath || ""                    
              }));                    
              location.href = "post.html?postId=" + encodeURIComponent(postId);                    
            });          
          return;          
        } catch (ePF) { }          
      }          
        
      sessionStorage.setItem("currentPost", JSON.stringify({                    
        id: postId,                    
        title: title || "",                    
        text: text || "",                    
        author: author || "",          
        image: imageUrl || "",                    
        imagePath: imagePath || ""                    
      }));                    
    } catch (e) { }                    
        
    location.href = "post.html?postId=" + encodeURIComponent(postId);                    
  }   
function startPresenceTracking() {
  if (!uid || !isAuthed) return;

  presenceStartAt = Date.now();
  presenceRef = firebase.database().ref("forum A/presence/" + uid);

  presenceRef.update({
    username: realUsername || "××©×ª××©",
    isOnline: true,
    connectedAt: presenceStartAt,
    lastSeen: presenceStartAt
  });

  presenceHeartbeatTimer = setInterval(function () {
    presenceRef.update({
      lastSeen: Date.now()
    });
  }, 10000);

  presenceRef.onDisconnect().update({
    isOnline: false,
    lastSeen: firebase.database.ServerValue.TIMESTAMP
  });
}

function stopPresenceTracking() {
  if (!presenceRef || !presenceStartAt) return;

  var sessionTime = Math.floor((Date.now() - presenceStartAt) / 1000);

  presenceRef.update({
    lastSeen: Date.now(),
    sessionTime: sessionTime,
    totalTime: firebase.database.ServerValue.increment(sessionTime)
  });
  if (presenceHeartbeatTimer) {
    clearInterval(presenceHeartbeatTimer);
    presenceHeartbeatTimer = null;
  }
}                 
        
  function openCreatePostModal() {                    
    createPostErrorHide();                    
    if (newPostTitle) newPostTitle.value = "";                    
    if (newPostText) newPostText.value = "";                    
        
    // reset image (×©×“×¨×•×’)          
    clearSelectedImage(true);          
    isPublishingNow = false;          
        
    if (overlay) overlay.style.display = "flex";                    
        
    setTimeout(function () {                    
      try { if (newPostTitle) newPostTitle.focus(); } catch (e) { }                    
    }, 50);                    
  }                    
        
  function closeCreatePostModal() {                    
    createPostErrorHide();                    
    if (overlay) overlay.style.display = "none";                    
        
    // reset image (×©×“×¨×•×’)          
    clearSelectedImage(true);          
    isPublishingNow = false;          
  }                    
        
  function createPostErrorShow(msg) {                    
    if (!createPostError) return;                    
    createPostError.textContent = msg;                    
    createPostError.style.display = "block";                    
  }                    
        
  function createPostErrorHide() {                    
    if (!createPostError) return;                    
    createPostError.textContent = "";                    
    createPostError.style.display = "none";                    
  }                    
        
  function setUploadProgress(pct) {          
    try {          
      var x = Math.max(0, Math.min(100, Number(pct || 0)));          
      if (uploadProgressArea) uploadProgressArea.style.display = "block";          
      if (uploadProgressText) uploadProgressText.textContent = x + "%";          
      if (uploadProgressBar) uploadProgressBar.style.width = x + "%";          
    } catch (e) { }          
  }                    
        
  function publishPost(title, text) {                    
    if (!isAuthed || !uid) {                    
      createPostErrorShow("××ª×” ×œ× ×××•××ª. × ×¡×” ×©×•×‘.");                    
      return;                    
    }                    
        
    // ×× ×™×¢×ª ×“××‘×œ-×¤×¨×¡×•× (×©×“×¨×•×’ - ×ª×™×§×•×Ÿ)          
    if (isPublishingNow) return;          
    isPublishingNow = true;          
        
    var btn = submitPostBtn;                    
    if (btn) btn.disabled = true;                    
        
    var postObj = {                    
      title: title,                    
      text: text,                    
      author: realUsername,                    
      time: nowTs(),          
      image: null,          
      imagePath: null          
      /*          
        NOTE: we do not force lastCommentTime/commentsCount here.          
        Forum page will compute meta reliably even if old posts don't have these fields.          
      */          
    };                    
        
    var postsRef = firebase.database().ref("forum A/posts");          
    var newRef = postsRef.push();          
    var postId = newRef.key;          
        
    if (!selectedImageFile) {          
      postObj.image = null;          
      postObj.imagePath = null;          
        
      newRef.set(postObj)          
        .then(function () {                    
          closeCreatePostModal();                    
          setStatus("×”×¤×•×¡×˜ ×¤×•×¨×¡× ×‘×”×¦×œ×—×”.", "ok");                    
        
          try { sessionStorage.setItem("cachedPosts", renderedHtmlCache); } catch (e3) { }                    
          try { window.scrollTo({ top: 0, behavior: "smooth" }); } catch (e4) { window.scrollTo(0, 0); }                    
        })                    
        .catch(function () {                    
          createPostErrorShow("×©×’×™××” ×‘×¤×¨×¡×•×. × ×¡×” ×©×•×‘.");                    
        })                    
        .finally(function () {                    
          if (btn) btn.disabled = false;          
          isPublishingNow = false;          
        });          
        
      return;          
    }          
        
    setStatus("××›×™×Ÿ ×ª××•× ×”â€¦", "info");          
    setUploadProgress(1);          
    
    // NEW: Optimize on publish (not on selection) for stability on weak phones          
    prepareImageForUpload(selectedImageFile, imageWarn)          
      .then(function (prepared) {          
        selectedImagePrepared = prepared || null;          
        
        var blobToUpload = (selectedImagePrepared && selectedImagePrepared.blob) ? selectedImagePrepared.blob : selectedImageFile;          
        var ct = (selectedImagePrepared && selectedImagePrepared.contentType) ? selectedImagePrepared.contentType : safeText(selectedImageFile.type || "");          
        var ext0 = (selectedImagePrepared && selectedImagePrepared.ext) ? safeText(selectedImagePrepared.ext || "") : "";          
        
        if (!ext0) {          
          try {          
            var n0 = safeText(selectedImageFile.name || "");          
            if (n0.indexOf(".") !== -1) ext0 = n0.split(".").pop().toLowerCase();          
          } catch (eExt) { ext0 = "jpg"; }          
        }          
        
        setStatus("××¢×œ×” ×ª××•× ×”â€¦", "info");          
        setUploadProgress(2);          
        
        return uploadPostImageToPathEx(blobToUpload, ct, ext0, postId, uid, function (pct) {          
          setUploadProgress(pct);          
        });          
      })          
      .then(function (imagePath) {          
        postObj.image = null;          
        postObj.imagePath = safeText(imagePath || "");          
        
        setStatus("×©×•××¨ ×¤×•×¡×˜â€¦", "info");          
        setUploadProgress(100);          
        
        return newRef.set(postObj);          
      })          
      .then(function () {          
        closeCreatePostModal();                    
        setStatus("×”×¤×•×¡×˜ ×¤×•×¨×¡× ×‘×”×¦×œ×—×”.", "ok");                    
        
        try { sessionStorage.setItem("cachedPosts", renderedHtmlCache); } catch (e3) { }                    
        try { window.scrollTo({ top: 0, behavior: "smooth" }); } catch (e4) { window.scrollTo(0, 0); }                    
      })          
      .catch(function (err) {          
        try {          
          if (postId) firebase.database().ref("forum A/posts/" + postId).remove();          
        } catch (eRm) { }          
        
        var msg = "×©×’×™××” ×‘×”×¢×œ××ª ×ª××•× ×”/×¤×¨×¡×•×. × ×¡×” ×©×•×‘.";          
        if (safeText(err) === "upload_timeout") msg = "×”×¢×œ××ª ×ª××•× ×” × ×ª×§×¢×” (Timeout). × ×¡×” ×©×•×‘.";          
        if (safeText(err) === "read_failed") msg = "×©×’×™××” ×‘×§×¨×™××ª ×”×ª××•× ×” (DataURL). × ×¡×” ×œ×‘×—×•×¨ ×©×•×‘.";          
        
        createPostErrorShow(msg);          
        setStatus("×©×’×™××” ×‘×¤×¨×¡×•×.", "error");          
      })          
      .finally(function () {          
        if (uploadProgressArea) uploadProgressArea.style.display = "none";          
        if (btn) btn.disabled = false;          
        isPublishingNow = false;          
      });          
  }                    
        
  function attachLivePostListeners() {                    
    if (window.__postsLiveAttached) return;                    
    window.__postsLiveAttached = true;                    
        
    var ref = firebase.database().ref("forum A/posts").orderByChild("time").limitToLast(50);                    
        
    ref.on("child_added", function (snap) {                    
      var id = snap.key;                    
      var v = snap.val() || {};                    
        
      var cachedMeta = getMetaForPost(id) || {};          
      var cc = (v.commentsCount !== undefined && v.commentsCount !== null) ? Number(v.commentsCount || 0) : cachedMeta.commentsCount;          
      var lct = (v.lastCommentTime !== undefined && v.lastCommentTime !== null) ? Number(v.lastCommentTime || 0) : cachedMeta.lastCommentTime;          
        
      var item = {                    
        id: id,                    
        title: safeText(v.title),                    
        text: safeText(v.text),                    
        author: safeText(v.author),                    
        time: Number(v.time || 0),                    
        likes: Number(v.likes || 0),                    
        commentsCount: (cc === undefined ? null : (cc === null ? null : Number(cc || 0))),          
        lastCommentTime: (lct === undefined ? 0 : Number(lct || 0)),          
        imagePath: safeText(v.imagePath || ""),          
        image: sanitizeImageUrl(v.image || "")                    
      };                    
        
      for (var i = 0; i < postsCacheData.length; i++) {                    
        if (postsCacheData[i] && postsCacheData[i].id === id) return;                    
      }                    
        
      postsCacheData.unshift(item);                    
        
      if (!isRefreshing) {                    
        renderPostsFromCache();                    
        try { sessionStorage.setItem("cachedPosts", renderedHtmlCache); } catch (e5) { }                    
      }                    
    });                    
        
    ref.on("child_changed", function (snap) {                    
      var id = snap.key;                    
      var v = snap.val() || {};                    
        
      var idx = -1;                    
      for (var i = 0; i < postsCacheData.length; i++) {                    
        if (postsCacheData[i] && postsCacheData[i].id === id) { idx = i; break; }                    
      }                    
      if (idx === -1) return;                    
        
      var prev = postsCacheData[idx] || {};          
      var cachedMeta = getMetaForPost(id) || {};          
        
      var cc = (v.commentsCount !== undefined && v.commentsCount !== null) ? Number(v.commentsCount || 0) : (prev.commentsCount !== undefined ? prev.commentsCount : cachedMeta.commentsCount);          
      var lct = (v.lastCommentTime !== undefined && v.lastCommentTime !== null) ? Number(v.lastCommentTime || 0) : (prev.lastCommentTime !== undefined ? prev.lastCommentTime : cachedMeta.lastCommentTime);          
        
      postsCacheData[idx] = {                    
        id: id,                    
        title: safeText(v.title),                    
        text: safeText(v.text),                    
        author: safeText(v.author),                    
        time: Number(v.time || prev.time || 0),                    
        likes: Number(v.likes || prev.likes || 0),                    
        commentsCount: (cc === undefined ? null : (cc === null ? null : Number(cc || 0))),          
        lastCommentTime: (lct === undefined ? 0 : Number(lct || 0)),          
        imagePath: safeText(v.imagePath || prev.imagePath || ""),          
        image: sanitizeImageUrl(v.image || prev.image || "")                    
      };                    
        
      // keep meta cache in sync          
      try {          
        if (cc !== undefined && cc !== null) setMetaForPost(id, { commentsCount: Number(cc || 0) });          
        if (lct !== undefined && lct !== null) setMetaForPost(id, { lastCommentTime: Number(lct || 0) });          
      } catch (eSync) { }          
        
      if (!isRefreshing) {                    
        renderPostsFromCache();                    
        try { sessionStorage.setItem("cachedPosts", renderedHtmlCache); } catch (e6) { }                    
      }                    
    });                    
  }                    
        
  /* =========================================================================================          
     THIRD ROUND FIXES: Meta fetching + lastComment sorting done right          
     + replies bump lastCommentTime, do not count as commentsCount          
     ========================================================================================= */          
        
  function enqueueMeta(postId) {          
    try {          
      var id = safeText(postId || "");          
      if (!id) return;          
        
      // Avoid duplicates in queue          
      for (var i = 0; i < metaQueue.length; i++) {          
        if (metaQueue[i] === id) return;          
      }          
        
      metaQueue.push(id);          
    } catch (e) { }          
  }          
        
  function drainMetaQueue() {          
    try {          
      while (metaInFlight < META_CONCURRENCY && metaQueue.length) {          
        var id = metaQueue.shift();          
        if (!id) continue;          
        metaInFlight++;          
        
        fetchMetaForPost(id)          
          .catch(function () { })          
          .finally(function () {          
            metaInFlight--;          
            drainMetaQueue();          
        
            // If this was the "fetch all" run for lastComment: finish + resort once at the end          
            if (metaFetchAllRunning) {          
              if (metaInFlight === 0 && metaQueue.length === 0) {          
                metaFetchAllRunning = false;          
                setLastCommentMetaReady(true);          
        
                // Now that ALL meta is ready, we can safely sort by lastCommentTime          
                try {          
                  renderPostsFromCache();          
                  setStatus("×¢×•×“×›×Ÿ ××™×•×Ÿ ×œ×¤×™ ×ª×’×•×‘×” ××—×¨×•× ×”.", "ok");          
                } catch (eEnd) { }          
              }          
            }          
          });          
      }          
    } catch (e) { }          
  }          
        
  function fetchMetaForPost(postId) {          
    return new Promise(function (resolve, reject) {          
      try {          
        if (!isAuthed) { resolve(); return; }          
        var id = safeText(postId || "");          
        if (!id) { resolve(); return; }          
        
        // Load comments snapshot once => count + lastTime (including replies)          
        firebase.database()          
          .ref("forum A/comments/" + id)          
          .once("value")          
          .then(function (snap) {          
            var meta = computeMetaFromCommentsSnapshot(snap);          
            var count = Number(meta.countTop || 0);          
            var lastTime = Number(meta.lastTime || 0);          
        
            /* =================================================================================          
               âœ… FIX (minimal): never let comments-derived lastTime LOWER the posts lastCommentTime          
               - posts/{id}/lastCommentTime may include replies bump (post.html)          
               - comments snapshot might be behind (especially when replies are in separate path)          
               ================================================================================= */          
            var prevMeta = getMetaForPost(id) || {};          
            var prevLast = Number(prevMeta.lastCommentTime || 0) || 0;          
            var prevItemLast = 0;          
            for (var z = 0; z < postsCacheData.length; z++) {          
              if (postsCacheData[z] && postsCacheData[z].id === id) {          
                prevItemLast = Number(postsCacheData[z].lastCommentTime || 0) || 0;          
                break;          
              }          
            }          
            var mergedLast = Math.max(prevLast, prevItemLast, lastTime);          
        
            // Update cache          
            setMetaForPost(id, { commentsCount: count, lastCommentTime: mergedLast });          
        
            // Update postsCacheData entry too          
            for (var i = 0; i < postsCacheData.length; i++) {          
              if (postsCacheData[i] && postsCacheData[i].id === id) {          
                postsCacheData[i].commentsCount = count;          
                postsCacheData[i].lastCommentTime = Math.max(Number(postsCacheData[i].lastCommentTime || 0) || 0, mergedLast);          
                break;          
              }          
            }          
        
            resolve();          
          })          
          .catch(function (e2) {          
            reject(e2);          
          });          
      } catch (e0) {          
        reject(e0);          
      }          
    }).then(function () {          
      // Rerender to reflect counts / order          
      try {          
        var sm = safeText(sortMode && sortMode.value ? sortMode.value : rememberedSortMode);          
        if (sm === "lastComment" && lastCommentMetaReady) {          
          renderPostsFromCache();          
        } else {          
          renderPostsFromCache();          
        }          
      } catch (eR) { }          
    });          
  }          
        
  function ensureAllPostsMetaForLastCommentSort() {          
    try {          
      if (!isAuthed) return;          
      if (metaFetchAllRunning) return;          
        
      // If we already have lastCommentMetaReady, no need to full-pass again          
      if (lastCommentMetaReady) return;          
        
      // Start one full run: fetch meta for ALL posts          
      metaFetchAllRunning = true;          
      setStatus("××›×™×Ÿ ××™×•×Ÿ ×œ×¤×™ ×ª×’×•×‘×” ××—×¨×•× ×”â€¦ (×˜×•×¢×Ÿ ×ª×’×•×‘×•×ª)", "info");          
        
      for (var i = 0; i < postsCacheData.length; i++) {          
        if (postsCacheData[i] && postsCacheData[i].id) {          
          enqueueMeta(postsCacheData[i].id);          
        }          
      }          
        
      drainMetaQueue();          
    } catch (e) { }          
  }          
        
  function ensureVisibleMetaAndFetch() {          
    try {          
      if (!isAuthed) return;          
        
      // Limit: we bind listeners only for top N visible posts to keep WebView stable          
      var MAX_VISIBLE = 40;          
      var ids = (lastRenderedListIds && lastRenderedListIds.length) ? lastRenderedListIds.slice(0, MAX_VISIBLE) : [];          
        
      // Queue meta fetch for visible posts missing known count          
      for (var i = 0; i < ids.length; i++) {          
        var id = ids[i];          
        var meta = getMetaForPost(id) || {};          
        
        // If missing or stale, enqueue fetch          
        var need = false;          
        if (meta.commentsCount === undefined || meta.commentsCount === null) need = true;          
        if (meta.lastCommentTime === undefined || meta.lastCommentTime === null) need = true;          
        
        if (need) enqueueMeta(id);          
      }          
        
      drainMetaQueue();          
        
      // Bind live update listeners for visible posts (count + lastCommentTime, including replies)          
      bindVisibleMetaListeners(ids);          
        
      // A light periodic tick to re-ensure visible listeners (after search/sort changes)          
      if (!liveMetaTickTimer) {          
        liveMetaTickTimer = setInterval(function () {          
          try {          
            if (!isAuthed) return;          
            var ids2 = (lastRenderedListIds && lastRenderedListIds.length) ? lastRenderedListIds.slice(0, MAX_VISIBLE) : [];          
            bindVisibleMetaListeners(ids2);          
          } catch (eT) { }          
        }, 14000);          
      }          
    } catch (e0) { }          
  }          
        
  function bindVisibleMetaListeners(ids) {          
    try {          
      if (!ids) ids = [];          
        
      // Detach old listeners not in visible set          
      var keep = {};          
      for (var i = 0; i < ids.length; i++) keep[ids[i]] = true;          
        
      for (var k in visibleMetaListenerMap) {          
        if (!keep[k]) {          
          detachMetaListenersForPost(k);          
        }          
      }          
        
      // Attach new listeners          
      for (var j = 0; j < ids.length; j++) {          
        var id = ids[j];          
        if (!id) continue;          
        if (visibleMetaListenerMap[id]) continue;          
        
        attachMetaListenersForPost(id);          
      }          
    } catch (e1) { }          
  }          
        
  function detachMetaListenersForPost(postId) {          
    try {          
      var id = safeText(postId || "");          
      if (!id) return;          
        
      // value listener (count + last comment)          
      try {          
        var vref = visibleMetaValueRefMap[id];          
        if (vref) vref.off();          
      } catch (eV) { }          
        
      // last comment listener (kept; does not harm)          
      try {          
        var lref = visibleMetaLastRefMap[id];          
        if (lref) lref.off();          
      } catch (eL) { }          
        
      delete visibleMetaValueRefMap[id];          
      delete visibleMetaLastRefMap[id];          
      delete visibleMetaListenerMap[id];          
    } catch (e0) { }          
  }          
        
  function attachMetaListenersForPost(postId) {          
    try {          
      var id = safeText(postId || "");          
      if (!id) return;          
        
      visibleMetaListenerMap[id] = true;          
        
      // Listener 1: value on comments/{postId} (includes nested replies changes too)          
      var refCount = firebase.database().ref("forum A/comments/" + id);          
      visibleMetaValueRefMap[id] = refCount;          
        
      refCount.on("value", function (snap) {          
        try {          
          var meta = computeMetaFromCommentsSnapshot(snap);          
          var count = Number(meta.countTop || 0);          
          var lastTime = Number(meta.lastTime || 0);          
        
          /* =================================================================================          
             âœ… FIX (minimal): merge with existing lastCommentTime (never decrease)          
             ================================================================================= */          
          var prevMeta = getMetaForPost(id) || {};          
          var prevLast = Number(prevMeta.lastCommentTime || 0) || 0;          
          var prevItemLast = 0;          
          for (var z = 0; z < postsCacheData.length; z++) {          
            if (postsCacheData[z] && postsCacheData[z].id === id) {          
              prevItemLast = Number(postsCacheData[z].lastCommentTime || 0) || 0;          
              break;          
            }          
          }          
          var mergedLast = Math.max(prevLast, prevItemLast, lastTime);          
        
          // Update caches          
          setMetaForPost(id, { commentsCount: count, lastCommentTime: mergedLast });          
        
          for (var i = 0; i < postsCacheData.length; i++) {          
            if (postsCacheData[i] && postsCacheData[i].id === id) {          
              postsCacheData[i].commentsCount = count;          
              postsCacheData[i].lastCommentTime = Math.max(Number(postsCacheData[i].lastCommentTime || 0) || 0, mergedLast);          
              break;          
            }          
          }          
        
          var sm = safeText(sortMode && sortMode.value ? sortMode.value : rememberedSortMode);          
          if (sm === "lastComment" && lastCommentMetaReady) {          
            renderPostsFromCache();          
          } else {          
            renderPostsFromCache();          
          }          
        } catch (eU) { }          
      });          
        
      // Listener 2: last top-level comment (kept for quick signal; value listener handles replies)          
      var refLast = firebase.database().ref("forum A/comments/" + id).orderByChild("time").limitToLast(1);          
      visibleMetaLastRefMap[id] = refLast;          
        
      refLast.on("child_added", function (snap) {          
        try {          
          var v = snap.val() || {};          
          var t = Number(v.time || 0) || 0;          
        
          // update lastCommentTime quickly (may be overridden by value listener that includes replies)          
          // âœ… FIX (minimal): never decrease cache          
          var prevMeta = getMetaForPost(id) || {};          
          var prevLast = Number(prevMeta.lastCommentTime || 0) || 0;          
          var merged = Math.max(prevLast, t);          
          setMetaForPost(id, { lastCommentTime: merged });          
        
          for (var i = 0; i < postsCacheData.length; i++) {          
            if (postsCacheData[i] && postsCacheData[i].id === id) {          
              postsCacheData[i].lastCommentTime = Math.max(Number(postsCacheData[i].lastCommentTime || 0), merged);          
              break;          
            }          
          }          
        
          var sm = safeText(sortMode && sortMode.value ? sortMode.value : rememberedSortMode);          
          if (sm === "lastComment" && lastCommentMetaReady) {          
            renderPostsFromCache();          
          }          
        } catch (eL2) { }          
      });          
        
    } catch (e0) { }          
  }          
        
  // Ensure: if page is loaded already with lastComment selected, start full run once          
  try {          
    var initMode = safeText(sortMode && sortMode.value ? sortMode.value : rememberedSortMode);          
    if (initMode === "lastComment") {          
      ensureAllPostsMetaForLastCommentSort();          
    }          
  } catch (eInitLC) { }          
        
  /* =====================================================================================          
     Cleanup listeners on unload          
     ===================================================================================== */          
  window.addEventListener("beforeunload", function () {          
    try {          
      if (liveMetaTickTimer) clearInterval(liveMetaTickTimer);          
    } catch (eT) { }          
    liveMetaTickTimer = null;          
        
    try {          
      for (var k in visibleMetaListenerMap) {          
        detachMetaListenersForPost(k);          
      }          
      } catch (eOff) { }
      stopPresenceTracking();
    });
});                    
        
/* =========================================================================================          
   NEW: Upload to Storage and return PATH (secure)          
   - This avoids storing public download URLs in the DB          
   ========================================================================================= */          
function uploadPostImageToPathEx(blobOrFile, contentType, ext, postId, uid, onProgress) {          
  return new Promise(function (resolve, reject) {          
    try {          
      if (!blobOrFile || !postId || !uid) {          
        reject("missing params");          
        return;          
      }          
        
      var safeExt = safeText(ext || "").toLowerCase();          
      if (!safeExt) safeExt = "jpg";          
      if (safeExt.length > 8) safeExt = "jpg";          
        
      var name = Date.now() + "_" + uid + "." + safeExt;          
      var fullPath = "post-images/" + postId + "/" + name;          
      var ref = firebase.storage().ref(fullPath);          
        
      var meta = {};          
      try {          
        if (contentType) meta.contentType = contentType;          
        // align caches with short-lived signed url logic          
        meta.cacheControl = "private, max-age=120";          
      } catch (eM) { }          
        
      var task = null;          
      try {          
        task = ref.put(blobOrFile, meta);          
      } catch (ePut) {          
        task = ref.put(blobOrFile);          
      }          
        
      task.on("state_changed",          
        function (snap) {          
          try {          
            if (!snap) return;          
            var bytes = Number(snap.bytesTransferred || 0);          
            var total = Number(snap.totalBytes || 0);          
            if (total > 0) {          
              var pct = Math.round((bytes / total) * 100);          
              if (typeof onProgress === "function") onProgress(pct);          
            }          
          } catch (eP) { }          
        },          
        function (err) { reject(err); },          
        function () {          
          try {          
            resolve(fullPath);          
          } catch (eU) { reject(eU); }          
        }          
      );          
    } catch (e0) {          
      reject(e0);          
    }          
  });          
}          
        
/* =========================================================================================          
   FIX: Upload DataURL (stable in WebView) + progress + timeout          
   ========================================================================================= */          
function uploadPostImageDataUrlEx(dataUrl, ext, postId, uid, onProgress) {          
  return new Promise(function (resolve, reject) {          
    try {          
      if (!dataUrl || !postId || !uid) {          
        reject("missing params");          
        return;          
      }          
        
      var safeExt = safeText(ext || "").toLowerCase();          
      if (!safeExt) safeExt = "jpg";          
      if (safeExt.length > 8) safeExt = "jpg";          
        
      var name = Date.now() + "_" + uid + "." + safeExt;          
      var ref = firebase.storage().ref("post-images/" + postId + "/" + name);          
        
      var finished = false;          
      var task = ref.putString(dataUrl, "data_url");          
        
      var timer = setTimeout(function () {          
        if (finished) return;          
        finished = true;          
        try { if (task && typeof task.cancel === "function") task.cancel(); } catch (eC) { }          
        reject("upload_timeout");          
      }, 90000); // 90s watchdog          
        
      task.on("state_changed",          
        function (snap) {          
          try {          
            if (!snap) return;          
            var bytes = Number(snap.bytesTransferred || 0);          
            var total = Number(snap.totalBytes || 0);          
            if (total > 0) {          
              var pct = Math.round((bytes / total) * 100);          
              if (typeof onProgress === "function") onProgress(pct);          
            }          
          } catch (eP) { }          
        },          
        function (err) {          
          if (finished) return;          
          finished = true;          
          try { clearTimeout(timer); } catch (eT) { }          
          reject(err);          
        },          
        function () {          
          try {          
            task.snapshot.ref.getDownloadURL()          
              .then(function (url) {          
                if (finished) return;          
                finished = true;          
                try { clearTimeout(timer); } catch (eT2) { }          
                resolve(url);          
              })          
              .catch(function (eU) {          
                if (finished) return;          
                finished = true;          
                try { clearTimeout(timer); } catch (eT3) { }          
                reject(eU);          
              });          
          } catch (eU2) {          
            if (finished) return;          
            finished = true;          
            try { clearTimeout(timer); } catch (eT4) { }          
            reject(eU2);          
          }          
        }          
      );          
    } catch (e0) {          
      reject(e0);          
    }          
  });          
}          
        
/* =========================================================================================          
   Image upload (extended with progress) - keeps your original uploadPostImage untouched          
   ========================================================================================= */          
function uploadPostImageEx(blobOrFile, contentType, ext, postId, uid, onProgress) {          
  return new Promise(function (resolve, reject) {          
    try {          
      if (!blobOrFile || !postId || !uid) {          
        reject("missing params");          
        return;          
      }          
        
      var safeExt = safeText(ext || "").toLowerCase();          
      if (!safeExt) safeExt = "jpg";          
      if (safeExt.length > 8) safeExt = "jpg";          
        
      var name = Date.now() + "_" + uid + "." + safeExt;          
        
      var ref = firebase.storage().ref("post-images/" + postId + "/" + name);          
        
      var meta = {};          
      try {          
        if (contentType) meta.contentType = contentType;          
      } catch (eM) { }          
        
      var task = null;          
      try {          
        task = ref.put(blobOrFile, meta);          
      } catch (ePut) {          
        task = ref.put(blobOrFile);          
      }          
        
      task.on("state_changed",          
        function (snap) {          
          try {          
            if (!snap) return;          
            var bytes = Number(snap.bytesTransferred || 0);          
            var total = Number(snap.totalBytes || 0);          
            if (total > 0) {          
              var pct = Math.round((bytes / total) * 100);          
              if (typeof onProgress === "function") onProgress(pct);          
            }          
          } catch (eP) { }          
        },          
        function (err) { reject(err); },          
        function () {          
          try {          
            task.snapshot.ref.getDownloadURL()          
              .then(function (url) { resolve(url); })          
              .catch(reject);          
          } catch (eU) { reject(eU); }          
        }          
      );          
    } catch (e0) {          
      reject(e0);          
    }          
  });          
}          
        
/* =========================================================================================          
   ORIGINAL helper you added (unchanged)          
   ========================================================================================= */          
function uploadPostImage(file, postId, uid) {                    
  return new Promise((resolve, reject) => {                    
        
    if (!file || !postId || !uid) {                    
      reject("missing params");                    
      return;                    
    }                    
        
    const ext = file.name.split(".").pop().toLowerCase();                    
    const name = Date.now() + "_" + uid + "." + ext;                    
        
    const ref = firebase.storage()                    
      .ref("post-images/" + postId + "/" + name);                    
        
    const task = ref.put(file);                    
        
    task.on("state_changed",                    
      null,                    
      err => reject(err),                    
      () => {                    
        task.snapshot.ref.getDownloadURL()                    
          .then(url => resolve(url))                    
          .catch(reject);                    
      }                    
    );                    
  });                    
}                    
</script>                    </body>                    
</html>
